<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<div class="book"><div class="titlepage"><div><div><h1 class="title"><a name="gtdeveloper"></a>Globus Toolkit 6.0 Developer's Guide</h1></div><div><div class="abstract"><p class="title"><b>Introduction</b></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../docbook/xsl/docbook-xsl-1.78.1/images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Please note that the Best Practices need to be 
                                                updated for GT5 and are not being published at this time. 
                                    </p></td></tr></table></div><p>You can download the <a class="ulink" href="gtDeveloperGuide.pdf" target="_top">PDF version here</a>. Following are some docs you should be familiar with as well:</p><p>
                                                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                                  <a href="../../admin/install/#gtadmin" class="olink">Installation
                                                  Guide</a>
                                                  </p></li><li class="listitem"><p>
                                                  <a href="../../admin/quickstart/#quickstart" class="olink">Quickstart</a>
                                                  </p></li><li class="listitem"><p>All GT command line clients are listed <a href="../commands/#gtcommands" class="olink">here</a>.</p></li></ul></div><p>
                                                
                                    </p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="part"><a href="#idm6051777344">Asynchronous Event Handling with Examples</a></span></dt><dd><dl><dt><span class="chapter"><a href="#globus-async">1. GT 6.0: Asynchronous Event Handling</a></span></dt><dd><dl><dt><span class="section"><a href="#examples">1. Examples</a></span></dt><dt><span class="section"><a href="#EventModels">2. Event Models</a></span></dt><dd><dl><dt><span class="section"><a href="#idm6049182512">2.1. Blocking Event Model</a></span></dt><dt><span class="section"><a href="#idm6049948272">2.2. Non-blocking Event Model</a></span></dt><dt><span class="section"><a href="#idm6047586304">2.3. Asynchronous Event Model</a></span></dt></dl></dd><dt><span class="section"><a href="#CallbackLibrary">3. Callback Library</a></span></dt><dt><span class="section"><a href="#ThreadAbstraction">4. Thread Abstraction</a></span></dt><dt><span class="section"><a href="#AsynchronousModel">5. Asynchronous Model</a></span></dt><dd><dl><dt><span class="section"><a href="#idm6047532960">5.1. Blocking in Callbacks</a></span></dt></dl></dd><dt><span class="section"><a href="#Conclusion">6. Conclusion</a></span></dt><dt><span class="section"><a href="#References">7. References</a></span></dt></dl></dd><dt><span class="chapter"><a href="#globus-async-example1">2. Asynchronous Event Handling: Example 1</a></span></dt><dt><span class="chapter"><a href="#globus-async-example2">3. Asynchronous Event Handling: Example 2</a></span></dt><dt><span class="chapter"><a href="#globus-async-example3">4. Asynchronous Event Handling: Example 3</a></span></dt></dl></dd><dt><span class="appendix"><a href="#public-interfaces">A. Globus Toolkit 6.0 Public Interface Guides</a></span></dt><dt><span class="glossary"><a href="#glossary-gtDeveloper">Glossary</a></span></dt></dl></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="idm6051777344"></a>Asynchronous Event Handling with Examples</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="chapter"><a href="#globus-async">1. GT 6.0: Asynchronous Event Handling</a></span></dt><dd><dl><dt><span class="section"><a href="#examples">1. Examples</a></span></dt><dt><span class="section"><a href="#EventModels">2. Event Models</a></span></dt><dd><dl><dt><span class="section"><a href="#idm6049182512">2.1. Blocking Event Model</a></span></dt><dt><span class="section"><a href="#idm6049948272">2.2. Non-blocking Event Model</a></span></dt><dt><span class="section"><a href="#idm6047586304">2.3. Asynchronous Event Model</a></span></dt></dl></dd><dt><span class="section"><a href="#CallbackLibrary">3. Callback Library</a></span></dt><dt><span class="section"><a href="#ThreadAbstraction">4. Thread Abstraction</a></span></dt><dt><span class="section"><a href="#AsynchronousModel">5. Asynchronous Model</a></span></dt><dd><dl><dt><span class="section"><a href="#idm6047532960">5.1. Blocking in Callbacks</a></span></dt></dl></dd><dt><span class="section"><a href="#Conclusion">6. Conclusion</a></span></dt><dt><span class="section"><a href="#References">7. References</a></span></dt></dl></dd><dt><span class="chapter"><a href="#globus-async-example1">2. Asynchronous Event Handling: Example 1</a></span></dt><dt><span class="chapter"><a href="#globus-async-example2">3. Asynchronous Event Handling: Example 2</a></span></dt><dt><span class="chapter"><a href="#globus-async-example3">4. Asynchronous Event Handling: Example 3</a></span></dt></dl></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="globus-async"></a>Chapter 1. GT 6.0: Asynchronous Event Handling</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#examples">1. Examples</a></span></dt><dt><span class="section"><a href="#EventModels">2. Event Models</a></span></dt><dd><dl><dt><span class="section"><a href="#idm6049182512">2.1. Blocking Event Model</a></span></dt><dt><span class="section"><a href="#idm6049948272">2.2. Non-blocking Event Model</a></span></dt><dt><span class="section"><a href="#idm6047586304">2.3. Asynchronous Event Model</a></span></dt></dl></dd><dt><span class="section"><a href="#CallbackLibrary">3. Callback Library</a></span></dt><dt><span class="section"><a href="#ThreadAbstraction">4. Thread Abstraction</a></span></dt><dt><span class="section"><a href="#AsynchronousModel">5. Asynchronous Model</a></span></dt><dd><dl><dt><span class="section"><a href="#idm6047532960">5.1. Blocking in Callbacks</a></span></dt></dl></dd><dt><span class="section"><a href="#Conclusion">6. Conclusion</a></span></dt><dt><span class="section"><a href="#References">7. References</a></span></dt></dl></div><p>The Globus Toolkit contains several APIs written in C for creating grid applications.  Each of these components is built on a coherent asynchronous event model.  This text will introduce and explain the philosophy behind the model and its basic concepts.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="examples"></a>1. Examples</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a href="#globus-async-example1" class="olink">Example 1</a> - Demonstrates basic use of <code class="computeroutput">globus_callback_register_oneshot()</code></p></li><li class="listitem"><p><a href="#globus-async-example2" class="olink">Example 2</a> - An example of <code class="computeroutput">globus_callback_register_oneshot()</code> using condition variables</p></li><li class="listitem"><p><a href="#globus-async-example3" class="olink">Example 3</a> - Game of Craps example demonstrates a more complex use of the asynchronous event model</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="EventModels"></a>2. Event Models</h2></div></div></div><p>The Globus Toolkit uses an <span class="strong"><strong>asynchronous event model</strong></span>.  
  Details of this model are contained in the remainder of this text but it will be helpful to take a few examples of other popular models.</p><p>
Applications existing in event heavy environments, such as graphical user interfaces
  (GUIs), IO, or inter-process signaling, must implement some event
model.  Events are characterized by changes in the environment at an undetermined
time. There are several different popular models used to handle such events.
We provide examples of them here, and then describe in detail the asynchronous
event model used by the Globus Toolkit.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm6049182512"></a>2.1. Blocking Event Model</h3></div></div></div><p>In a blocking API, an event is serviced, delaying all processing in the current
    thread of execution until the event completes. This has the obvious disadvantage
    that no processing can be done while waiting on the IO. Typically this is
    solved by forking additional processes or creating additional threads to
    service each event. However, more processes and more threads make a more
    resource intensive application.
</p><p><span class="strong"><strong>Example: Blocking Event Model</strong></span></p><pre class="screen">
main()
{
    while(!done)
    {
        ~ other processing ~
        data = ReadData();
        ~ process event ~
    }
}
    </pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm6049948272"></a>2.2. Non-blocking Event Model</h3></div></div></div><p>A non-blocking model follows the same in-line procedural model as blocking
    except that events are polled for completion. Instead of blocking all processing
    until the event completes, the user asks if the event is complete. If so,
    the event is processed. If not, other processing may resume.</p><p><span class="strong"><strong>Example: Non-blocking Event Model</strong></span></p><pre class="screen">
main()
{
    while(!done)
    {
        if(EventIsReady())
        {
            ~ process event ~
        }
        else
        {
            ~ other processing ~
        }
    }
}
    </pre><p>Unlike the blocking model, this approach allows for simultaneous processing
      while waiting for the event.  However, it can become cumbersome as more
    and more events are added. Further, if there is no other processing to
      be done, it results in tight spin loops that use the CPU simply to poll
  for events.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm6047586304"></a>2.3. Asynchronous Event Model</h3></div></div></div><p>The asynchronous approach does not follow the in-line procedure.  Instead
    events are given handler functions.  A user registers for an event with
    the system, giving it a handler function.  When the event occurs the system
    calls the user's handler function.
</p><p><span class="strong"><strong>Example: Asynchronous Event Model</strong></span>
    </p><pre class="screen">
event_handler()
{
    process event
    register_next_event();
}

main()
{
    ~ other processing ~
    register_event()
    ~ other processing ~
    while(!done)
    {
        wait_for_events();
    }
}
    </pre><p>Like the non-blocking model, this allows simultaneous event and data processing.
    In this model, programs are designed as a series of events rather than a
    serial execution of instructions. A programmer registers events and when they occur the necessary processing is done. Additional events may then be registered and the program goes back to waiting for events. This is the approach taken by the Globus Toolkit.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="CallbackLibrary"></a>3. Callback Library</h2></div></div></div><p>The heart of the Globus event model is the callback library.  This API provides
  a user with functionality for asynchronous time events. In order to use the
  API for events, the user must implement a function (the callback) that is called
when the event has occurred and processes it. </p><p>There are two fundamental functions
    that explain the API: </p><pre class="screen">
globus_result_t
globus_callback_register_oneshot(
    globus_callback_handle_t *          callback_handle,
    const globus_reltime_t *            delay_time,
    globus_callback_func_t              callback_func,
    void *                              callback_user_args);

globus_result_t
globus_poll();
</pre><p>The first function is fairly clear. It registers the callback <code class="computeroutput">callback_func</code> with the system that will be called 
  once the time specified by <code class="computeroutput">delay_time</code> has expired.  </p><p>The more interesting of the two is <code class="computeroutput">globus_poll()</code>. Semantically
  this function is used to briefly turn control over to the Globus event system
  for processing. What this means is that <code class="computeroutput">globus_poll()</code> must be
  called often enough for the Globus event system to function. This is recognized as a rather ambiguous statement. Therefore, a look at what happens with <code class="computeroutput">globus_poll()</code> should
  assist in explanation. In threaded builds of Globus this <code class="computeroutput">globus_poll()</code> simply results in a call to <code class="computeroutput">thread_yield()</code> where control can be
  switched to a background thread dedicated to event processing. In non-threaded
  builds, a list of events is maintained by the system. A call to <code class="computeroutput">globus_poll()</code> finds
  ready events in the list and dispatches the associated callback to the user
  within the same call stack.</p><p>
In <a href="#globus-async-example1" class="olink">Example 1</a> a use of
these two functions is displayed. The function <code class="computeroutput">user_callback</code> is
registered for execution after 1 second has elapsed. </p><p>In a non-threaded build,
  there is a single thread of execution. In the main loop, the call to <code class="computeroutput">globus_poll()</code> invokes
  the Globus event process code. The code checks internal data structures for
  any ready events. If found, the user callbacks associated with the events will
  be called in the same call stack.</p><p>
In a threaded build a user would see two threads (possibly more, but for the
  sake of clarity two will be used): the main thread that is executing the loop
  in <code class="computeroutput">main()</code> and an internal Globus thread that is handling polling
  of events. The Globus thread is created when the user calls <code class="computeroutput">globus_module_activate(GLOBUS_COMMON_MODULE)</code>.  This
  function must be called before any API function in the the <code class="computeroutput">globus_common</code> package
  can be used. This is another common theme in Globus: all modules must be activated
  before use and deactivated when finished. The event thread polls all events
  and as they become ready the functions associated with them are dispatched.</p><p>
Another important concept to note in this API is the use of the <code class="computeroutput">void * user_arg</code> parameter.  This is a simple but important part of the model.
On registration of an event, a user can pass in a void pointer and this pointer
will be threaded through to their event callback. The pointer can point to any
bit of memory the user likes. Typically it points to some structure that allows
the user to maintain state throughout a series of event callbacks. This memory
is completely managed by the user, so if the memory is used in the event callback the user needs to be careful to <span class="strong"><strong>not</strong></span> free the memory until the callback occurs.
For a more complicated example of this see <a href="#globus-async-example2" class="olink">Example 2</a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="ThreadAbstraction"></a>4. Thread Abstraction</h2></div></div></div><p>The first thing to look at in understanding the Globus event model is the thread
abstraction layer. Globus can be built in a variety of ways with regard to the
underlying thread system. It can be built with pthreads, win32
threads, or non threaded depending on the user's preferences and the available
packages on the system. All builds present the same API. This thread API is very
much akin to pthreads. If the reader is not familiar with pthreads, we recommend
reading the  pthread manual. The more notable API interface is
presented below:</p><pre class="screen">
int
globus_thread_create(
    globus_thread_t *           thread,
    globus_threadattr_t *       attr,
    globus_thread_func_t        func,
    void *                      user_arg);

int
globus_mutex_lock(
    globus_mutex_t *            mutex);

int
globus_mutex_unlock(
    globus_mutex_t *            mutex);

int
globus_cond_wait(
    globus_cond_t *             cond,
    globus_mutex_t *            mutex);

int
globus_cond_signal(
    globus_cond_t *             cond);
</pre><p>It is important to note that this is <span class="strong"><strong>not</strong></span> a complete set 
  of necessary functions to properly use the threaded API. However, for the
  purposes of this text, they will serve for an explanation.  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="computeroutput">globus_thread_create()</code> will
      start a new thread of execution with a new call stack running beginning
    at the parameter <code class="computeroutput">func</code>. </p></li><li class="listitem"><p><code class="computeroutput">globus_mutex_lock()</code> and <code class="computeroutput">globus_mutex_unlock()</code> provide
          mutual exclusive among threads over critical sections of code.</p></li><li class="listitem"><p><code class="computeroutput">globus_cond_wait()</code> and <code class="computeroutput">globus_cond_signal()</code> provide
            a means of thread synchronization. </p></li><li class="listitem"><p><code class="computeroutput">wait()</code> will delay the
              thread that calls it until some other thread calls <code class="computeroutput">signal()</code>.</p></li></ul></div><p>
In most cases the thread layer abstraction is a very thin pass through to the
underlying thread package. </p><p>The notable exception is the non-threaded build.
    The Globus Toolkit has created a non-threaded, semantically equivalent implementation
    of all the functions described above (and of most in the pthreads API) with
  the exception of <code class="computeroutput">globus_thread_create()</code>.  In the non-threaded
  case this is a no-op. However the model of asynchronous programming used in
  the Globus Toolkit, <code class="computeroutput">globus_thread_create()</code> is rarely needed or
  used.</p><p>
In the Globus model, the callback code and the thread abstraction are coupled.  <a href="#globus-async-example2" class="olink">Example
2</a> shows how this coupling works:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>An event is registered in the main
    thread, then <code class="computeroutput">globus_cond_wait()</code> is called. </p></li><li class="listitem"><p>When the event has
    been processed, the handler is called.</p></li><li class="listitem"><p>The handler signals the wait that
    it may continue, then exits.</p></li><li class="listitem"><p>The signal awakens the wait so the main thread
    may continue. </p></li><li class="listitem"><p>The main thread then exits. </p></li></ol></div><p>
In the threaded build, <code class="computeroutput">globus_cond_wait()</code> and <code class="computeroutput">globus_cond_signal()</code> are
simple passes through to the underlying thread packages, and as described previously,
a background thread delivers the event. </p><p>In the non-threaded build, <code class="computeroutput">globus_cond_wait()</code> will
  call <code class="computeroutput">globus_poll()</code> and the non-threaded polling code takes over.
  For this reason, it is often not necessary to call <code class="computeroutput">globus_poll()</code> in
  non-threaded builds. <code class="computeroutput">globus_cond_wait()</code> tends to be used often
  enough to satisfy the needs of the event system.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="AsynchronousModel"></a>5. Asynchronous Model</h2></div></div></div><p>In many ways, the asynchronous programming model is the most difficult of the
three presented. The blocking model is clearly the easiest, because everything
happens in-line, and when the event function (like a read or a write) returns,
the event has completed and all data is available. Events in this model are treated
just like any other function call and are therefore easily dealt with by programmers
with modest logic skills.</p><p>
The non-blocking model is a bit more complicated than blocking, but not much.
  The only twist is that a user must check to see if the event completed and,
  if so, how much of it completed. This still allows for in-line processing;
  it only requires an additional <code class="computeroutput">if</code> statement. Even when event polling is multiplexed
  (for example, posix select) the processing is still inline. The user must
  add some branches to determine what event is ready and then process it. The
  most difficult challenge of the non-blocking model is making use of the idle
  time when no events are ready.</p><p>
In both  non-blocking and blocking, the user has easy, in-line control over 
  when an event is processed. If there is any logic that must occur before the
  event, the user simply needs to complete that processing before calling either
  the blocking function or the non-blocking function which checks for ready events.
  The asynchronous model removes this luxury. In the asynchronous model events
  can occur at any time. This can complicate the logic of keeping critical sections
  of code safe. Further complication is caused by the fact that they come
  in via their own handlers. This removes the luxury of maintaining state on
  the local stack. Instead all state must be packed into heap allocated structures
  which are passed to the callbacks via void * pointers (see the monitor structure
  in <a href="#globus-async-example2" class="olink">Example 2</a>).</p><p>
The upside to the asynchronous model is that it forces cleaner, more well thought
  out code. The non-blocking model does not scale well. As more events are managed,
  the event processing code becomes unmanageable, typically resulting in a
  single function that is far too long and far too interdependent for practical
  maintenance. Since users can use local variables, the tendency is to use many
  different flags to control state instead of a clean, well thought out state
  machine. This is especially true with software that evolves over time, growing
  in complexity.</p><p>
In contrast the asynchronous model scales very well.  Every event has a clean
  separation of being scoped to a user handler function. All shared states among
  events must be encapsulated into a data structure. A side effect of these two
  characteristics is that it is easier for a user to define and follow a state
  machine then it is to create spaghetti logic based on many flags.</p><p>
<a class="ulink" href="globus-async-example3.html" target="_top">Example 3</a> shows a proper
use of the asynchronous model. This example simulates the game of Craps. Craps
is a dice game, the rules of which can be found with a simple web search, but
  the following state diagram should explain the rules well enough for this example.</p><div class="figure"><a name="idm6047538000"></a><p class="title"><b>Figure 1.1. State Diagram</b></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="state_diagram.png" align="middle" alt="State Diagram"></div></div></div><br class="figure-break"><p>
<a href="#globus-async-example3" class="olink">Example 3</a> follows this
state diagram. In the example rolls of the dice are considered events. For the
sake of simplicity the example only uses a one shot event and then gets the data
by calling <code class="computeroutput">random();</code>  If this were a real world event, the values
for the dice would come in as part of the event function. Notice how each time
the event occurs the state is checked and, if needed, advanced to the next state.
In the main function the program waits until the state machine comes to the final stage, where it signals the wait and allows for the program to end.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm6047532960"></a>5.1. Blocking in Callbacks</h3></div></div></div><p>What happens if an event handler blocks?  The correct answer to this question
    is: <span class="strong"><strong>They never should</strong></span>.  This answer is of course a bit naive.  There
    will be times when blocking in a callback is the only solution, and there
    will be even more times when it is the chosen solution, albeit the wrong
    one. Therefore, the Globus Toolkit does have mechanisms to allow this. That
    said, a user should make every effort to find alternative solutions to blocking
    in event callbacks. If the only solution is to block in a callback it could
    be an indication that the state machine is erroneous.
</p><p>
  If an event callback is going to block, it must call the following function:
  <code class="computeroutput">void globus_thread_blocking_will_block();</code>
  If <code class="computeroutput">globus_cond_wait()</code> is called, this function is implied.
</p><p>
  In the threaded build of Globus there is a background thread that handles
    the polling of events and dispatching of the handler functions. When a
    handler function blocks, it prevents this process.  <code class="computeroutput">globus_thread_blocking_will_block()</code> starts
      a new thread to handle event processing and allows the user to take over
      the current thread without stopping the processing of other threads. The
      user must also call <code class="computeroutput">globus_poll()</code> in order to ensure that
event processing continues. </p><p>This is needed:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>in the threaded case to yield
                the user's processing thread to the system event thread.</p></li><li class="listitem"><p> in the non
                  threaded case so that the only thread can make a non-blocking
    run through of any ready events.</p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="Conclusion"></a>6. Conclusion</h2></div></div></div><p>The Globus Toolkit is middleware for the grid.  Because grid infrastructure often
depends heavily on both push and pull notifications (remote events), the callback
style event handling model the Globus Toolkit provides is essential. It allows
entire APIs within the toolkit to be designed with asynchronous functions that
use the event handling model. Once an API provides that asynchronous functionality
(such as XIO), software that builds on top of it can leverage this functionality.
This eases the burden of the application programmer, as they need only to implement
a callback function to handle possibly many notification events efficiently,
instead of stopping execution until one is received, or managing multiple threads.  </p><p>
In the Globus Toolkit, because of the thread abstraction it provides, threads
  are managed by the underlying code base, so that the developer can be ignorant of using threads but still be able to get their benefits, simply
  by specifying a compile time switch. Overall, this flexibility is quite powerful,
  which is why we encourage the use of this model when designing and developing
  your own software components using the Globus Toolkit.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="References"></a>7. References</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="ulink" href="http://www.opengroup.org/onlinepubs/007908799/xsh/pthread.h.html" target="_top">Posix Threads API</a></p></li><li class="listitem"><p><a class="ulink" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/fileio/base/i_o_completion_ports.asp" target="_top">Microsoft's description of Completion Ports and Thread Pooling</a></p></li><li class="listitem"><p><a class="ulink" href="http://www-unix.globus.org/api/c-globus-%24%7Bversion%7D/globus_common/html/index.html" target="_top">Globus Common API</a></p></li><li class="listitem"><p><a class="ulink" href="http://www.cs.bgu.ac.il/~elhadad/se/events.html" target="_top">Documentation on Programming with Events</a></p></li></ul></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="globus-async-example1"></a>Chapter 2. GT 6.0: Asynchronous Event Handling: Example 1</h2></div></div></div><pre class="screen">#include &lt;globus_common.h&gt;

void
user_callback(
    void *                              user_arg)
{
    int *                               count;

    count = (int *) user_arg;
    fprintf(stdout, "User callback, count = %d\n", *count);
    exit(0);
}

int
main(
    int                                 argc,
    char **                             argv)
{
    globus_reltime_t                    delay;
    int                                 count = 0;

    globus_module_activate(GLOBUS_COMMON_MODULE);

    GlobusTimeReltimeSet(delay, 1, 0);
    globus_callback_register_oneshot(
        NULL,
        &amp;delay,
        user_callback,
        &amp;count);

    while(1)
    {
        usleep(10000);
        globus_poll_nonblocking();
        fprintf(stdout, "After poll\n");
        count++;
    }

    globus_module_deactivate(GLOBUS_COMMON_MODULE);

    return 0;
}
</pre></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="globus-async-example2"></a>Chapter 3. GT 6.0: Asynchronous Event Handling: Example 2</h2></div></div></div><pre class="screen">#include &lt;globus_common.h&gt;

struct test_monitor_s
{
    globus_mutex_t                      mutex;
    globus_cond_t                       cond;
    globus_bool_t                       done;
};

void
user_callback(
    void *                              user_arg)
{
    struct test_monitor_s *              monitor;

    monitor = (struct test_monitor_s *) user_arg;

    globus_mutex_lock(&amp;monitor-&gt;mutex);
    {
        fprintf(stdout, "Signaling the wait\n");
        monitor-&gt;done = GLOBUS_TRUE;
        globus_cond_signal(&amp;monitor.cond);
    }
    globus_mutex_unlock(&amp;monitor-&gt;mutex);
}

int
main(
    int                                 argc,
    char **                             argv)
{
    struct test_monitor_s               monitor;
    globus_reltime_t                    delay;

    globus_module_activate(GLOBUS_COMMON_MODULE);

    globus_mutex_init(&amp;monitor.mutex, NULL);
    globus_cond_init(&amp;monitor.cond, NULL);
    monitor.done = GLOBUS_FALSE;

    globus_mutex_lock(&amp;monitor.mutex);
    {
        GlobusTimeReltimeSet(delay, 1, 0);
        globus_callback_register_oneshot(
            NULL,
            &amp;delay,
            user_callback,
            &amp;monitor);

        while(!monitor.done)
        {
            fprintf(stdout, "waiting...\n");
            globus_cond_wait(&amp;monitor.cond, &amp;monitor.mutex);
        }
    }
    globus_mutex_unlock(&amp;monitor.mutex);

    globus_module_deactivate(GLOBUS_COMMON_MODULE);

    fprintf(stdout, "Done\n");

    return 0;
}

</pre></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="globus-async-example3"></a>Chapter 4. GT 6.0: Asynchronous Event Handling: Example 3</h2></div></div></div><pre class="screen">#include &lt;globus_common.h&gt;
#include &lt;stdlib.h&gt;


typedef enum game_state_e
{
    FIRST_ROLL,
    ROLLING,
    LOST_GAME,
    WON_GAME
} game_state_t;

typedef struct game_context_s
{
    globus_mutex_t                      mutex;
    globus_cond_t                       cond;
    game_state_t                        state;
    int                                 rolls;
    int                                 point;
} game_context_t;

void
event_callback(
    void *                              user_arg)
{
    int                                 die1;
    int                                 die2;
    game_context_t *                    game_context;

    game_context = (game_context_t *) user_arg;

    die1 = rand() % 6 + 1;
    die2 = rand() % 6 + 1;

    globus_mutex_lock(&amp;game_context-&gt;mutex);
    {
        game_context-&gt;rolls++;
        fprintf(stdout, "you rolled %d and %d, total is %d\n", 
            die1, die2, die1+die2);
        switch(game_context-&gt;state)
        {
            case FIRST_ROLL:
                if(die1+die2 == 7 || die1+die2 == 11)
                {
                    game_context-&gt;state = WON_GAME;
                    globus_cond_signal(&amp;game_context-&gt;cond);
                }
                else if(die1+die2 == 2 || die1+die2 == 3 || die1+die2 == 12)
                {
                    game_context-&gt;state = LOST_GAME;
                    globus_cond_signal(&amp;game_context-&gt;cond);
                }
                else
                {
                    game_context-&gt;state = ROLLING;
                    game_context-&gt;point = die1+die2;
                    fprintf(stdout, "The point is: %d\n", game_context-&gt;point);
                    globus_callback_register_oneshot(
                        NULL,
                        NULL,
                        event_callback,
                        game_context);
                }
                break;

            case ROLLING:
                if(die1+die2 == 7)
                {
                    game_context-&gt;state = LOST_GAME;
                    globus_cond_signal(&amp;game_context-&gt;cond);
                }
                else if(die1+die2 == game_context-&gt;point)
                {
                    game_context-&gt;state = WON_GAME;
                    globus_cond_signal(&amp;game_context-&gt;cond);
                }
                else
                {
                    globus_callback_register_oneshot(
                        NULL,
                        NULL,
                        event_callback,
                        game_context);
                }
                break;

            default:
                globus_assert(0 &amp;&amp; "should never reach this state");
                break;
        }
    }
    globus_mutex_unlock(&amp;game_context-&gt;mutex);
}

int
main(
    int                                 argc,
    char **                             argv)
{
    game_context_t                      game_context;

    globus_module_activate(GLOBUS_COMMON_MODULE);

    globus_mutex_init(&amp;game_context.mutex, NULL);
    globus_cond_init(&amp;game_context.cond, NULL);
    game_context.rolls = 0;
    game_context.state = FIRST_ROLL;

    srandom(time(NULL));

    globus_mutex_lock(&amp;game_context.mutex);
    {
        globus_callback_register_oneshot(
            NULL,
            NULL,
            event_callback,
            &amp;game_context);

        while(game_context.state != LOST_GAME &amp;&amp; 
                game_context.state != WON_GAME)
        {
            globus_cond_wait(&amp;game_context.cond, &amp;game_context.mutex);
        }
    }
    globus_mutex_unlock(&amp;game_context.mutex);

    fprintf(stdout, "%s, game over in %d rolls.\n", 
        game_context.state == LOST_GAME ? "You LOSE" : "You WIN", 
        game_context.rolls);

    globus_module_deactivate(GLOBUS_COMMON_MODULE);
    return 0;
}


</pre></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="public-interfaces"></a>Appendix A. Globus Toolkit 6.0 Public Interface Guides</h1></div></div></div><p>This page contains links to each GT 6.0 component's Public Interfaces Guide.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a href="../../gridftp/pi/#gridftpPI" class="olink">GridFTP</a></li><li class="listitem"><a href="../../gram5/pi/#gram5PI" class="olink">GRAM5</a></li><li class="listitem"><p class="simpara">Security</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
                              <a href="../../gsic/pi/#gsicPI" class="olink">GSI C</a>
                         </li><li class="listitem">
                              <a href="../../myproxy/pi/#myproxyPI" class="olink">MyProxy</a>
                         </li><li class="listitem">
                              <a href="../../gsiopenssh/pi/#gsiopensshPI" class="olink">GSI-OpenSSH</a>
                         </li></ul></div></li><li class="listitem"><p class="simpara">Common Runtime Components</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
                              <a href="../../xio/pi/#xioPI" class="olink">XIO</a>
                         </li><li class="listitem">
                              <a href="../../ccommonlib/pi/#ccommonlibPI" class="olink">C Common Libraries</a>
                         </li></ul></div></li></ul></div></div><div class="glossary"><div class="titlepage"><div><div><h1 class="title"><a name="glossary-gtDeveloper"></a>Glossary</h1></div></div></div></div></div>
