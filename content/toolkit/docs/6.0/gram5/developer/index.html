<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<div class="book"><div class="titlepage"><div><div><h1 class="title"><a name="gram5Developer"></a>GT 6.0 GRAM5: Developer's Guide</h1></div><div><div class="abstract"><p class="title"><b>Introduction</b></p><p>
  This guide is intended to help a developer interact with GRAM5. It includes
  sections on implementing clients in C and implementing a Local Resource
  Manager interface, as well as an overview of concepts and APIs used to
  interact with GRAM.
</p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="part"><a href="#idm136351995232">I. Introduction</a></span></dt><dd><dl><dt><span class="chapter"><a href="#gram5-developer-beforeyoubegin">1. Before you begin</a></span></dt><dd><dl><dt><span class="section"><a href="#gram5-features">1. Feature summary</a></span></dt><dt><span class="section"><a href="#gram5-platforms">2. Tested platforms</a></span></dt><dt><span class="section"><a href="#gram5-compatibility">3. Backward compatibility summary</a></span></dt><dt><span class="section"><a href="#gram5-dependencies">4. Technology dependencies</a></span></dt><dt><span class="section"><a href="#gram5-security-considerations">5. Security Considerations</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136351468928">5.1. Gatekeeper Security Considerations</a></span></dt><dt><span class="section"><a href="#idm136345139424">5.2. Job Manager Security Considerations</a></span></dt><dt><span class="section"><a href="#idm136350461584">5.3. Fork SEG Module Security Considerations</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#gram5-developer-concepts">2. GRAM5 Concepts for Developers</a></span></dt><dd><dl><dt><span class="section"><a href="#gram5-developer-concepts-blocking">1. Blocking and Nonblocking Function Variants</a></span></dt><dt><span class="section"><a href="#idm136351983152">2. Service Contact Strings</a></span></dt><dd><dl><dt><span class="section"><a href="#gram5-developer-resource-names">2.1. Resource Names</a></span></dt></dl></dd><dt><span class="section"><a href="#gram5-developer-jobstatecallbacks">3. Job State Callbacks and Polling</a></span></dt><dt><span class="section"><a href="#idm136351930016">4. Credential Management</a></span></dt><dt><span class="section"><a href="#idm136351927088">5. RSL</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#idm136351925360">II. GRAM Client Developer's Guide</a></span></dt><dd><dl><dt><span class="chapter"><a href="#gram5-developer-scenarios">3. Basic GRAM Client Scenarios</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136351922640">1. "Ping" a Job Manager</a></span></dt><dt><span class="section"><a href="#idm136351919936">2. Check a Job Manager Version</a></span></dt><dt><span class="section"><a href="#idm136351917328">3. Submitting a Job</a></span></dt><dt><span class="section"><a href="#idm136351914896">4. Submitting a Job and Processing Job State Callbacks</a></span></dt><dt><span class="section"><a href="#idm136351912288">5. Polling Job Status</a></span></dt><dt><span class="section"><a href="#idm136351909680">6. Canceling a Job</a></span></dt><dt><span class="section"><a href="#idm136351907248">7. Refreshing Job Credential</a></span></dt></dl></dd><dt><span class="chapter"><a href="#gram5-developer-scenarios-advanced">4. Advanced GRAM Client Scenarios</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136351903760">1. Non-blocking Job Submission</a></span></dt><dt><span class="section"><a href="#idm136351900480">2. Custom Security Attributes</a></span></dt><dt><span class="section"><a href="#idm136351897920">3. Modifying RSL</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#idm136351895072">III. GRAM Server Developer's Guide</a></span></dt><dd><dl><dt><span class="chapter"><a href="#gram5-developer-lrm-adapter-tutorial">5. LRM Adapter Tutorial</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136336836896">1. Introduction</a></span></dt><dt><span class="section"><a href="#idm136335987504">2. Parts of a GRAM5 LRM Adapter</a></span></dt><dt><span class="section"><a href="#gram5-lrma-tutorial-rvf">3. RSL Validation File</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136335997456">3.1. RVF Attributes</a></span></dt><dt><span class="section"><a href="#idm136336025888">3.2. Creating a RSL Validation File for the Fake LRM</a></span></dt></dl></dd><dt><span class="section"><a href="#idm136336052464">4. Configuration File</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136336046912">4.1. Parsing the Configuration File</a></span></dt></dl></dd><dt><span class="section"><a href="#gram5-lrma-tutorial-perl">5. LRM Adapter Perl Module</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136336071008">5.1. Perl LRM Adapter Module</a></span></dt></dl></dd><dt><span class="section"><a href="#gram5-developer-lrm-adapter-tutorial-seg">6. LRM SEG Module</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136336113984">6.1. Intro</a></span></dt><dt><span class="section"><a href="#idm136336131936">6.2. Outline</a></span></dt><dt><span class="section"><a href="#gram5-lrm-seg-depdendencies">6.3. LRM Module Dependencies</a></span></dt><dt><span class="section"><a href="#gram5-lrm-seg-module-specific-data">6.4. Module Specific Data</a></span></dt><dt><span class="section"><a href="#gram5-lrm-seg-module-prototypes">6.5. Module Specific Prototypes</a></span></dt><dt><span class="section"><a href="#gram5-lrm-seg-module-descriptor">6.6. Extension Module Descriptor</a></span></dt><dt><span class="section"><a href="#gram5-lrm-seg-module-activation">6.7. Module Activation</a></span></dt><dt><span class="section"><a href="#gram5-lrm-seg-module-deactivation">6.8. Module Deactivation</a></span></dt><dt><span class="section"><a href="#gram5-lrm-seg-module-process">6.9. Process Events</a></span></dt><dt><span class="section"><a href="#gram5-lrm-seg-module-utils">6.10. Utility Functions</a></span></dt></dl></dd><dt><span class="section"><a href="#gram5-lrma-tutorial-perl-changes">7. Changes from Previous Versions</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136336255856">7.1. Changes in GT 5.2</a></span></dt><dt><span class="section"><a href="#idm136336254112">7.2. Changes in GT 5.0</a></span></dt><dt><span class="section"><a href="#idm136336252096">7.3. Changes in GT 4.0</a></span></dt><dt><span class="section"><a href="#idm136336284640">7.4. Changes in GT 3.2</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="#idm136351893664">IV. GRAM5 Developer's Reference</a></span></dt><dd><dl><dt><span class="chapter"><a href="#gram5-apis">6. APIs</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136313777376">1. Programming Model Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136313764096">1.1. C API Documentation Links</a></span></dt><dt><span class="section"><a href="#idm136315038960">1.2. GRAM5 Perl API Reference</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#gram5-rsl">7. RSL Specification v1.1</a></span></dt><dd><dl><dt><span class="section"><a href="#gram5-rsl-syntax-overview">1. RSL Syntax Overview</a></span></dt><dt><span class="section"><a href="#gram5-rsl-tokenization-overview">2. RSL Tokenization Overview</a></span></dt><dt><span class="section"><a href="#gram5-rsl-substitution-semantics">3. RSL Substitution Semantics</a></span></dt><dt><span class="section"><a href="#gram5-rsl-attribute-summary">4. RSL Attribute Summary</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#idm136312716704">rsl</a></span><span class="refpurpose"> &#8212; GRAM5 RSL Attributes</span></dt></dl></dd><dt><span class="section"><a href="#gram5-rsl-examples">5. Simple RSL Examples</a></span></dt><dt><span class="section"><a href="#gram5-rsl-grammar-and-tokenization-rules">6. RSL grammar and tokenization rules</a></span></dt></dl></dd><dt><span class="chapter"><a href="#gram5-debugging">8. Debugging</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136317281280">1. Basic Debugging Methods</a></span></dt><dt><span class="section"><a href="#idm136339247968">2. Advanced Debugging Methods</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136339246784">2.1. Debugging the Job Manager</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#gram5-troubleshooting">9. Troubleshooting</a></span></dt><dd><dl><dt><span class="section"><a href="#gram5-troubleshooting-client">1. GRAM Client Troubleshooting</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136318052688">1.1. Credential Problems</a></span></dt><dt><span class="section"><a href="#idm136339225792">1.2. Connection Problems</a></span></dt><dt><span class="section"><a href="#idm136313256336">1.3. Jobs are Hanging</a></span></dt><dt><span class="section"><a href="#idm136313645040">1.4. Logs and Debugging</a></span></dt><dt><span class="section"><a href="#idm136313543936">1.5. Diagnosing LRM Errors</a></span></dt><dt><span class="section"><a href="#idm136313535872">1.6. Email Support</a></span></dt></dl></dd><dt><span class="section"><a href="#gram5-troubleshooting-admin">2. Admin Troubleshooting</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136313531392">2.1. Security</a></span></dt><dt><span class="section"><a href="#idm136313407344">2.2. Verify that Services are Running</a></span></dt><dt><span class="section"><a href="#idm136313397136">2.3. Verify that LRM packages are installed</a></span></dt><dt><span class="section"><a href="#idm136313499984">2.4. Verify that the LRM packages are configured</a></span></dt><dt><span class="section"><a href="#gram5-troubleshooting-gatekeeper-log">2.5. Check the Gatekeeper Log</a></span></dt><dt><span class="section"><a href="#gram5-troubleshooting-jobmanager-log">2.6. Job Manager Logs</a></span></dt><dt><span class="section"><a href="#idm136313920048">2.7. Email Support</a></span></dt></dl></dd><dt><span class="section"><a href="#gram5-error-codes">3. Errors</a></span></dt></dl></dd><dt><span class="chapter"><a href="#gram5-developer-protocols">10. Semantics and syntax of protocols</a></span></dt><dd><dl><dt><span class="section"><a href="#gram5-interface-protocol">1. GRAM5 Protocol</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136340584064">1.1. Framing</a></span></dt><dt><span class="section"><a href="#idm136336970640">1.2. Message Format</a></span></dt><dt><span class="section"><a href="#idm136318072608">1.3. Message Types</a></span></dt><dt><span class="section"><a href="#gram5-state-model">1.4. Job State Model</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="#gram5-developer-relateddocs">11. Related Documentation</a></span></dt><dt><span class="chapter"><a href="#gram5-developer-internal-components">12. Internal Components</a></span></dt><dt><span class="glossary"><a href="#glossary-gram5Developer">Glossary</a></span></dt><dt><span class="index"><a href="#idm136351883808">Index</a></span></dt></dl></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="idm136351995232"></a>Introduction</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="chapter"><a href="#gram5-developer-beforeyoubegin">1. Before you begin</a></span></dt><dd><dl><dt><span class="section"><a href="#gram5-features">1. Feature summary</a></span></dt><dt><span class="section"><a href="#gram5-platforms">2. Tested platforms</a></span></dt><dt><span class="section"><a href="#gram5-compatibility">3. Backward compatibility summary</a></span></dt><dt><span class="section"><a href="#gram5-dependencies">4. Technology dependencies</a></span></dt><dt><span class="section"><a href="#gram5-security-considerations">5. Security Considerations</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136351468928">5.1. Gatekeeper Security Considerations</a></span></dt><dt><span class="section"><a href="#idm136345139424">5.2. Job Manager Security Considerations</a></span></dt><dt><span class="section"><a href="#idm136350461584">5.3. Fork SEG Module Security Considerations</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#gram5-developer-concepts">2. GRAM5 Concepts for Developers</a></span></dt><dd><dl><dt><span class="section"><a href="#gram5-developer-concepts-blocking">1. Blocking and Nonblocking Function Variants</a></span></dt><dt><span class="section"><a href="#idm136351983152">2. Service Contact Strings</a></span></dt><dd><dl><dt><span class="section"><a href="#gram5-developer-resource-names">2.1. Resource Names</a></span></dt></dl></dd><dt><span class="section"><a href="#gram5-developer-jobstatecallbacks">3. Job State Callbacks and Polling</a></span></dt><dt><span class="section"><a href="#idm136351930016">4. Credential Management</a></span></dt><dt><span class="section"><a href="#idm136351927088">5. RSL</a></span></dt></dl></dd></dl></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-developer-beforeyoubegin"></a>Chapter 1. Before you begin</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#gram5-features">1. Feature summary</a></span></dt><dt><span class="section"><a href="#gram5-platforms">2. Tested platforms</a></span></dt><dt><span class="section"><a href="#gram5-compatibility">3. Backward compatibility summary</a></span></dt><dt><span class="section"><a href="#gram5-dependencies">4. Technology dependencies</a></span></dt><dt><span class="section"><a href="#gram5-security-considerations">5. Security Considerations</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136351468928">5.1. Gatekeeper Security Considerations</a></span></dt><dt><span class="section"><a href="#idm136345139424">5.2. Job Manager Security Considerations</a></span></dt><dt><span class="section"><a href="#idm136350461584">5.3. Fork SEG Module Security Considerations</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-features"></a>1. Feature summary</h2></div></div></div><a class="indexterm" name="idm136347612000"></a><p>New Features new since 5.2.5:

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Improved memory management and process management.</li><li class="listitem">Support for SLURM</li></ul></div><p>
    </p><p>Other Standard Supported Features</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Remote job execution and management</li><li class="listitem">Uniform and flexible interface to local resource managers, including Condor, LSF, and GridEngine</li><li class="listitem">File staging before and after job execution</li><li class="listitem">File and directory clean up after job termination</li><li class="listitem">Service auditing for each submitted</li></ul></div><p>Removed Features</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">None.</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-platforms"></a>2. Tested platforms</h2></div></div></div><a class="indexterm" name="idm136345148528"></a><p>GRAM5 has been tested extensively on the following platforms:

    </p><div class="table"><a name="tested-platforms"></a><p class="title"><b>Table 1.1. Tested Platforms</b></p><div class="table-contents"><table summary="Tested Platforms" border="1" width="700px"><colgroup><col align="center" class="Operating System"><col align="left" class="Distribution"><col align="left" class="Versions"><col align="left" class="Architectures"></colgroup><thead><tr><th align="center">Operating System</th><th align="left">Distribution</th><th align="left">Version(s)</th><th align="left">Architecture(s)</th></tr></thead><tbody><tr><td class="auto-generated"> </td><td align="left">CentOS</td><td align="left">5</td><td align="left">i386, x86_64</td></tr><tr><td class="auto-generated"> </td><td align="left">Fedora</td><td align="left">18, 19</td><td align="left">i386, x86_64</td></tr><tr><td class="auto-generated"> </td><td align="left">Red Hat Enterprise Linux</td><td align="left">5, 6</td><td align="left">i386, x86_64</td></tr><tr><td class="auto-generated"> </td><td align="left">Scientific Linux</td><td align="left">5, 6</td><td align="left">i386, x86_64</td></tr><tr><td class="auto-generated"> </td><td align="left">Debian</td><td align="left">6, 7</td><td align="left">i386, amd64</td></tr><tr><td class="auto-generated"> </td><td align="left">Ubuntu</td><td align="left">10.04LTS, 12.04LTS, 12.10, 13.04, 13.10</td><td align="left">i386, amd64</td></tr><tr><td colspan="2" align="center">Mac OS X</td><td align="left">10.8 (Mountain Lion)</td><td align="left">x86_64</td></tr><tr><td colspan="2" align="center">Solaris</td><td align="left">11</td><td align="left">x86_64</td></tr></tbody></table></div></div><p><br class="table-break">
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-compatibility"></a>3. Backward compatibility summary</h2></div></div></div><a class="indexterm" name="idm136349395040"></a><p>Protocol changes in GRAM since GT4 series:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">The GRAM5 service uses a superset of the GRAM2 protocol for 
  communciation between the client and service. The extensions supported
  in GRAM5 are implemented in such a way that they are ignored by GRAM2
  services or clients. These extensions provide improved error messages and
  version detection.
  </li><li class="listitem">GRAM5 does not support task coallocation using DUROC and its related
  protocols. Jobs submitted using DUROC directives will fail.
  </li><li class="listitem">GRAM5 does not support file streaming. The standard output and
  standard error streams are sent after the job completes instead of during
  execution. As a special case, support for the Condor grid monitor program
  implements a small subset of the streaming capabilities of GRAM2 in GT 4.2.x.
  </li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-dependencies"></a>4. Technology dependencies</h2></div></div></div><a class="indexterm" name="idm136351377200"></a><p>GRAM depends on the following GT components:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Globus Common</li><li class="listitem">GSI C</li><li class="listitem">GridFTP server</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-security-considerations"></a>5. Security Considerations</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136351468928"></a>5.1. Gatekeeper Security Considerations</h3></div></div></div><p>
GRAM5 runs different parts of itself under different privilege
levels. The <span class="command"><strong>globus-gatekeeper</strong></span> runs as root, and uses its root privilege to access
the host's private key. It uses the <a href="#grid-map-file" class="glossterm"><em class="glossterm">grid map file</em></a> to
map <a href="#cert" class="glossterm"><em class="glossterm">Grid Certificates</em></a> to
local user ids and then uses the <code class="function">setuid()</code> function
to change to that user and execute the <span class="command"><strong>globus-job-manager</strong></span> program
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136345139424"></a>5.2. Job Manager Security Considerations</h3></div></div></div><p>
The  <span class="command"><strong>globus-job-manager</strong></span> program runs as a local non-root account. It receives
a delegated limited <a href="#proxy-cert" class="glossterm"><em class="glossterm">proxy certificate</em></a> from the GRAM5
client which it uses to access Grid storage resources via GridFTP and to
authenticate job signals (such as client cancel requests), and send
job state callbacks to registered clients. This proxy is generally short-lived,
and is automatically removed by the job manager when the job completes.
</p><p>
The <span class="command"><strong>globus-job-manager</strong></span> program uses a publicly-writable directory for job state
files. This directory has the <span class="emphasis"><em>sticky</em></span> bit set, so 
users may not remove other users files. Each file is named by a UUID, so
it should be unique.
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136350461584"></a>5.3. Fork SEG Module Security Considerations</h3></div></div></div><p>
The Fork Scheduler Event Generator module uses a globally writable file
for job state change events. This is not recommended for production use.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-developer-concepts"></a>Chapter 2. GRAM5 Concepts for Developers</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#gram5-developer-concepts-blocking">1. Blocking and Nonblocking Function Variants</a></span></dt><dt><span class="section"><a href="#idm136351983152">2. Service Contact Strings</a></span></dt><dd><dl><dt><span class="section"><a href="#gram5-developer-resource-names">2.1. Resource Names</a></span></dt></dl></dd><dt><span class="section"><a href="#gram5-developer-jobstatecallbacks">3. Job State Callbacks and Polling</a></span></dt><dt><span class="section"><a href="#idm136351930016">4. Credential Management</a></span></dt><dt><span class="section"><a href="#idm136351927088">5. RSL</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-developer-concepts-blocking"></a>1. Blocking and Nonblocking Function Variants</h2></div></div></div><p>
            In the GRAM Client API, all functions that involve sending
            messages over the network have both blocking and nonblocking
            variants. These are useful in different programming situations.
        </p><p>
            The blocking variants, such as the
            <code class="function">globus_gram_client_job_request</code> function
            require less application code, but will prevent subsequent
            instructions from executing until the request has been sent
            and the reply parsed. In a non-threaded environment, other
            callback functions registered with the Globus event driver may
            be invoked while the blocking function is running. In a threaded
            environment, other events may occur in other threads while the
            function is blocking, but the current thread will be blocked until
            the response is parsed.
        </p><p>
            The nonblocking variants, such as
            <code class="function">globus_gram_client_register_job_request</code> 
            require the application to include a callback function which will
            be called by the Globus event driver when the reply has been
            parsed. In a non-threaded environment, applications must poll
            the event driver using functions from the
            <code class="function">globus_poll</code> or 
            <code class="function">globus_cond_wait</code> families of
            functions. In a threaded environment, the callback function
            may be invoked in another thread than the one calling the
            non-blocking function, even before the non-blocking function has
            returned. Application writers must be careful in using
            synchronization primitives such as <span class="type">globus_mutex_t</span>
            and <span class="type">globus_cond_t</span> when using non-blocking functions.
        </p><p>
            An application writer should use the non-blocking variants if 
            the application will be submitting many jobs concurrently or
            requires custom network or security attributes. Using the 
            non-blocking variants allows the Globus event driver to better
            schedule network I/O in these cases.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="idm136351983152"></a>2. Service Contact Strings</h2></div></div></div><p>
        GRAM uses three types of <span class="emphasis"><em>contact strings</em></span> to
        describe how to contact different services. These service contacts
        are:

        </p><div class="table"><a name="idm136351981872"></a><p class="title"><b>Table 2.1. GRAM Contact String Types</b></p><div class="table-contents"><table summary="GRAM Contact String Types" border="1" width="700px"><colgroup><col><col></colgroup><thead><tr><th><p>Type</p></th><th><p>Meaning</p></th></tr></thead><tbody><tr><td><p>Gatekeeper Service Contact</p></td><td><p>This string describes how to contact a
                        gatekeeper service. It is used to submit jobs, send
                        "ping" requests to determine if a service is properly
                        deployed, and version requests to determine what
                        version of the software is deployed. Full details of
                        the syntax of this contact is located in the next
                        section.</p></td></tr><tr><td><p>Callback Contact</p></td><td><p>This string is an HTTPS URL that 
                        is an endpoint for GRAM job state callbacks. An https
                        message is posted to this address when the Job Manager
                        detects a job state change.</p></td></tr><tr><td><p>Job Contact</p></td><td><p>This string is an HTTPS URL that
                        is an endpoint for contacting an existing GRAM job.
                        An https message is posted to this address to cancel,
                        signal, or query a GRAM job.</p></td></tr></tbody></table></div></div><p><br class="table-break">
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gram5-developer-resource-names"></a>2.1. Resource Names</h3></div></div></div><p>
            In GRAM5, a Gatekeeper Service Contact
            contains the host, port, service name, and service identity 
            required to contact a particular GRAM service. For convenience,
            default values are used when parts of the contact are omitted.
            An example of a full gatekeeper service contact is
            <code class="literal">grid.example.org:2119/jobmanager:/C=US/O=Example/OU=Grid/CN=host/grid.example.org</code>.
            </p><p>
            The various forms of the resource name using default values follow:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><em class="replaceable"><code>HOST</code></em></li><li class="listitem"><em class="replaceable"><code>HOST</code></em><code class="literal">:</code><em class="replaceable"><code>PORT</code></em></li><li class="listitem"><em class="replaceable"><code>HOST</code></em><code class="literal">:</code><em class="replaceable"><code>PORT</code></em><code class="literal">/</code><em class="replaceable"><code>SERVICE</code></em></li><li class="listitem"><em class="replaceable"><code>HOST</code></em><code class="literal">/</code><em class="replaceable"><code>SERVICE</code></em></li><li class="listitem"><em class="replaceable"><code>HOST</code></em><code class="literal">:/</code><em class="replaceable"><code>SERVICE</code></em></li><li class="listitem"><em class="replaceable"><code>HOST</code></em><code class="literal">:</code><em class="replaceable"><code>PORT</code></em><code class="literal">:</code><em class="replaceable"><code>SUBJECT</code></em></li><li class="listitem"><em class="replaceable"><code>HOST</code></em><code class="literal">/</code><em class="replaceable"><code>SERVICE</code></em><code class="literal">:</code><em class="replaceable"><code>SUBJECT</code></em></li><li class="listitem"><em class="replaceable"><code>HOST</code></em><code class="literal">:/</code><em class="replaceable"><code>SERVICE</code></em><code class="literal">:</code><em class="replaceable"><code>SUBJECT</code></em></li><li class="listitem"><em class="replaceable"><code>HOST</code></em><code class="literal">:</code><em class="replaceable"><code>PORT</code></em><code class="literal">/</code><em class="replaceable"><code>SERVICE</code></em><code class="literal">:</code><em class="replaceable"><code>SUBJECT</code></em></li></ul></div><p>

            Where the various values have the following meaning:

            </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>HOST</code></em></span></dt><dd>Network name of the machine hosting the service.</dd><dt><span class="term"><em class="replaceable"><code>PORT</code></em></span></dt><dd>Network port number that the service is listening on. If not specified, the default of <code class="literal">2119</code> is used.</dd><dt><span class="term"><em class="replaceable"><code>SERVICE</code></em></span></dt><dd>Path of the service entry in <code class="filename"><code class="envar">$GLOBUS_LOCATION</code>/etc/grid-services</code>. If not specified, the default of <code class="literal">jobmanager</code> is used.</dd><dt><span class="term"><em class="replaceable"><code>SUBJECT</code></em></span></dt><dd>X.509 identity of the credential used by the service. If not specified, the default of <code class="literal">host@</code><em class="replaceable"><code>HOST</code></em> is used.</dd></dl></div><p>
            </p><div class="example"><a name="idm136351946704"></a><p class="title"><b>Example 2.1. Gatekeeper Service Contact Examples</b></p><div class="example-contents"><p>
                The following strings all name the service 
                <code class="literal">grid.example.org:2119/jobmanager:/C=US/O=Example/OU=Grid/CN=host/grid.example.org</code>
                using the formats with the various defaults described above.

                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">grid.example.org</code></li><li class="listitem"><code class="literal">grid.example.org:2119</code></li><li class="listitem"><code class="literal">grid.example.org:2119/jobmanager</code></li><li class="listitem"><code class="literal">grid.example.org/jobmanager</code></li><li class="listitem"><code class="literal">grid.example.org:/jobmanager</code></li><li class="listitem"><code class="literal">grid.example.org:2119:/C=US/O=Example/OU=Grid/CN=host/grid.example.org</code></li><li class="listitem"><code class="literal">grid.example.org/jobmanager:/C=US/O=Example/OU=Grid/CN=host/grid.example.org</code></li><li class="listitem"><code class="literal">grid.example.org:/jobmanager:/C=US/O=Example/OU=Grid/CN=host/grid.example.org</code></li><li class="listitem"><code class="literal">grid.example.org:2119/jobmanager:/C=US/O=Example/OU=Grid/CN=host/grid.example.org</code></li></ul></div><p>
                </p></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-developer-jobstatecallbacks"></a>3. Job State Callbacks and Polling</h2></div></div></div><p>
        GRAM clients and learn about a job's state in two ways: by registering
        for job state callbacks and by polling for status. These two methods
        have different performance characteristics and costs.
        </p><p>
        In order to receive job state callbacks, a client application must
        create an HTTPS listener using the
        <code class="function">globus_gram_client_callback_allow</code> or
        <code class="function">globus_gram_client_info_callback_allow</code> functions.
        A non-threaded application must then periodically call a function from
        either the <code class="function">globus_cond_wait</code> or
        <code class="function">globus_poll</code> families in order to process the
        job state callbacks. Additionally, the network must be configured to
        allow the GRAM job manager to send messages to the port that the client
        is listening on. This may be difficult if there is a firewall between
        the client and service.
        </p><p>The GRAM service initiates the job state callbacks, and thus
        they are usually sent very shortly after the job state changes, so
        clients can be notified about the state changes quickly.
        </p><p>
        In order to poll for job states, a client can call either the blocking
        or nonblocking variant of the
        <code class="function">globus_gram_client_job_status</code> or
        <code class="function">globus_gram_client_job_status_with_info</code> functions.
        These functions require that the network be configured to allow
        the client to contact the network port that the GRAM service is
        listening on (the Job Contact).
        </p><p>
        The client intiates these polling operations, so they are only
        as accurate as the polling frequence of the client. If the client polls
        very often, it will receive job state changes more quickly, at the 
        risk of increasing the computing and network cost of both the client
        and service.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="idm136351930016"></a>4. Credential Management</h2></div></div></div><p>
        The GRAM5 protocols all use GSSAPIv2 abstractions to provide
        authentication and authorization. By default, GRAM uses an SSL-based
        GSSAPI for its security.
        </p><p>
        The client delegates a credential to the gatekeeper service after
        authentication, and the GRAM job manager service uses this delegated
        credential as both a job-specific credential and for subsequent
        communication with GRAM clients.
        </p><p>
        If a client or clients submit multiple jobs to a gatekeeper service,
        they will eventually all be handled by a single job manager process.
        This process will use whichever delegated credential will remain
        valid the longest for accepting new connections and connecting to 
        clients to send job state callbacks.
        When a client delegates a new credential to a job, this credential may
        also be used as the job manager's credential for future connections.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="idm136351927088"></a>5. RSL</h2></div></div></div><p>
        GRAM5 jobs are described using the RSL language. The GRAM client API
        submits jobs using the string representation of the RSL, rather than
        the RSL parse tree. Clients can, if they need to modify of construct
        RSL at runtime, use the functions in the RSL API to do so.
        </p></div></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="idm136351925360"></a>GRAM Client Developer's Guide</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="chapter"><a href="#gram5-developer-scenarios">3. Basic GRAM Client Scenarios</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136351922640">1. "Ping" a Job Manager</a></span></dt><dt><span class="section"><a href="#idm136351919936">2. Check a Job Manager Version</a></span></dt><dt><span class="section"><a href="#idm136351917328">3. Submitting a Job</a></span></dt><dt><span class="section"><a href="#idm136351914896">4. Submitting a Job and Processing Job State Callbacks</a></span></dt><dt><span class="section"><a href="#idm136351912288">5. Polling Job Status</a></span></dt><dt><span class="section"><a href="#idm136351909680">6. Canceling a Job</a></span></dt><dt><span class="section"><a href="#idm136351907248">7. Refreshing Job Credential</a></span></dt></dl></dd><dt><span class="chapter"><a href="#gram5-developer-scenarios-advanced">4. Advanced GRAM Client Scenarios</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136351903760">1. Non-blocking Job Submission</a></span></dt><dt><span class="section"><a href="#idm136351900480">2. Custom Security Attributes</a></span></dt><dt><span class="section"><a href="#idm136351897920">3. Modifying RSL</a></span></dt></dl></dd></dl></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-developer-scenarios"></a>Chapter 3. Basic GRAM Client Scenarios</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#idm136351922640">1. "Ping" a Job Manager</a></span></dt><dt><span class="section"><a href="#idm136351919936">2. Check a Job Manager Version</a></span></dt><dt><span class="section"><a href="#idm136351917328">3. Submitting a Job</a></span></dt><dt><span class="section"><a href="#idm136351914896">4. Submitting a Job and Processing Job State Callbacks</a></span></dt><dt><span class="section"><a href="#idm136351912288">5. Polling Job Status</a></span></dt><dt><span class="section"><a href="#idm136351909680">6. Canceling a Job</a></span></dt><dt><span class="section"><a href="#idm136351907248">7. Refreshing Job Credential</a></span></dt></dl></div><p>
            This chapter contains a series of examples demonstrating how to
            use different features of the GRAM APIs to interact with
            the GRAM service. These examples can be compiled by using GNU
            make with the makefile from
            <a class="ulink" href="Makefile.examples" target="_top">Makefile.examples</a>.
        </p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="idm136351922640"></a>1. "Ping" a Job Manager</h2></div></div></div><p>
            This example shows how to use a gatekeeper "ping" request to
            determine if a service is running and if the client is authorized
            to contact it. It takes a gatekeeper service contact as its only
            command-line option. The <a class="ulink" href="gram_ping_example.c" target="_top">source to
            this example</a> can be downloaded.
        </p><pre class="programlisting">/*
 * These headers contain declarations for the globus_module functions
 * and GRAM Client API functions
 */
#include "globus_common.h"
#include "globus_gram_client.h"

#include &lt;stdio.h&gt;

int
main(int argc, char *argv[])
{
    int rc;

    if (argc != 2)
    {
        fprintf(stderr, "Usage: %s RESOURCE-MANAGER-CONTACT\n", argv[0]);
        rc = 1;

        goto out;
    }

    printf("Pinging GRAM resource: %s\n", argv[1]);

    /*
     * Always activate the GLOBUS_GRAM_CLIENT_MODULE prior to using any
     * functions from the GRAM Client API or behavior is undefined.
     */
    rc = globus_module_activate(GLOBUS_GRAM_CLIENT_MODULE);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error activating %s because %s (Error %d)\n",
                GLOBUS_GRAM_CLIENT_MODULE-&gt;module_name,
                globus_gram_client_error_string(rc),
                rc);
        goto out;
    }
    /*
     * Ping the service passed as our first command-line option. If successful,
     * this function will return GLOBUS_SUCCESS, otherwise an integer
     * error code.
     */
    rc = globus_gram_client_ping(argv[1]);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Unable to ping service at %s because %s (Error %d)\n",
                argv[1], globus_gram_client_error_string(rc), rc);
    }
    else
    {
        printf("Ping successful\n");
    }
    /*
     * Deactivating the module allows it to free memory and close network
     * connections.
     */
    rc = globus_module_deactivate(GLOBUS_GRAM_CLIENT_MODULE);
out:
    return rc;
}
/* End of gram_ping_example.c */
</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="idm136351919936"></a>2. Check a Job Manager Version</h2></div></div></div><p>
            This example shows how to use the "version" command to determine
            what software version a gatekeeper service is running.
            The <a class="ulink" href="gram_version_example.c" target="_top">source to
            this example</a> can be downloaded.
        </p><pre class="programlisting">/*
 * These headers contain declarations for the globus_module functions
 * and GRAM Client API functions
 */
#include "globus_common.h"
#include "globus_gram_client.h"
#include "globus_gram_protocol.h"

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int
main(int argc, char *argv[])
{
    int rc;
    globus_hashtable_t extensions = NULL;
    globus_gram_protocol_extension_t * extension_value;

    if (argc != 2)
    {
        fprintf(stderr, "Usage: %s RESOURCE-MANAGER-CONTACT\n", argv[0]);
        rc = 1;

        goto out;
    }

    printf("Checking version of GRAM resource: %s\n", argv[1]);

    /*
     * Always activate the GLOBUS_GRAM_CLIENT_MODULE prior to using any
     * functions from the GRAM Client API or behavior is undefined.
     */
    rc = globus_module_activate(GLOBUS_GRAM_CLIENT_MODULE);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error activating %s because %s (Error %d)\n",
                GLOBUS_GRAM_CLIENT_MODULE-&gt;module_name,
                globus_gram_client_error_string(rc),
                rc);
        goto out;
    }
    /*
     * Contact the service passed as our first command-line option and perform
     * a version check. If successful,
     * this function will return GLOBUS_SUCCESS, otherwise an integer
     * error code. Old versions of the job manager will return 
     * GLOBUS_GRAM_PROTOCOL_ERROR_HTTP_UNPACK_FAILED as they do not support
     * the version operation.
     */
    rc = globus_gram_client_get_jobmanager_version(argv[1], &amp;extensions);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Unable to get service version from %s because %s "
                "(Error %d)\n",
                argv[1], globus_gram_client_error_string(rc), rc);
    }
    else
    {
        /* The version information is returned in the extensions hash table */
        extension_value = globus_hashtable_lookup(
                &amp;extensions,
                "toolkit-version");

        if (extension_value == NULL)
        {
            printf("Unknown toolkit version\n");
        }
        else
        {
            printf("Toolkit Version: %s\n", extension_value-&gt;value);
        }

        extension_value = globus_hashtable_lookup(
                &amp;extensions,
                "version");
        if (extension_value == NULL)
        {
            printf("Unknown package version\n");
        }
        else
        {
            printf("Package Version: %s\n", extension_value-&gt;value);
        }
        /* Free the extensions hash and its values */
        globus_gram_protocol_hash_destroy(&amp;extensions);
    }

    /*
     * Deactivating the module allows it to free memory and close network
     * connections.
     */
    rc = globus_module_deactivate(GLOBUS_GRAM_CLIENT_MODULE);
out:
    return rc;
}
/* End of gram_version_example.c */
</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="idm136351917328"></a>3. Submitting a Job</h2></div></div></div><p>
            This example shows how to submit a job to a GRAM service.
            The <a class="ulink" href="gram_submit_example.c" target="_top">source to
            this example</a> can be downloaded.
        </p><pre class="programlisting">/*
 * These headers contain declarations for the globus_module functions
 * and GRAM Client API functions
 */
#include "globus_common.h"
#include "globus_gram_client.h"

#include &lt;stdio.h&gt;

int
main(int argc, char *argv[])
{
    int rc;
    char * job_contact = NULL;

    if (argc != 3)
    {
        fprintf(stderr, "Usage: %s RESOURCE-MANAGER-CONTACT RSL\n", argv[0]);
        rc = 1;

        goto out;
    }

    printf("Submitting job to GRAM resource: %s\n", argv[1]);

    /*
     * Always activate the GLOBUS_GRAM_CLIENT_MODULE prior to using any
     * functions from the GRAM Client API or behavior is undefined.
     */
    rc = globus_module_activate(GLOBUS_GRAM_CLIENT_MODULE);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error activating %s because %s (Error %d)\n",
                GLOBUS_GRAM_CLIENT_MODULE-&gt;module_name,
                globus_gram_client_error_string(rc),
                rc);
        goto out;
    }
    /*
     * Submit the job request to the service passed as our first command-line
     * option. If successful, this function will return GLOBUS_SUCCESS,
     * otherwise an integer error code.
     */
    rc = globus_gram_client_job_request(
            argv[1], argv[2], 0, NULL, &amp;job_contact);

    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Unable to submit job to %s because %s (Error %d)\n",
                argv[1], globus_gram_client_error_string(rc), rc);
        if (job_contact != NULL)
        {
            printf("Job Contact: %s\n", job_contact);
        }
    }
    else
    {
        /* Display job contact string */
        printf("Job submit successful: %s\n", job_contact);
    }

    if (job_contact != NULL)
    {
        free(job_contact);
    }
    /*
     * Deactivating the module allows it to free memory and close network
     * connections.
     */
    rc = globus_module_deactivate(GLOBUS_GRAM_CLIENT_MODULE);
out:
    return rc;
}
/* End of gram_submit_example.c */
</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="idm136351914896"></a>4. Submitting a Job and Processing Job State Callbacks</h2></div></div></div><p>
            This example shows how to submit a job to a GRAM service and
            then wait until the job reaches the FAILED or DONE state.
            The <a class="ulink" href="gram_submit_and_wait_example.c" target="_top">source to
            this example</a> can be downloaded.
        </p><pre class="programlisting">/*
 * These headers contain declarations for the globus_module functions
 * and GRAM Client API functions
 */
#include "globus_common.h"
#include "globus_gram_client.h"

#include &lt;stdio.h&gt;

struct monitor_t
{
    globus_mutex_t mutex;
    globus_cond_t cond;
    globus_gram_protocol_job_state_t state;
};

/*
 * Job State Callback Function
 *
 * This function is called when the job manager sends job states.
 */
static
void
example_callback(void * callback_arg, char * job_contact, int state,
        int errorcode)
{
    struct monitor_t * monitor = callback_arg;

    globus_mutex_lock(&amp;monitor-&gt;mutex);

    printf("Old Job State: %d\nNew Job State: %d\n", monitor-&gt;state, state);

    monitor-&gt;state = state;

    if (state == GLOBUS_GRAM_PROTOCOL_JOB_STATE_FAILED ||
        state == GLOBUS_GRAM_PROTOCOL_JOB_STATE_DONE)
    {
        globus_cond_signal(&amp;monitor-&gt;cond);
    }
    globus_mutex_unlock(&amp;monitor-&gt;mutex);
}

int
main(int argc, char *argv[])
{
    int rc;
    char * callback_contact = NULL;
    char * job_contact = NULL;
    struct monitor_t monitor;

    if (argc != 3)
    {
        fprintf(stderr, "Usage: %s RESOURCE-MANAGER-CONTACT RSL\n", argv[0]);
        rc = 1;

        goto out;
    }

    /*
     * Always activate the GLOBUS_GRAM_CLIENT_MODULE prior to using any
     * functions from the GRAM Client API or behavior is undefined.
     */
    rc = globus_module_activate(GLOBUS_GRAM_CLIENT_MODULE);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error activating %s because %s (Error %d)\n",
                GLOBUS_GRAM_CLIENT_MODULE-&gt;module_name,
                globus_gram_client_error_string(rc),
                rc);
        goto out;
    }

    rc = globus_mutex_init(&amp;monitor.mutex, NULL);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error initializing mutex\n");
        goto deactivate;
    }
    rc = globus_cond_init(&amp;monitor.cond, NULL);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error initializing condition variable\n");
        goto destroy_mutex;
    }

    monitor.state = GLOBUS_GRAM_PROTOCOL_JOB_STATE_UNSUBMITTED;

    globus_mutex_lock(&amp;monitor.mutex);

    /*
     * Allow GRAM state change callbacks 
     */
    rc = globus_gram_client_callback_allow(
            example_callback, &amp;monitor, &amp;callback_contact);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error allowing callbacks because %s (Error %d)\n",
                globus_gram_client_error_string(rc), rc);
        goto destroy_cond;
    }
    /*
     * Submit the job request to the service passed as our first command-line
     * option. 
     */
    rc = globus_gram_client_job_request(
            argv[1], argv[2],
            GLOBUS_GRAM_PROTOCOL_JOB_STATE_FAILED|
            GLOBUS_GRAM_PROTOCOL_JOB_STATE_DONE,
            callback_contact, &amp;job_contact);

    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Unable to submit job to %s because %s (Error %d)\n",
                argv[1], globus_gram_client_error_string(rc), rc);
        /* Job submit failed. Short circuit the while loop below by setting
         * the job state to failed
         */
        monitor.state = GLOBUS_GRAM_PROTOCOL_JOB_STATE_FAILED;
    }
    else
    {
        /* Display job contact string */
        printf("Job submit successful: %s\n", job_contact);
    }

    /* Wait for job state callback to let us know the job has completed */
    while (monitor.state != GLOBUS_GRAM_PROTOCOL_JOB_STATE_DONE &amp;&amp;
           monitor.state != GLOBUS_GRAM_PROTOCOL_JOB_STATE_FAILED)
    {
        globus_cond_wait(&amp;monitor.cond, &amp;monitor.mutex);
    }
    rc = globus_gram_client_callback_disallow(callback_contact);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error disabling callbacks because %s (Error %d)\n",
                globus_gram_client_error_string(rc), rc);
    }
    globus_mutex_unlock(&amp;monitor.mutex);

    if (job_contact != NULL)
    {
        free(job_contact);
    }

destroy_cond:
    globus_cond_destroy(&amp;monitor.cond);
destroy_mutex:
    globus_mutex_destroy(&amp;monitor.mutex);
deactivate:
    /*
     * Deactivating the module allows it to free memory and close network
     * connections.
     */
    rc = globus_module_deactivate(GLOBUS_GRAM_CLIENT_MODULE);
out:
    return rc;
}
/* End of gram_submit_and_wait_example.c */
</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="idm136351912288"></a>5. Polling Job Status</h2></div></div></div><p>
            This example shows how to submit a job to a GRAM service and
            then wait until the job reaches the FAILED or DONE state.
            The <a class="ulink" href="gram_poll_example.c" target="_top">source to
            this example</a> can be downloaded.
        </p><pre class="programlisting">/*
 * These headers contain declarations for the globus_module functions
 * and GRAM Client API functions
 */
#include "globus_common.h"
#include "globus_gram_client.h"

#include &lt;stdio.h&gt;

int
main(int argc, char *argv[])
{
    int rc;
    int status = 0;
    int failure_code = 0;

    if (argc != 2)
    {
        fprintf(stderr, "Usage: %s JOB-CONTACT\n", argv[0]);
        rc = 1;

        goto out;
    }

    /*
     * Always activate the GLOBUS_GRAM_CLIENT_MODULE prior to using any
     * functions from the GRAM Client API or behavior is undefined.
     */
    rc = globus_module_activate(GLOBUS_GRAM_CLIENT_MODULE);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error activating %s because %s (Error %d)\n",
                GLOBUS_GRAM_CLIENT_MODULE-&gt;module_name,
                globus_gram_client_error_string(rc),
                rc);
        goto out;
    }
    /*
     * Check the job status of the job named by the first argument to
     * this program.
     */
    rc = globus_gram_client_job_status(argv[1], &amp;status, &amp;failure_code);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Unable to check job status because %s (Error %d)\n",
                globus_gram_client_error_string(rc), rc);
    }
    else
    {
        switch (status)
        {
            case GLOBUS_GRAM_PROTOCOL_JOB_STATE_UNSUBMITTED:
                printf("Unsubmitted\n");
                break;
            case GLOBUS_GRAM_PROTOCOL_JOB_STATE_STAGE_IN:
                printf("StageIn\n");
                break;
            case GLOBUS_GRAM_PROTOCOL_JOB_STATE_PENDING:
                printf("Pending\n");
                break;
            case GLOBUS_GRAM_PROTOCOL_JOB_STATE_ACTIVE:
                printf("Active\n");
                break;
            case GLOBUS_GRAM_PROTOCOL_JOB_STATE_SUSPENDED:
                printf("Suspended\n");
                break;
            case GLOBUS_GRAM_PROTOCOL_JOB_STATE_STAGE_OUT:
                printf("StageOut\n");
                break;
            case GLOBUS_GRAM_PROTOCOL_JOB_STATE_DONE:
                printf("Done\n");
                break;
            case GLOBUS_GRAM_PROTOCOL_JOB_STATE_FAILED:
                printf("Failed (%d)\n", failure_code);
                break;
            default:
                printf("Unknown job state\n");
                break;
        }
    }
    /*
     * Deactivating the module allows it to free memory and close network
     * connections.
     */
    rc = globus_module_deactivate(GLOBUS_GRAM_CLIENT_MODULE);
out:
    return rc;
}
/* End of gram_poll_example.c */
</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="idm136351909680"></a>6. Canceling a Job</h2></div></div></div><p>
            This example shows how to cancel a job being run by a GRAM service.
            The <a class="ulink" href="gram_cancel_example.c" target="_top">source to this
            example</a> can be downloaded.
        </p><pre class="programlisting">/*
 * These headers contain declarations for the globus_module functions
 * and GRAM Client API functions
 */
#include "globus_common.h"
#include "globus_gram_client.h"

#include &lt;stdio.h&gt;

int
main(int argc, char *argv[])
{
    int rc;

    if (argc != 2)
    {
        fprintf(stderr, "Usage: %s JOB-CONTACT\n", argv[0]);
        rc = 1;

        goto out;
    }

    /*
     * Always activate the GLOBUS_GRAM_CLIENT_MODULE prior to using any
     * functions from the GRAM Client API or behavior is undefined.
     */
    rc = globus_module_activate(GLOBUS_GRAM_CLIENT_MODULE);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error activating %s because %s (Error %d)\n",
                GLOBUS_GRAM_CLIENT_MODULE-&gt;module_name,
                globus_gram_client_error_string(rc),
                rc);
        goto out;
    }
    /*
     * Cancel the job named by the first argument to
     * this program.
     */
    rc = globus_gram_client_job_cancel(argv[1]);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Unable to cancel job because %s (Error %d)\n",
                globus_gram_client_error_string(rc), rc);
    }
    /*
     * Deactivating the module allows it to free memory and close network
     * connections.
     */
    rc = globus_module_deactivate(GLOBUS_GRAM_CLIENT_MODULE);
out:
    return rc;
}
/* End of gram_cancel_example.c */
</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="idm136351907248"></a>7. Refreshing Job Credential</h2></div></div></div><p>
            This example shows how to refresh a GRAM job's credential after
            the job has been submitted by some other means.
            The <a class="ulink" href="gram_refresh_example.c" target="_top">source to
            this example</a> can be downloaded.
        </p><pre class="programlisting">/*
 * These headers contain declarations for the globus_module functions
 * and GRAM Client API functions
 */
#include "globus_common.h"
#include "globus_gram_client.h"

#include &lt;stdio.h&gt;

int
main(int argc, char *argv[])
{
    int rc;

    if (argc != 2)
    {
        fprintf(stderr, "Usage: %s JOB-CONTACT\n", argv[0]);
        rc = 1;

        goto out;
    }

    printf("Refreshing Credential for GRAM Job: %s\n", argv[1]);

    /*
     * Always activate the GLOBUS_GRAM_CLIENT_MODULE prior to using any
     * functions from the GRAM Client API or behavior is undefined.
     */
    rc = globus_module_activate(GLOBUS_GRAM_CLIENT_MODULE);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error activating %s because %s (Error %d)\n",
                GLOBUS_GRAM_CLIENT_MODULE-&gt;module_name,
                globus_gram_client_error_string(rc),
                rc);
        goto out;
    }
    /*
     * Refresh the credential of the job running at the contact named
     * by the first command-line argument to this program. We'll use the
     * process's default credential by passing in GSS_C_NO_CREDENTIAL.
     */
    rc = globus_gram_client_job_refresh_credentials(
            argv[1], GSS_C_NO_CREDENTIAL);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Unable to refresh credential for job %s because %s (Error %d)\n",
                argv[1], globus_gram_client_error_string(rc), rc);
    }
    else
    {
        printf("Refresh successful\n");
    }
    /*
     * Deactivating the module allows it to free memory and close network
     * connections.
     */
    rc = globus_module_deactivate(GLOBUS_GRAM_CLIENT_MODULE);
out:
    return rc;
}
/* End of gram_refresh_example.c */
</pre></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-developer-scenarios-advanced"></a>Chapter 4. Advanced GRAM Client Scenarios</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#idm136351903760">1. Non-blocking Job Submission</a></span></dt><dt><span class="section"><a href="#idm136351900480">2. Custom Security Attributes</a></span></dt><dt><span class="section"><a href="#idm136351897920">3. Modifying RSL</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="idm136351903760"></a>1. Non-blocking Job Submission</h2></div></div></div><p>
            This example shows how to submit a series of GRAM jobs using the
            non-blocking function
            <code class="function">globus_gram_client_register_job_request</code> and
            wait until all submissions have completed. This example throttles
            the number of concurrent job submissions to reduce the load
            on the service node. The
            <a class="ulink" href="gram_nonblocking_submit_example.c" target="_top">source to
            this example</a> can be downloaded.

            </p><pre class="programlisting">/*
 * These headers contain declarations for the globus_module functions
 * and GRAM Client API functions
 */
#include "globus_common.h"
#include "globus_gram_client.h"

#include &lt;stdio.h&gt;

struct monitor_t
{
    globus_mutex_t mutex;
    globus_cond_t cond;
    int submit_pending;
    int successful_submits;
};

#define CONCURRENT_SUBMITS 5

static
void
example_submit_callback(
    void * user_callback_arg,
    globus_gram_protocol_error_t operation_failure_code,
    const char * job_contact,
    globus_gram_protocol_job_state_t job_state,
    globus_gram_protocol_error_t job_failure_code)
{
    struct monitor_t * monitor = user_callback_arg;

    globus_mutex_lock(&amp;monitor-&gt;mutex);
    monitor-&gt;submit_pending--;
    if (monitor-&gt;submit_pending &lt; CONCURRENT_SUBMITS)
    {
        globus_cond_signal(&amp;monitor-&gt;cond);
    }
    printf("Submitted job %s\n",
            job_contact ? job_contact : "UNKNOWN");
    if (operation_failure_code == GLOBUS_SUCCESS)
    {
        monitor-&gt;successful_submits++;
    }
    else
    {
        printf("submit failed because %s (Error %d)\n",
                globus_gram_client_error_string(operation_failure_code),
                operation_failure_code);
    }
    globus_mutex_unlock(&amp;monitor-&gt;mutex);
}

int
main(int argc, char *argv[])
{
    int rc;
    int i;
    struct monitor_t monitor;

    if (argc &lt; 3)
    {
        fprintf(stderr, "Usage: %s RESOURCE-MANAGER-CONTACT RSL-SPEC...\n",
                argv[0]);
        rc = 1;

        goto out;
    }

    printf("Submiting %d jobs to %s\n", argc-2, argv[1]);

    /*
     * Always activate the GLOBUS_GRAM_CLIENT_MODULE prior to using any
     * functions from the GRAM Client API or behavior is undefined.
     */
    rc = globus_module_activate(GLOBUS_GRAM_CLIENT_MODULE);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error activating %s because %s (Error %d)\n",
                GLOBUS_GRAM_CLIENT_MODULE-&gt;module_name,
                globus_gram_client_error_string(rc),
                rc);
        goto out;
    }

    rc = globus_mutex_init(&amp;monitor.mutex, NULL);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error initializing mutex %d\n", rc);

        goto deactivate;
    }

    rc = globus_cond_init(&amp;monitor.cond, NULL);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error initializing condition variable %d\n", rc);

        goto destroy_mutex;
    }
    monitor.submit_pending = 0;

    /* Submits jobs from argv[2] until end of the argv array. At most
     * CONCURRENT_SUBMITS will be pending at any given time.
     */
    globus_mutex_lock(&amp;monitor.mutex);
    for (i = 2; i &lt; argc; i++)
    {
        /* This throttles the number of concurrent job submissions */
        while (monitor.submit_pending &gt;= CONCURRENT_SUBMITS)
        {
            globus_cond_wait(&amp;monitor.cond, &amp;monitor.mutex);
        }

        /* When the job has been submitted, the example_submit_callback
         * will be called, either from another thread or from a 
         * globus_cond_wait in a nonthreaded build
         */
        rc = globus_gram_client_register_job_request(
                argv[1], argv[i], 0, NULL, NULL, example_submit_callback,
                &amp;monitor);
        if (rc != GLOBUS_SUCCESS)
        {
            fprintf(stderr, "Unable to submit job %s because %s (Error %d)\n",
                    argv[i], globus_gram_client_error_string(rc), rc);
        }
        else
        {
            monitor.submit_pending++;
        }
    }

    /* Wait until the example_submit_callback function has been called for
     * each job submission
     */
    while (monitor.submit_pending &gt; 0)
    {
        globus_cond_wait(&amp;monitor.cond, &amp;monitor.mutex);
    }
    globus_mutex_unlock(&amp;monitor.mutex);

    printf("Submitted %d jobs (%d successfully)\n",
            argc-2, monitor.successful_submits);

    globus_cond_destroy(&amp;monitor.cond);
destroy_mutex:
    globus_mutex_destroy(&amp;monitor.mutex);
deactivate:
    /*
     * Deactivating the module allows it to free memory and close network
     * connections.
     */
    rc = globus_module_deactivate(GLOBUS_GRAM_CLIENT_MODULE);
out:
    return rc;
}
/* End of gram_nonblocking_submit_example.c */
</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="idm136351900480"></a>2. Custom Security Attributes</h2></div></div></div><p>
            This example shows how to submit a job and delegate a full
            credential to the job.  The
            <a class="ulink" href="gram_attr_example.c" target="_top">source to
            this example</a> can be downloaded.

            </p><pre class="programlisting">/*
 * These headers contain declarations for the globus_module functions
 * and GRAM Client API functions
 */
#include "globus_common.h"
#include "globus_gram_client.h"

#include &lt;stdio.h&gt;

struct monitor_t
{
    globus_mutex_t mutex;
    globus_cond_t cond;
    globus_bool_t done;
};

static
void
example_submit_callback(
    void * user_callback_arg,
    globus_gram_protocol_error_t operation_failure_code,
    const char * job_contact,
    globus_gram_protocol_job_state_t job_state,
    globus_gram_protocol_error_t job_failure_code)
{
    struct monitor_t * monitor = user_callback_arg;

    globus_mutex_lock(&amp;monitor-&gt;mutex);
    monitor-&gt;done = GLOBUS_TRUE;
    globus_cond_signal(&amp;monitor-&gt;cond);
    if (operation_failure_code == GLOBUS_SUCCESS)
    {
        printf("Submitted job %s\n",
            job_contact ? job_contact : "UNKNOWN");
    }
    else
    {
        printf("submit failed because %s (Error %d)\n",
                globus_gram_client_error_string(operation_failure_code),
                operation_failure_code);
    }
    globus_mutex_unlock(&amp;monitor-&gt;mutex);
}

int
main(int argc, char *argv[])
{
    int rc;
    globus_gram_client_attr_t attr;
    struct monitor_t monitor;

    if (argc &lt; 3)
    {
        fprintf(stderr, "Usage: %s RESOURCE-MANAGER-CONTACT RSL-SPEC...\n",
                argv[0]);
        rc = 1;

        goto out;
    }

    printf("Submiting job to %s with full proxy\n", argv[1]);

    /*
     * Always activate the GLOBUS_GRAM_CLIENT_MODULE prior to using any
     * functions from the GRAM Client API or behavior is undefined.
     */
    rc = globus_module_activate(GLOBUS_GRAM_CLIENT_MODULE);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error activating %s because %s (Error %d)\n",
                GLOBUS_GRAM_CLIENT_MODULE-&gt;module_name,
                globus_gram_client_error_string(rc),
                rc);
        goto out;
    }

    rc = globus_mutex_init(&amp;monitor.mutex, NULL);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error initializing mutex %d\n", rc);

        goto deactivate;
    }

    rc = globus_cond_init(&amp;monitor.cond, NULL);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error initializing condition variable %d\n", rc);

        goto destroy_mutex;
    }
    monitor.done = GLOBUS_FALSE;

    /* Initialize attribute so that we can set the delegation attribute */
    rc = globus_gram_client_attr_init(&amp;attr);

    /* Set the proxy attribute */
    rc = globus_gram_client_attr_set_delegation_mode(
        attr,
        GLOBUS_IO_SECURE_DELEGATION_MODE_FULL_PROXY);

    /* Submit the job rsl from argv[2]
     */
    globus_mutex_lock(&amp;monitor.mutex);
    /* When the job has been submitted, the example_submit_callback
     * will be called, either from another thread or from a 
     * globus_cond_wait in a nonthreaded build
     */
    rc = globus_gram_client_register_job_request(
            argv[1], argv[2], 0, NULL, attr, example_submit_callback,
            &amp;monitor);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Unable to submit job %s because %s (Error %d)\n",
                argv[2], globus_gram_client_error_string(rc), rc);
    }

    /* Wait until the example_submit_callback function has been called for
     * the job submission
     */
    while (!monitor.done)
    {
        globus_cond_wait(&amp;monitor.cond, &amp;monitor.mutex);
    }
    globus_mutex_unlock(&amp;monitor.mutex);

    globus_cond_destroy(&amp;monitor.cond);
destroy_mutex:
    globus_mutex_destroy(&amp;monitor.mutex);
deactivate:
    /*
     * Deactivating the module allows it to free memory and close network
     * connections.
     */
    rc = globus_module_deactivate(GLOBUS_GRAM_CLIENT_MODULE);
out:
    return rc;
}
/* End of gram_attr_example.c */
</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="idm136351897920"></a>3. Modifying RSL</h2></div></div></div><p>
            This example shows how to programmatically add environment variable
            definitions to an RSL prior to submitting a job.  The
            <a class="ulink" href="gram_rsl_example.c" target="_top">source to
            this example</a> can be downloaded.

            </p><pre class="programlisting">/*
 * These headers contain declarations for the globus_module,
 * the GRAM Client, RSL, and protocol functions
 */
#include "globus_common.h"
#include "globus_gram_client.h"
#include "globus_rsl.h"
#include "globus_gram_protocol.h"

#include &lt;stdio.h&gt;
#include &lt;strings.h&gt;

static
int
example_rsl_attribute_match(void * datum, void * arg)
{
    const char * relation_attribute = globus_rsl_relation_get_attribute(datum);
    const char * attribute = arg;

    /* RSL attributes are case-insensitive */
    return (relation_attribute &amp;&amp;
            strcasecmp(relation_attribute, attribute) == 0);
}

int
main(int argc, char *argv[])
{
    int rc;
    globus_rsl_t *rsl, *environment_relation;
    globus_rsl_value_t *new_env_pair = NULL;
    globus_list_t *environment_relation_node;
    char * rsl_string;
    char * job_contact;

    if (argc != 3)
    {
        fprintf(stderr, "Usage: %s RESOURCE-MANAGER-CONTACT RSL\n", argv[0]);
        rc = 1;

        goto out;
    }

    /*
     * Always activate the GLOBUS_GRAM_CLIENT_MODULE prior to using any
     * functions from the GRAM Client API or behavior is undefined.
     */
    rc = globus_module_activate(GLOBUS_GRAM_CLIENT_MODULE);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error activating %s because %s (Error %d)\n",
                GLOBUS_GRAM_CLIENT_MODULE-&gt;module_name,
                globus_gram_client_error_string(rc),
                rc);
        goto out;
    }

    /* Parse the RSL string into a syntax tree */
    rsl = globus_rsl_parse(argv[2]);
    if (rsl == NULL)
    {
        rc = 1;
        fprintf(stderr, "Error parsing RSL string\n");
        goto deactivate;
    }

    /* Create the new environment variable pair that we'll insert
     * into the RSL. We'll start by making an empty sequence
     */
    new_env_pair = globus_rsl_value_make_sequence(NULL);
    if (new_env_pair == NULL)
    {
        fprintf(stderr, "Error creating value sequence\n");
        rc = 1;

        goto free_rsl;
    }
    /* Then insert the name-value pair in reverse order */
    rc = globus_list_insert(
            globus_rsl_value_sequence_get_list_ref(new_env_pair),
            globus_rsl_value_make_literal(
                strdup("itsvalue")));
    if (rc != GLOBUS_SUCCESS)
    {
        goto free_env_pair;
    }

    rc = globus_list_insert(
            globus_rsl_value_sequence_get_list_ref(new_env_pair),
            globus_rsl_value_make_literal(
                strdup("EXAMPLE_ENVIRONMENT_VARIABLE")));
    if (rc != GLOBUS_SUCCESS)
    {
        goto free_env_pair;
    }
    /* Now, check to see if the RSL already contains an environment 
     * attribute.
     */
    environment_relation_node = globus_list_search_pred(
            globus_rsl_boolean_get_operand_list(rsl),
            example_rsl_attribute_match,
            GLOBUS_GRAM_PROTOCOL_ENVIRONMENT_PARAM);

    if (environment_relation_node == NULL)
    {
        /* Not present yet, create a new relation and insert it into
         * the RSL.
         */
        environment_relation = globus_rsl_make_relation(
                GLOBUS_RSL_EQ,
                strdup(GLOBUS_GRAM_PROTOCOL_ENVIRONMENT_PARAM),
                globus_rsl_value_make_sequence(NULL));
        rc = globus_list_insert(
                globus_rsl_boolean_get_operand_list_ref(rsl),
                environment_relation);
        if (rc != GLOBUS_SUCCESS)
        {
            globus_rsl_free_recursive(environment_relation);
            goto free_env_pair;
        }
    }
    else
    {
        /* Pull the environment relation out of the node returned from the
         * search function
         */
        environment_relation = globus_list_first(environment_relation_node);
    }

    /* Add the new environment binding to the value sequence associated with
     * the environment relation
     */
    rc = globus_list_insert(
        globus_rsl_value_sequence_get_list_ref(
                globus_rsl_relation_get_value_sequence(environment_relation)),
        new_env_pair);
    if (rc != GLOBUS_SUCCESS)
    {
        goto free_env_pair;
    }
    new_env_pair = NULL;

    /* Convert the RSL parse tree to a string */
    rsl_string = globus_rsl_unparse(rsl);

    /*
     * Submit the augmented RSL to the service passed as our first command-line
     * option. If successful, this function will return GLOBUS_SUCCESS,
     * otherwise an integer error code.
     */
    rc = globus_gram_client_job_request(
            argv[1],
            rsl_string,
            0,
            NULL,
            &amp;job_contact);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Unable to submit job to %s because %s (Error %d)\n",
                argv[1], globus_gram_client_error_string(rc), rc);
    }
    else
    {
        printf("Job submitted successfully: %s\n", job_contact);
    }

    free(rsl_string);

    if (job_contact)
    {
        free(job_contact);
    }
free_env_pair:
    if (new_env_pair != NULL)
    {
        globus_rsl_value_free_recursive(new_env_pair);
    }
free_rsl:
    globus_rsl_free_recursive(rsl);
deactivate:
    /*
     * Deactivating the module allows it to free memory and close network
     * connections.
     */
    rc = globus_module_deactivate(GLOBUS_GRAM_CLIENT_MODULE);
out:
    return rc;
}
/* End of gram_rsl_example.c */
</pre><p>
        </p></div></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="idm136351895072"></a>GRAM Server Developer's Guide</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="chapter"><a href="#gram5-developer-lrm-adapter-tutorial">5. LRM Adapter Tutorial</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136336836896">1. Introduction</a></span></dt><dt><span class="section"><a href="#idm136335987504">2. Parts of a GRAM5 LRM Adapter</a></span></dt><dt><span class="section"><a href="#gram5-lrma-tutorial-rvf">3. RSL Validation File</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136335997456">3.1. RVF Attributes</a></span></dt><dd><dl><dt><span class="section"><a href="#gram5-lrma-tutorial-rvf-when-values">3.1.1. RVF When Values</a></span></dt><dt><span class="section"><a href="#idm136336022256">3.1.2. Common RSL Attributes</a></span></dt></dl></dd><dt><span class="section"><a href="#idm136336025888">3.2. Creating a RSL Validation File for the Fake LRM</a></span></dt></dl></dd><dt><span class="section"><a href="#idm136336052464">4. Configuration File</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136336046912">4.1. Parsing the Configuration File</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136336063648">4.1.1. Perl API</a></span></dt><dt><span class="section"><a href="#idm136336059504">4.1.2. C/C++ API</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#gram5-lrma-tutorial-perl">5. LRM Adapter Perl Module</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136336071008">5.1. Perl LRM Adapter Module</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136336104352">5.1.1. Writing a Constructor</a></span></dt><dt><span class="section"><a href="#idm136336094272">5.1.2. Submitting Jobs</a></span></dt><dt><span class="section"><a href="#idm136336087248">5.1.3. Polling Job State</a></span></dt><dt><span class="section"><a href="#idm136336083088">5.1.4. Cancelling Jobs</a></span></dt><dt><span class="section"><a href="#idm136336118928">5.1.5. End of the script</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#gram5-developer-lrm-adapter-tutorial-seg">6. LRM SEG Module</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136336113984">6.1. Intro</a></span></dt><dt><span class="section"><a href="#idm136336131936">6.2. Outline</a></span></dt><dt><span class="section"><a href="#gram5-lrm-seg-depdendencies">6.3. LRM Module Dependencies</a></span></dt><dt><span class="section"><a href="#gram5-lrm-seg-module-specific-data">6.4. Module Specific Data</a></span></dt><dt><span class="section"><a href="#gram5-lrm-seg-module-prototypes">6.5. Module Specific Prototypes</a></span></dt><dt><span class="section"><a href="#gram5-lrm-seg-module-descriptor">6.6. Extension Module Descriptor</a></span></dt><dt><span class="section"><a href="#gram5-lrm-seg-module-activation">6.7. Module Activation</a></span></dt><dd><dl><dt><span class="section"><a href="#gram5-lrm-module-activate-read-configuration">6.7.1. LRM SEG Module Configuration</a></span></dt><dt><span class="section"><a href="#gram5-lrm-module-activate-register-event">6.7.2. Register Event</a></span></dt><dt><span class="section"><a href="#gram5-lrm-module-activate-cleanup-on-failure">6.7.3. Cleanup on Failure</a></span></dt></dl></dd><dt><span class="section"><a href="#gram5-lrm-seg-module-deactivation">6.8. Module Deactivation</a></span></dt><dt><span class="section"><a href="#gram5-lrm-seg-module-process">6.9. Process Events</a></span></dt><dt><span class="section"><a href="#gram5-lrm-seg-module-utils">6.10. Utility Functions</a></span></dt></dl></dd><dt><span class="section"><a href="#gram5-lrma-tutorial-perl-changes">7. Changes from Previous Versions</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136336255856">7.1. Changes in GT 5.2</a></span></dt><dt><span class="section"><a href="#idm136336254112">7.2. Changes in GT 5.0</a></span></dt><dt><span class="section"><a href="#idm136336252096">7.3. Changes in GT 4.0</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136336251392">7.3.1. Module Methods</a></span></dt><dt><span class="section"><a href="#idm136336267088">7.3.2. GASS Cache</a></span></dt></dl></dd><dt><span class="section"><a href="#idm136336284640">7.4. Changes in GT 3.2</a></span></dt></dl></dd></dl></dd></dl></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-developer-lrm-adapter-tutorial"></a>Chapter 5. LRM Adapter Tutorial</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#idm136336836896">1. Introduction</a></span></dt><dt><span class="section"><a href="#idm136335987504">2. Parts of a GRAM5 LRM Adapter</a></span></dt><dt><span class="section"><a href="#gram5-lrma-tutorial-rvf">3. RSL Validation File</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136335997456">3.1. RVF Attributes</a></span></dt><dd><dl><dt><span class="section"><a href="#gram5-lrma-tutorial-rvf-when-values">3.1.1. RVF When Values</a></span></dt><dt><span class="section"><a href="#idm136336022256">3.1.2. Common RSL Attributes</a></span></dt></dl></dd><dt><span class="section"><a href="#idm136336025888">3.2. Creating a RSL Validation File for the Fake LRM</a></span></dt></dl></dd><dt><span class="section"><a href="#idm136336052464">4. Configuration File</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136336046912">4.1. Parsing the Configuration File</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136336063648">4.1.1. Perl API</a></span></dt><dt><span class="section"><a href="#idm136336059504">4.1.2. C/C++ API</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#gram5-lrma-tutorial-perl">5. LRM Adapter Perl Module</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136336071008">5.1. Perl LRM Adapter Module</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136336104352">5.1.1. Writing a Constructor</a></span></dt><dt><span class="section"><a href="#idm136336094272">5.1.2. Submitting Jobs</a></span></dt><dt><span class="section"><a href="#idm136336087248">5.1.3. Polling Job State</a></span></dt><dt><span class="section"><a href="#idm136336083088">5.1.4. Cancelling Jobs</a></span></dt><dt><span class="section"><a href="#idm136336118928">5.1.5. End of the script</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#gram5-developer-lrm-adapter-tutorial-seg">6. LRM SEG Module</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136336113984">6.1. Intro</a></span></dt><dt><span class="section"><a href="#idm136336131936">6.2. Outline</a></span></dt><dt><span class="section"><a href="#gram5-lrm-seg-depdendencies">6.3. LRM Module Dependencies</a></span></dt><dt><span class="section"><a href="#gram5-lrm-seg-module-specific-data">6.4. Module Specific Data</a></span></dt><dt><span class="section"><a href="#gram5-lrm-seg-module-prototypes">6.5. Module Specific Prototypes</a></span></dt><dt><span class="section"><a href="#gram5-lrm-seg-module-descriptor">6.6. Extension Module Descriptor</a></span></dt><dt><span class="section"><a href="#gram5-lrm-seg-module-activation">6.7. Module Activation</a></span></dt><dd><dl><dt><span class="section"><a href="#gram5-lrm-module-activate-read-configuration">6.7.1. LRM SEG Module Configuration</a></span></dt><dt><span class="section"><a href="#gram5-lrm-module-activate-register-event">6.7.2. Register Event</a></span></dt><dt><span class="section"><a href="#gram5-lrm-module-activate-cleanup-on-failure">6.7.3. Cleanup on Failure</a></span></dt></dl></dd><dt><span class="section"><a href="#gram5-lrm-seg-module-deactivation">6.8. Module Deactivation</a></span></dt><dt><span class="section"><a href="#gram5-lrm-seg-module-process">6.9. Process Events</a></span></dt><dt><span class="section"><a href="#gram5-lrm-seg-module-utils">6.10. Utility Functions</a></span></dt></dl></dd><dt><span class="section"><a href="#gram5-lrma-tutorial-perl-changes">7. Changes from Previous Versions</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136336255856">7.1. Changes in GT 5.2</a></span></dt><dt><span class="section"><a href="#idm136336254112">7.2. Changes in GT 5.0</a></span></dt><dt><span class="section"><a href="#idm136336252096">7.3. Changes in GT 4.0</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136336251392">7.3.1. Module Methods</a></span></dt><dt><span class="section"><a href="#idm136336267088">7.3.2. GASS Cache</a></span></dt></dl></dd><dt><span class="section"><a href="#idm136336284640">7.4. Changes in GT 3.2</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="idm136336836896"></a>1. Introduction</h2></div></div></div><p> 
        GRAM5 provides a resource-independent abstraction to remote job
        management.  The resource abstraction contains methods for
        job submission and cancelling, and a method for monitoring
        job state changes.  This set of tutorials describes how to implement
        and bundle all packages needed for a complete
        <a href="#local-resource-manager-adapter" class="glossterm"><em class="glossterm">LRM Adapter</em></a> interface for
        GRAM5.
    </p><p>
    For purposes of this tutorial, we will create a fake LRM adapter that
    pretends to run jobs, but in fact just keeps track of jobs and expires
    them after the job's <code class="literal">max_wall_time</code> expires. We'll
    call this LRM the <code class="literal">fake</code> LRM adapter.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="idm136335987504"></a>2. Parts of a GRAM5 LRM Adapter</h2></div></div></div><p>
    A GRAM5 LRM Adapter consists of a few parts which work together
    to provide a full interface between the GRAM5
    <a href="#job-manager" class="glossterm"><em class="glossterm">Job Manager</em></a> and the
    <a href="#local-resource-manager" class="glossterm"><em class="glossterm">Local Resource Manager</em></a>.
    These parts include:

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">RSL Validation File</span></dt><dd>An option file which defines any custom RSL
        attributes which the LRM Adapter implements, or sets any custom 
        defaults for RSL attributes that the LRM processes. Defining new RSL
        attributes in this file allows the GRAM5 service to detect some sets
        of RSL errors without invoking the Perl LRM Adapter
        Module. For this example, the file will be called <code class="filename">fake.rvf</code>.</dd><dt><span class="term">Perl LRM Adapter Module</span></dt><dd>A Perl module which implements the execution
        interface to the LRM. This module translates the 
        <a href="#rsl" class="glossterm"><em class="glossterm">Resource Specification Language</em></a> description
        of a job's requirements to a concrete way of starting the job
        on a particular LRM. For this example, this file will be called
        <code class="filename">fake.pm</code>.</dd><dt><span class="term">Configuration File</span></dt><dd>The GRAM5 service implements a simple configuration
        file parser which can be used to provide a way to add site
        customizations to LRM Adapters. These files are usually shared between
        the Perl LRM Adapter Module and the Scheduler Event Generator
        Module. For this example, this file will be called
        <code class="filename">fake.conf</code>.</dd><dt><span class="term"><a href="#gatekeeper" class="glossterm"><em class="glossterm">Gatekeeper</em></a> Service File</span></dt><dd>The Gatekeeper is a privileged service which
        authenticates and authorizes clients and then starts a 
        <a href="#job-manager" class="glossterm"><em class="glossterm">Job Manager</em></a> process on their behalf. The
        Gatekeeper Service File contains the LRM-specific command-line options 
        to the job manager. For this example, this file will be called
        <code class="filename">jobmanager-fork</code>.</dd><dt><span class="term"><a href="#seg" class="glossterm"><em class="glossterm">Scheduler Event Generator</em></a> Module</span></dt><dd>A dynamic object which parses LRM state and
        generates job state change events in a generic format for GRAM5
        to consume. For this example, the SEG module will be called
        <code class="filename">libglobus_seg_fake.so</code>.</dd></dl></div><p>
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-lrma-tutorial-rvf"></a>3. RSL Validation File</h2></div></div></div><p>
    Each LRM Adapter can have a custom RSL validation file (RVF) which
    indicates which RSL attributes are valid for that LRM, what their default
    values are, and when they can be used during a job lifecycle.
    </p><p>
    The RVF entries consist of a set of records containing attribute-value
    pairs, with a blank line separating records. Each attribute-value pair
    is separated by the colon character. The value may be quoted with the
    double-quote character, in which case, the value continues until a
    second quote character is found; otherwise, the value terminates at
    end of line.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136335997456"></a>3.1. RVF Attributes</h3></div></div></div><p>
    The attribute names understood by the GRAM5 RVF parser are:
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Attribute</span></dt><dd>The name of an RSL
            attribute.</dd><dt><span class="term">Description</span></dt><dd>A textual description of the
            attribute.</dd><dt><span class="term">RequiredWhen</span></dt><dd>A sequence of <a href="#gram5-lrma-tutorial-rvf-when-values" class="olink">WHEN-VALUES</a>
            describing when this RSL attribute must be
            present.</dd><dt><span class="term">DefaultWhen</span></dt><dd>A sequence of <a href="#gram5-lrma-tutorial-rvf-when-values" class="olink">WHEN-VALUES</a>
            describing when the default RSL value will be applied if it's not
            present in the RSL.</dd><dt><span class="term">ValidWhen</span></dt><dd>A sequence of <a href="#gram5-lrma-tutorial-rvf-when-values" class="olink">WHEN-VALUES</a>
            describing when the RSL attribute may be
            present.</dd><dt><span class="term">Default</span></dt><dd>A literal RSL value sequence containing the
            default value of the attribute, applied to the RSL when the
            attribute is not present, but the RSL use matches the
            <code class="literal">DefaultWhen</code> value.</dd><dt><span class="term">Values</span></dt><dd>A sequence of strings enumerating the legal
            values for the RSL attribute.</dd><dt><span class="term">Publish</span></dt><dd>When set to <code class="literal">true</code>, the
            RSL attribute will be added to the documentation for the LRM
            Adapter if the RVF is processed by the
            <span class="command"><strong>create_rsl_documentation.pl</strong></span> script. Otherwise,
            it will not be mentioned.</dd></dl></div><p>
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gram5-lrma-tutorial-rvf-when-values"></a>3.1.1. RVF When Values</h4></div></div></div><p>The <em class="replaceable"><code>WHEN-VALUES</code></em> used by the RVF parser are
    described in this list:

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">GLOBUS_GRAM_JOB_SUBMIT</code></span></dt><dd>RSL Attribute used in a GRAM5 job request
            to submit a job to an LRM Adapter.</dd><dt><span class="term"><code class="literal">GLOBUS_GRAM_JOB_RESTART</code></span></dt><dd>RSL Attribute used in a GRAM5 job request
            to restart a job which was stopped due to a two-phase commit
            timeout.</dd><dt><span class="term"><code class="literal">GLOBUS_GRAM_JOB_STDIO_UPDATE</code></span></dt><dd>RSL Attribute used in a GRAM5 STDIO_UPDATE 
            signal, which may be sent to a job during the two-phase end
            state.</dd></dl></div><p>
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136336022256"></a>3.1.2. Common RSL Attributes</h4></div></div></div><p>
    The GRAM5 service by default implements a common set of RSL attributes for
    all jobs.  Not all of these may be relevant to all LRM types, but are
    included in the common set so that the same concept will be processed by
    the same attribute for each LRM. LRM Adapters can disable particular RSL
    attributes if they want by adding the attribute to their RVF file with
    </p><pre class="programlisting">Attribute: <em class="replaceable"><code>AttributeName</code></em>
ValidWhen: ""</pre><p>
    The common list of attributes is described in <a href="../pi/#gram5-rsl-attribute-summary" class="olink">Section 4, &#8220;RSL Attribute Summary&#8221;</a>.
    </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136336025888"></a>3.2. Creating a RSL Validation File for the Fake LRM</h3></div></div></div><p>
    Normally, the RVF for a new LRM Adapter will add any LRM-specific
    RSL attributes and perhaps change the DefaultValue for some. For the 
    <code class="literal">fake</code> LRM, we'll be a bit more complicated and
    disable most of the GRAM common RSL attributes and reduce
    things to indicate the queue and execution time for the fake jobs.
    The <code class="filename">fake.rvf</code> will do the following:

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Remove <code class="literal">executable</code>,
        <code class="literal">arguments</code>, <code class="literal">directory</code>,
        <code class="literal">environment</code>, <code class="literal">file_clean_up</code>,
        <code class="literal">file_stage_in</code>, <code class="literal">file_stage_out</code>,
        <code class="literal">file_stage_in_shared</code>, <code class="literal">gass_cache</code>,
        <code class="literal">gram_my_job</code>, <code class="literal">host_count</code>,
        <code class="literal">library_path</code>, <code class="literal">max_cpu_time</code>,
        <code class="literal">min_memory</code>, <code class="literal">project</code>,
        <code class="literal">queue</code>, <code class="literal">remote_io_url</code>,
        <code class="literal">scratch_dir</code>, <code class="literal">stdin</code>,
        <code class="literal">stdout</code>, and <code class="literal">stderr</code> attributes.</li><li class="listitem">Add a <code class="literal">max_queue_time</code> attribute,
        which will be the maximum time a particular fake job will be in the
        <code class="literal">PENDING</code> state. This will have a default of 20
        minutes.</li><li class="listitem">Add a default value to the
        <code class="literal">max_wall_time</code> attribute of 5
        minutes.</li></ul></div><p>
    </p><p>
    </p><div class="example"><a name="idm136336056992"></a><p class="title"><b>Example 5.1. fake.rvf</b></p><div class="example-contents"><p>Here is the <a class="ulink" href="fake.rvf" target="_top">complete RVF</a> for the
        <code class="literal">fake</code> LRM Adapter:

        </p><pre class="programlisting"># Disable a large number of RSL attributes
Attribute: executable
ValidWhen: ""
RequiredWhen: ""

Attribute: directory
ValidWhen: ""
RequiredWhen: ""

Attribute: environment
ValidWhen: ""
RequiredWhen: ""

Attribute: file_clean_up
ValidWhen: ""
RequiredWhen: ""

Attribute: file_stage_in
ValidWhen: ""
RequiredWhen: ""

Attribute: file_stage_out
ValidWhen: ""
RequiredWhen: ""

Attribute: file_stage_in_shared
ValidWhen: ""
RequiredWhen: ""

Attribute: gass_cache
ValidWhen: ""
RequiredWhen: ""

Attribute: gram_my_job
ValidWhen: ""
RequiredWhen: ""

Attribute: host_count
ValidWhen: ""
RequiredWhen: ""

Attribute: library_path
ValidWhen: ""
RequiredWhen: ""

Attribute: max_cpu_time
ValidWhen: ""
RequiredWhen: ""

Attribute: min_memory
ValidWhen: ""
RequiredWhen: ""

Attribute: project
ValidWhen: ""
RequiredWhen: ""

Attribute: queue
ValidWhen: ""
RequiredWhen: ""

Attribute: remote_io_url
ValidWhen: ""
RequiredWhen: ""

Attribute: scratch_dir
ValidWhen: ""
RequiredWhen: ""

Attribute: stdin
ValidWhen: ""
RequiredWhen: ""

Attribute: stdout
ValidWhen: ""
RequiredWhen: ""

Attribute: stderr 
ValidWhen: ""
RequiredWhen: ""

# Add a new attribute max_queue_time
Attribute: max_queue_time
ValidWhen: GLOBUS_GRAM_JOB_SUBMIT
DefaultWhen: GLOBUS_GRAM_JOB_SUBMIT 
RequiredWhen: GLOBUS_GRAM_JOB_SUBMIT 
Description: "Maximum time a fake job will be in pending, in seconds. The
              default value is 1200 seconds (20 minutes)"
Default: 1200

# Add a default value and requirement for max_wall_time
Attribute: max_wall_time
DefaultWhen: GLOBUS_GRAM_JOB_SUBMIT 
RequiredWhen: GLOBUS_GRAM_JOB_SUBMIT 
Default: 300
Description: "Maximum time a fake job will be in the ACTIVE state"
</pre><p>
        </p></div></div><p><br class="example-break">
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="idm136336052464"></a>4. Configuration File</h2></div></div></div><p> 
    For the fake LRM, there's not much to configure: a path to a file
    where the LRM should write its job files. For real LRMs, there
    are other things which might belong there: paths to LRM-specific
    executables such as <span class="command"><strong>qsub</strong></span>, tuning parameters fo
    the LRM adapter script such as the number of available cores per
    execution node, or the host to contact when using a remote submit
    protocol between GRAM the the LRM. The configuation parameters used
    by the LRM adapters included in GRAM5 are described in 
    <a href="../admin/#gram5-configuring-lrm" class="olink">Section 4, &#8220;LRM Adapter Configuration&#8221;</a>.
</p><p>
    The LRM adapter configuration files consist of attribute="value" pairs,
    which comment lines beginning with the <code class="literal">#</code> character. 
    For the example fake LRM, the configuration file looks like this:
    </p><pre class="programlisting"># log_path is the path to log file that the  fake LRM generates. This file is
# updated each time a job is submitted or cancelled. The default if it is not
# present is ${localstatedir}/fake, which is typically /var/fake
log_path="/tmp"
</pre><p>
</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136336046912"></a>4.1. Parsing the Configuration File</h3></div></div></div><p>The Globus Toolkit contains API functions for parsing files in the
format used by the LRM configuration files. In Perl, use the
<code class="classname">Globus::Core::Config</code> class. In C/C++,
use the <code class="function">globus_common_get_attribute_from_config_file()</code>
function.
</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136336063648"></a>4.1.1. Perl API</h4></div></div></div><p>The <code class="classname">Globus::Core::Config</code> API is quite simple. The
<code class="function">new()</code> constructor parses the configuration file and
returns an object containing the attribute=value pairs. The
<code class="function">get_attribute()</code> method returns the value of the named
attribute. These functions are used in <a href="#gram5-LRM-Adapter-Perl-Config" class="olink">the fake LRM Perl Module</a>.
</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136336059504"></a>4.1.2. C/C++ API</h4></div></div></div><p>The <code class="function">globus_common_get_attribute_from_config_file()</code>
function will load the configuration file and return the value of the
attribute passed to it. This function is ued in the SEG module below. Note
that this function returns a pointer to a copy of the string value in the 
location pointed to by the <em class="parameter"><code>value</code></em> parameter. The caller
must free this value.
</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-lrma-tutorial-perl"></a>5. LRM Adapter Perl Module</h2></div></div></div><p>
    The Perl-language LRM module provides the job submission and
    cancelling interface between GRAM5 and the underlying
    scheduler. Very little has been added to this part of the scheduler
    interface since Globus Toolkit 2---if you have a version for an
    older Globus Toolkit release, you can ignore most of this tutorial and jump
    to the <a href="#gram5-lrma-tutorial-perl-changes" class="olink">Section 7, &#8220;Changes from Previous Versions&#8221;</a>  section of
    this tutorial. The module annotated below is available from <a class="ulink" href="fake.pm" target="_top">fake.pm</a>.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136336071008"></a>5.1. Perl LRM Adapter Module</h3></div></div></div><p>The LRM Adapter interface is implemented as a Perl module which is a
    subclass of the <code class="classname">Globus::GRAM::JobManager</code> module. Its
    name must match the type string used when the job manager is
    started, but in all lower case: for the fake LRM, the module name is
    <code class="classname">Globus::GRAM::JobManager::fake</code> and it is stored in
    the file <code class="filename">fake.pm</code>.  Though there are several methods in
    the <a href="#Globus::GRAM::JobManager" class="olink"><code class="classname">Globus::GRAM::JobManager
    interface</code></a>, the only ones which
    absolutely need to be implemented in a scheduler module are
    <code class="methodname">submit</code> and
    <code class="methodname">cancel</code>. The <code class="methodname">poll</code>
    can be used if there is no SEG module for your LRM Adapter, but
    using polling can be resource intensive and slow. We'll present
    the methods in the module one by one, but the entire module
    can be downloaded from here: <a class="ulink" href="fake.pm" target="_top">fake.pm</a>.</p><p>We'll begin by looking at the start of the
    <code class="filename">fake.pm</code> source module To begin the script, we import
    the GRAM support modules into the LRM adapter module's namespace, declare
    the module's package, and declare this module as a subclass of the
    <code class="classname">Globus::GRAM::JobManager</code>
    module.  All LRM adapter packages will need to do this, substituting the
    name of the LRM type being implemented where we see
    <code class="literal">fake</code>
    below.</p><pre class="programlisting">use Globus::GRAM::Error;
use Globus::GRAM::JobState;
use Globus::GRAM::JobManager;
use Globus::Core::Paths;
use Globus::Core::Config;
use File::Path;
use strict;
use warnings;

package Globus::GRAM::JobManager::fake;

our @ISA = ('Globus::GRAM::JobManager');
</pre><p>Next, we declare any system-specific values which will be read
    from the configuration file.  In the fake case, we will declare a 
    module-global directory for job information and for SEG log entries.
    In real LRM Adapters, there are often variables which
    are loaded from the configuration file for such things as
    the list of available queues, paths to executables such as
    <span class="command"><strong>mpiexec</strong></span>,
    and any other site-specific configuration.

    <a name="gram5-LRM-Adapter-Perl-Config"></a></p><pre class="programlisting">our($job_dir, $fake_seg_dir);

BEGIN
{
    my $config = new Globus::Core::Config(
        '${sysconfdir}/globus/globus-fake.conf');
    
    $job_dir = $fake_seg_dir = "";

    if ($config)
    {
        $job_dir = $config-&gt;get_attribute("log_path") || "";
    }
    if ($job_dir eq '')
    {
        $job_dir = Globus::Core::Paths::eval_path('${localstatedir}/fake');
    }
}
</pre><p>
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136336104352"></a>5.1.1. Writing a Constructor</h4></div></div></div><p>For LRM Adapter interfaces which need to setup some data before
    calling their other methods, they can overload the <code class="methodname">new</code> method
    which acts as a constructor. Scheduler scripts which don't need any
    per-instance initialization will not need to provide a constructor, the
    default <code class="methodname">Globus::GRAM::JobManager::new</code> constructor will do
    the job.</p><p>If you do need to overloaded this method, be sure to call the
    parent module's constructor to allow it to do its initialization. In
    this example, we create an object which includes a sequence number to
    ensure that the job ids returned from the LRM script is unique.

    </p><pre class="programlisting">sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class-&gt;SUPER::new(@_);
    $self-&gt;{sequence} = 0;

    return $self;
}
</pre><p>
    </p><p>The job interface methods are called with only one argument: the
    LRM Adapter object itself. That object contains a
    <code class="classname">Globus::GRAM::JobDescription</code> object
    (<code class="code">$self-&gt;{JobDescription}</code>) which includes the values from
    the RSL associated with the request, as well as a few extra
    values:

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">job_id</span></dt><dd>The string returned as the value of JOB_ID in the
        eturn hash from submit.  This won't be present for methods called
        before the job is submitted.</dd><dt><span class="term">uniq_id</span></dt><dd>A string associated with this job request by the job
        manager program. It will be unique for all jobs on a host for all time
        and might be useful in creating temporary files or LRM-specific
        processing.</dd></dl></div><p>
    </p><p>
    Now, let's look at the methods which will interface to the LRM.
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136336094272"></a>5.1.2. Submitting Jobs</h4></div></div></div><p>All LRM adapter modules must implement the
    <code class="methodname">submit</code> method. This method
    is called when the job manager wishes to submit the job to the LRM.
    The information in the original job request RSL string is available to
    the LRM adapter interface through the
    <em class="structfield"><code>JobDescription</code></em> data member of its hash.</p><p>For most LRM Adapters, this is the longest method to be implemented,
    as it must decide what to do with the job description, and convert RSL
    elements to something which the LRM can understand.</p><p>For our fake adapter, we will validate that the two RSL attributes
    we process are integers, and if so generate a new unique LRM
    ID and return it and the state
    <code class="code">Globus::GRAM::JobState::PENDING</code>. Note the call to
    <code class="methodname">respond</code> with 
    <code class="literal">GT3_FAILURE_MESSAGE</code>. This allows the GRAM5 client
    application to see the context-sensitive error message along with the
    general failure code from GRAM5.

    </p><pre class="programlisting">sub submit
{
    my $self = shift;
    my $description = $self-&gt;{JobDescription};
    my $now = time();
    my $jobid;
    my $fh;
    my $pending_time;
    my $active_time;
    my $done_time;
    my $failed_time = 0;

    if ($description-&gt;max_wall_time() != int($description-&gt;max_wall_time()))
    {
        return Globus::GRAM::Error::INVALID_MAX_WALL_TIME;
    }
    elsif ($description-&gt;max_queue_time() !=
        int($description-&gt;max_queue_time()))
    {
        $self-&gt;respond({GT3_FAILURE_MESSAGE =&gt; "Invalid max_queue_time"});

        return Globus::GRAM::Error::INVALID_ATTR;
    }
    $self-&gt;{sequence}++;
    $pending_time = $now;
    $active_time = $pending_time + int($description-&gt;max_queue_time);
    $done_time = $active_time + int($description-&gt;max_wall_time);

    $jobid = sprintf("%.63s", "$$".$self-&gt;{sequence}.".$now");

    if (!open($fh, "&gt;&gt;$job_dir/fakejob.log"))
    {
        $self-&gt;respond({GT3_FAILURE_MESSAGE =&gt; "Unable to write job file"});
        return Globus::GRAM::Error::INVALID_SCRIPT_STATUS;
    }
    print $fh "$jobid;$pending_time;$active_time;$done_time;$failed_time\n";
    close($fh);

    return { JOB_STATE =&gt; Globus::GRAM::JobState::PENDING,
             JOB_ID =&gt; $jobid };
}
</pre><p>
    </p><p>That finishes the submit method. Most of the functionality for the
    scheduler interface is now written. 
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136336087248"></a>5.1.3. Polling Job State</h4></div></div></div><p>
    GRAM5 requires some way to determine the state of a job. In most systems,
    writing a Scheduler Event Generator module will provide the best
    performance and lowest resource overhead. However, when developing an LRM
    adapter, it is helpful to implement the polling interface so that the
    submission and cancel mechanism can be tested independent of having the
    SEG module completed. For the <code class="literal">fake</code> LRM Adapter, we'll
    write a simple <code class="methodname">poll</code> method which will compare the
    current time with the time when the job was originally submitted. 

    </p><pre class="programlisting">sub poll
{
    my $self = shift;
    my $description = $self-&gt;{JobDescription};
    my $state;
    my $pid;
    my $now;
    my $fh;
    my $pending_time = 0;
    my $active_time;
    my $done_time;
    my $failed_time;
    my $seqno;

    my $jobid = $description-&gt;jobid();

    if(!defined $jobid)
    {
        $self-&gt;log("poll: job id undefined!");
        return { JOB_STATE =&gt; Globus::GRAM::JobState::FAILED };
    }

    open($fh, "&lt;$job_dir/fakejob.log");

    # Multiple matches might occur if the job is cancelled, so we keep looping
    # until EOF
    while (&lt;$fh&gt;)
    {
        chomp;

        my @fields = split(/;/);

        if ($fields[0] ne $jobid)
        {
            next;
        }
        
        $pending_time = $fields[1];
        $active_time = $fields[2];
        $done_time = $fields[3];
        $failed_time = $fields[4];
    }
    close($fh);

    $now = time();

    if ($pending_time == 0)
    {
        # not found
        $state = Globus::GRAM::JobState::FAILED;
    }
    elsif (int($failed_time) != 0)
    {
        $state = Globus::GRAM::JobState::FAILED;
    }
    elsif ($now &lt; int($active_time))
    {
        $state = Globus::GRAM::JobState::PENDING;
        return
    }
    elsif ($now &lt; int($done_time))
    {
        $state = Globus::GRAM::JobState::ACTIVE;
    }
    else
    {
        $state = Globus::GRAM::JobState::DONE;
    }

    return { JOB_STATE =&gt; $state };
}
</pre><p>
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136336083088"></a>5.1.4. Cancelling Jobs</h4></div></div></div><p>All LRM Adapter modules must also implement the
    <code class="methodname">cancel</code> method. The
    purpose of this method is to cancel a job, whether it's already
    running or waiting in a queue.</p><p>This method will be given the job ID as part of the JobDescription
    object in the manager object.  If the LRM interface provides
    feedback that the job was cancelled successfully, then we can return a
    JOB_STATE change to the FAILED state.  Otherwise we can return an empty
    hash reference, and let either the Scheduler Event Generator or a
    subsequent call to poll determine when the state change occurs.</p><p>For the <code class="literal">fake</code> LRM adapter, we will update the
    job file with a cancellation time and return the
    <code class="literal">Globus::GRAM::JobState::FAILED</code> state change.

    </p><pre class="programlisting">sub cancel
{
    my $self = shift;
    my $description = $self-&gt;{JobDescription};
    my $pgid;
    my $jobid = $description-&gt;jobid();
    my $fh;
    my $pending_time = 0;
    my $active_time;
    my $done_time;
    my $failed_time ;
    my $now = time();

    if(!defined $jobid)
    {
        $self-&gt;log("cancel: no jobid defined!");
        return { JOB_STATE =&gt; Globus::GRAM::JobState::FAILED };
    }

    open($fh, "&lt;$job_dir/fakejob.log");

    # Multiple matches might occur if the job is cancelled, so we keep looping
    # until EOF
    while (&lt;$fh&gt;)
    {
        chomp;

        my @fields = split(/;/);

        if ($fields[0] ne $jobid)
        {
            next;
        }
        
        $pending_time = $fields[1];
        $active_time = $fields[2];
        $done_time = $fields[3];
        $failed_time = $fields[4];
    }
    close($fh);

    $self-&gt;log("cancel job " . $jobid);
    if ($now &lt; int($done_time) &amp;&amp; int($failed_time) == 0)
    {
        $failed_time = $now;
        $done_time = 0;
        if (!open($fh, "&gt;&gt;$job_dir/fakejob.log"))
        {
            $self-&gt;respond({GT3_FAILURE_MESSAGE =&gt; "Unable to write job file"});
            return Globus::GRAM::Error::INVALID_SCRIPT_STATUS;
        }
        print $fh "$jobid;$pending_time;$active_time;$done_time;$failed_time\n";
        close($fh);
    }

    return { JOB_STATE =&gt; Globus::GRAM::JobState::FAILED };
}
</pre><p>
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136336118928"></a>5.1.5. End of the script</h4></div></div></div><p>It is required that all perl modules return a non-zero value when
    they are parsed. To do this, make sure the last line of your module
    consists of:

    </p><pre class="programlisting">1;
</pre><p>
    </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-developer-lrm-adapter-tutorial-seg"></a>6. LRM SEG Module</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136336113984"></a>6.1. Intro</h3></div></div></div><p> 
The Scheduler Event Generator (SEG) module provides an efficient job monitoring
interface between GRAM5 and the underlying local resource manager.  In most
cases, the SEG module parses a log generated by the local resource manager which
contains information about job state changes and then uses the <a class="ulink" href="http://www.globus.org/api/c-globus-6.0/globus_scheduler_event_generator/html/group__seg__api.html" target="_top">SEG
API</a> to signal job state changes as they occur.
</p><p>A SEG module is implemented as a shared library which is loaded as a
globus extension. This means that the only entry point to the library is a
globus_module_descriptor, which defines activation and deactivation functions
for the library. For this tutorial, we will build up the SEG module piecewise, but the
<a class="ulink" href="seg_fake_module.c" target="_top">entire fake SEG module source</a> can be
downloaded as well.
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136336131936"></a>6.2. Outline</h3></div></div></div><p>The outline for our SEG module is:
    <a name="fake_seg_module_structure"></a></p><pre class="programlisting"><a class="xref" href="#gram5-lrm-seg-module-headers" title="Include Headers">Include Headers</a>
<a class="xref" href="#gram5-lrm-seg-module-specific-data" title="6.4. Module Specific Data">Module Specific Data</a>
<a class="xref" href="#gram5-lrm-seg-module-prototypes" title="6.5. Module Specific Prototypes">Module Specific Prototypes</a>
<a class="xref" href="#gram5-lrm-seg-module-descriptor" title="6.6. Extension Module Descriptor">Extension Module Descriptor</a>
<a class="xref" href="#gram5-lrm-seg-module-activation" title="6.7. Module Activation">Module Activation</a>
<a class="xref" href="#gram5-lrm-seg-module-deactivation" title="6.8. Module Deactivation">Module Deactivation</a>
<a class="xref" href="#gram5-lrm-seg-module-process" title="6.9. Process Events">Process Events</a>
<a class="xref" href="#gram5-lrm-seg-module-utils" title="6.10. Utility Functions">Utility Functions</a></pre><p>
From this outline, we'll explain the various sections of the source file below.
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gram5-lrm-seg-depdendencies"></a>6.3. LRM Module Dependencies</h3></div></div></div><p>
The LRM module uses the globus_common API from Globus for its linked list,
mutual exclusion, timed events, and module dependency tracking. It also uses
the Scheduler Event Generator APIs, which provide functions for defining and
emitting LRM events.
</p><p><a name="gram5-lrm-seg-module-headers"></a><b>Include Headers. </b>
For our implementation, we'll need to include the headers for the Globus
modules we'll be using. In this case
we'll be using <code class="filename">globus_common.h</code>,
<code class="filename">globus_scheduler_event_generator.h</code> (which includes the API
for emitting SEG events), and <code class="filename">globus_scheduler_event_generator_app.h</code>
(which includes the SEG event type definitions).

</p><pre class="programlisting">#include "globus_common.h"
#include "globus_scheduler_event_generator.h"
#include "globus_scheduler_event_generator_app.h"</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gram5-lrm-seg-module-specific-data"></a>6.4. Module Specific Data</h3></div></div></div><p>For the fake LRM, we need to keep some global state to keep track of what we've
parsed from our LRM's log file, and what events are we should be sending in the future.
To do this, we define two data structures, a <span class="structname">fake_job_info_t</span>
which defines the set of event timestamps associated with a job, and
<span class="structname">fake_state_t</span> which contains the state of the fake SEG parser.

</p><pre class="programlisting"><a class="xref" href="#gram5-lrm-seg-fake-job-info" title="Fake Job Info">Fake Job Info</a>
<a class="xref" href="#gram5-lrm-seg-fake-state" title="LRM Parser State">LRM Parser State</a></pre><p>
</p><p><a name="gram5-lrm-seg-fake-job-info"></a><b>Fake Job Info. </b>
For the <span class="structname">fake_job_info_t</span> structure, we will want to keep
track of the LRM id (an up to 64-character long string), and the timestamps for
the pending, active, failed, and done events for the job. We use the timestamp
value of <code class="literal">0</code> to indicate an event which will not happen or has
already been processed.
</p><pre class="programlisting">typedef struct
{
    char   jobid[64];
    time_t pending;
    time_t active;
    time_t failed;
    time_t done;
}
fake_job_info_t;
</pre><p>

In addition, we will keep a null initializer for the
<span class="structname">fake_job_info_t</span> structure so that we can simply
initialize dynamically allocated data.

</p><pre class="programlisting">
/* A statically-initialized empty job info which is used to initialize
 * dynamically allocated fake_job_info_t structs
 */
static fake_job_info_t fake_job_info_initializer;</pre><p>
</p><p><a name="gram5-lrm-seg-fake-state"></a><b>LRM Parser State. </b>
For the LRM parser state, we will keep track of the start time for which we will
emit events, the path to the fake job log, a file pointer open to that log, and 
a list of <span class="structname">fake_job_info_t</span> structs for each job we have
data for. We also use a mutex/condition variable combination to block deactivation
until all callback functions have completed. The data in this struct is
initialized in the module's activation function below. 

</p><pre class="programlisting">/**
 * State of the FAKE log file parser.
 */
static struct 
{
    /** Timestamp of when to start generating events from */
    time_t                              start_timestamp;
    /** Log file path */
    char *                              log_path;
    /** Log file pointer */
    FILE *                              log;
    /** List of job info containing future info we might need to
      * turn into job state changes
      */
    globus_list_t *                     jobs;
    /**
     * shutdown mutex
     */
    globus_mutex_t                      mutex;
    /**
     * shutdown condition
     */
    globus_cond_t                       cond;
    /**
     * shutdown flag
     */
    globus_bool_t                       shutdown_called;
    /**
     * callback count
     */
    int                                 callback_count;
} globus_l_fake_state;</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gram5-lrm-seg-module-prototypes"></a>6.5. Module Specific Prototypes</h3></div></div></div><p>For our SEG, we define a small number of static functions to process the fake
job log. These include our activation and deactivation functions, and our event callback
which is called periodically to process the fake job log. We also have a
couple of utility functions to look up entries in the job list and a predicate used
to sort a list of SEG events by timestamp and jobid.
</p><pre class="programlisting">static
int
globus_l_fake_module_activate(void);

static
int
globus_l_fake_module_deactivate(void);

static
void
globus_l_fake_read_callback(void *user_arg);

static
int
globus_l_fake_find_by_job_id(void * datum, void * arg);

static
int
globus_l_fake_compare_events(void * low_datum, void * high_datum, void * relation_args);</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gram5-lrm-seg-module-descriptor"></a>6.6. Extension Module Descriptor</h3></div></div></div><p>
The SEG dynamically loads our code using the Globus Extension API. To implement
the interface it needs, we must define an extension descriptor so that it can find
the entry point to our library. This module descriptor contains pointers to the
activation and deactivation functions we prototyped above. It can contain other
pointers but they aren't needed for our module implementation so we leave them
as NULL.

</p><pre class="programlisting">
GlobusExtensionDefineModule(globus_seg_fake) =
{
    "globus_seg_fake",
    globus_l_fake_module_activate,
    globus_l_fake_module_deactivate,
    NULL,
    NULL,
    NULL
};</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gram5-lrm-seg-module-activation"></a>6.7. Module Activation</h3></div></div></div><p>
The entry point to our LRM-specific module is the activation function. This function is
invoked by the <span class="command"><strong>globus-scheduler-event-generator</strong></span> program when it starts
and dynamically loads the LRM-specific module. It is not passed any parameters, and is
expected to return <code class="literal">GLOBUS_SUCCESS</code> if it is able to activate itself.
Typically the activation function will do the following:
</p><pre class="programlisting">
static
int
globus_l_fake_module_activate(void)
{
<a class="xref" href="#gram5-lrm-module-activate-declare-vars" title="Declare Variables">Declare Variables</a>
<a class="xref" href="#gram5-lrm-module-activate-dependencies" title="Activate Dependencies">Activate Dependencies</a>
<a class="xref" href="#gram5-lrm-module-activate-prepare-shutdown-handler" title="Prepare Shutdown Handler">Prepare Shutdown Handler</a>
<a class="xref" href="#gram5-lrm-module-activate-read-configuration" title="6.7.1. LRM SEG Module Configuration">Read Configuration</a>
<a class="xref" href="#gram5-lrm-module-activate-register-event" title="6.7.2. Register Event">Register Event</a>
<a class="xref" href="#gram5-lrm-module-activate-cleanup-on-failure" title="6.7.3. Cleanup on Failure">Cleanup on Failure</a>
    return result;
} /* globus_l_fake_module_activate() */</pre><p>
</p><p><a name="gram5-lrm-module-activate-declare-vars"></a><b>Declare Variables. </b>
For our activation function, we'll use variables to store the path to the configuration
file as well as return values from functions we call.

</p><pre class="programlisting">char *                              config_path = NULL;
char *                              log_dir;
int                                 rc;
globus_result_t                     result = GLOBUS_SUCCESS;</pre><p>
</p><p><a name="gram5-lrm-module-activate-dependencies"></a><b>Activate Dependencies. </b>
The headers we've just included contain the module descriptors which we will activate
in our LRM-specific activation function, so that we are able to use the APIs in
those modules. Our module is only ever activated by the SEG module, so we shouldn't activate
it. In the activation function for our module, we'll include this fragment

</p><pre class="programlisting">rc = globus_module_activate(GLOBUS_COMMON_MODULE);
if (rc != GLOBUS_SUCCESS)
{
    fprintf(stderr, "Fatal error activating GLOBUS_COMMON_MODULE\n");

    result = GLOBUS_FAILURE;
    goto activation_failure;
}</pre><p>
</p><p><a name="gram5-lrm-module-activate-prepare-shutdown-handler"></a><b>Prepare Shutdown Handler. </b>
To handling deactivation safely, we'll create a mutex and condition variable
to handle the case of when a shutdown is called while our event handler is
running. In that case, we'll set the <code class="varname">shutdown_called</code>
variable to <code class="literal">GLOBUS_TRUE</code> and then wait until the callback 
has terminated. Here we just set the variables to their non-shutdown values.

</p><pre class="programlisting">rc = globus_mutex_init(&amp;globus_l_fake_state.mutex, NULL);
if (rc != GLOBUS_SUCCESS)
{
    result = GLOBUS_FAILURE;
    goto mutex_init_failed;
}

rc = globus_cond_init(&amp;globus_l_fake_state.cond, NULL);
if (rc != GLOBUS_SUCCESS)
{
    result = GLOBUS_FAILURE;
    goto cond_init_failed;
}
globus_l_fake_state.shutdown_called = GLOBUS_FALSE;
globus_l_fake_state.callback_count = 0;</pre><p>
</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gram5-lrm-module-activate-read-configuration"></a>6.7.1. LRM SEG Module Configuration</h4></div></div></div><p><a name="gram5-lrm-module-activate-prepare-read-configuration"></a><b>Read Configuration. </b>
There are two main pieces of configuation information we'll need to process SEG events: the
earliest timestamp we care about (which we get from the SEG module) and the path to our
fake job log file (which we get from our configuration file as in the perl module).
</p><p>
So first, to get the timestamp, we'll use the
<code class="function">globus_scheduler_event_generator_get_timestamp()</code> function.

</p><pre class="programlisting">result = globus_scheduler_event_generator_get_timestamp(
        &amp;globus_l_fake_state.start_timestamp);
if (result != GLOBUS_SUCCESS)
{
    goto get_timestamp_failed;
}</pre><p>
</p><p>Then, to get the configuration file data, we first construct the path to
the configuration file and then pull out the configuration attribute
<code class="literal">log_path</code>, falling back to the default
(<code class="filename"><em class="replaceable"><code>${localstatedir}</code></em>/fake</code> if it is
not found.

</p><pre class="programlisting">
result = globus_eval_path(
        "${sysconfdir}/globus/globus-fake.conf",
        &amp;config_path);
if (result != GLOBUS_SUCCESS || config_path == NULL)
{
    goto get_config_path_failed;
}
result = globus_common_get_attribute_from_config_file(
        "",
        config_path,
        "log_path",
        &amp;log_dir);

/* This default must match fake.pm's default for things to work */
if (result != GLOBUS_SUCCESS)
{
    result = globus_eval_path("${localstatedir}/fake", &amp;log_dir);
}

if (result != GLOBUS_SUCCESS)
{
    goto get_log_dir_failed;
}

globus_l_fake_state.log_path =
    globus_common_create_string("%s/fakejob.log", log_dir);
if (globus_l_fake_state.log_path == NULL)
{
    result = GLOBUS_FAILURE;

    goto get_log_path_failed;
}</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gram5-lrm-module-activate-register-event"></a>6.7.2. Register Event</h4></div></div></div><p>
The next main action the activation function does is to register an event to happen
later to process the events in the LRM log. For this, we use the
<code class="function">globus_callback_register_oneshot()</code> function to register an
event handler to execute as soon as possible within the
<span class="command"><strong>globus-scheduduler-event-generator</strong></span> program. The callback function 
in this case is the globus_l_fake_read_callback() function defined later.

</p><pre class="programlisting">result = globus_callback_register_oneshot(
        NULL,
        NULL,
        globus_l_fake_read_callback,
        &amp;globus_l_fake_state);
if (result != GLOBUS_SUCCESS)
{
    goto register_oneshot_failed;
}
globus_l_fake_state.callback_count++;
</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gram5-lrm-module-activate-cleanup-on-failure"></a>6.7.3. Cleanup on Failure</h4></div></div></div><p>Here we handle the errors that might have occurred above and free temporarily used
memory. In case of a failure, <code class="varname">result</code> is set to something other than
<code class="literal">GLOBUS_SUCCESS</code>.
</p><pre class="programlisting">register_oneshot_failed:
get_log_path_failed:
    if (result != GLOBUS_SUCCESS)
    {
        free(globus_l_fake_state.log_path);
    }
    free(log_dir);
get_log_dir_failed:
    free(config_path);
get_config_path_failed:
get_timestamp_failed:
    if (result != GLOBUS_SUCCESS)
    {
malloc_state_failed:
        globus_cond_destroy(&amp;globus_l_fake_state.cond);
cond_init_failed:
        globus_mutex_destroy(&amp;globus_l_fake_state.mutex);
mutex_init_failed:
        globus_module_deactivate(GLOBUS_COMMON_MODULE);
    }
activation_failure:</pre><p>
</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gram5-lrm-seg-module-deactivation"></a>6.8. Module Deactivation</h3></div></div></div><p>
For our deactivation function, we will wait use the shutdown handling variables
in the state structure to wait until all outstanding callback have terminated and
then free memory associated with the state.

</p><pre class="programlisting">static
int
globus_l_fake_module_deactivate(void)
{
    <a class="xref" href="#gram5-lrm-seg-deactivate-shutdown" title="Shutdown Handling">Shutdown Handling</a>
    <a class="xref" href="#gram5-lrm-seg-deactivate-free-state" title="Cleanup State">Cleanup State</a>
} /* globus_l_fake_module_deactivate() */</pre><p>
</p><p><a name="gram5-lrm-seg-deactivate-shutdown"></a><b>Shutdown Handling. </b>
To handle shutdown safely, we must wait until pending callbacks have
terminated.  To do this, we set the <em class="structfield"><code>shutdown_called</code></em>
field in the state structure and wait until the
<em class="structfield"><code>callback_count</code></em> field is <code class="literal">0</code>. Inside
the callback function, if we see that the
<em class="structfield"><code>shutdown_called</code></em> field is
<code class="literal">GLOBUS_TRUE</code> then it will not reregister itself and will
signal when it terminates.

</p><pre class="programlisting">globus_mutex_lock(&amp;globus_l_fake_state.mutex);
globus_l_fake_state.shutdown_called = GLOBUS_TRUE;
while (globus_l_fake_state.callback_count &gt; 0)
{
    globus_cond_wait(&amp;globus_l_fake_state.cond, &amp;globus_l_fake_state.mutex);
}
globus_mutex_unlock(&amp;globus_l_fake_state.mutex);</pre><p>
</p><p><a name="gram5-lrm-seg-deactivate-free-state"></a><b>Cleanup State. </b>
Finally, we'll free data we allocated in the activation function.

</p><pre class="programlisting">globus_mutex_destroy(&amp;globus_l_fake_state.mutex);
globus_cond_destroy(&amp;globus_l_fake_state.cond);
if (globus_l_fake_state.log_path)
{
    free(globus_l_fake_state.log_path);
}
if (globus_l_fake_state.log)
{
    fclose(globus_l_fake_state.log);
}
while (!globus_list_empty(globus_l_fake_state.jobs))
{
    fake_job_info_t *info;
    
    info = globus_list_remove(
            &amp;globus_l_fake_state.jobs,
            globus_l_fake_state.jobs);
    free(info);
}

globus_module_deactivate(GLOBUS_COMMON_MODULE);

return GLOBUS_SUCCESS;</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gram5-lrm-seg-module-process"></a>6.9. Process Events</h3></div></div></div><p>
The main activity of our LRM module is to generate SEG events so that a job manager
will be able to efficient manage its jobs. In this code, we will parse our log file
periodically, and fire off any events which are to have occurred for the jobs in the
fake job log. The structure of the processing function is this

</p><pre class="programlisting">
static
void
globus_l_fake_read_callback(void * arg)
{
<a class="xref" href="#gram5-lrm-seg-read-declare-vars" title="Declare Variables">Declare Variables</a>
<a class="xref" href="#gram5-lrm-seg-read-check-for-shutdown" title="Check for Shutdown">Check for Shutdown</a>
<a class="xref" href="#gram5-lrm-seg-read-open-log" title="Open Log">Open Log</a>
<a class="xref" href="#gram5-lrm-seg-read-read-log" title="Read Log">Read Log</a>
<a class="xref" href="#gram5-lrm-seg-read-create-events" title="Create Events">Create Events</a>
<a class="xref" href="#gram5-lrm-seg-read-emit-events" title="Emit Events">Emit Events</a>
<a class="xref" href="#gram5-lrm-seg-read-reregister" title="Reregister Callback">Reregister Callback</a>
<a class="xref" href="#gram5-lrm-seg-read-error-handling" title="Error Handling">Error Handling</a>
} /* globus_l_fake_read_callback() */</pre><p>
</p><p><a name="gram5-lrm-seg-read-declare-vars"></a><b>Declare Variables. </b>
</p><pre class="programlisting">char                                jobid[64];
globus_list_t                       *l, *events;
fake_job_info_t                     *info;
globus_reltime_t                    delay = {0};
time_t                              now;
unsigned long                       pending_time, active_time, done_time, failed_time;
globus_scheduler_event_t            *e;
time_t                              last_timestamp;
globus_result_t                     result = GLOBUS_SUCCESS;</pre><p>
</p><p><a name="gram5-lrm-seg-read-check-for-shutdown"></a><b>Check for Shutdown. </b>To check for shutdown, we'll first lock the mutex associated with the state
structure and check if the <em class="structfield"><code>shutdown_called</code></em> field
is set to true. If so, we'll jump to our error handling code.

</p><pre class="programlisting">globus_mutex_lock(&amp;globus_l_fake_state.mutex);
if (globus_l_fake_state.shutdown_called)
{
    result = GLOBUS_FAILURE;
    goto error;
}</pre><p>
</p><p><a name="gram5-lrm-seg-read-open-log"></a><b>Open Log. </b>
In general, we'll keep a file open to parse the log, but the first time around,
or before any events have been written, the log file might not exist. So we'll
check to see if we have a <code class="literal">NULL</code> file pointer, and if so, try
to open the file. Once opened, we'll use line buffering while we process the file.

</p><pre class="programlisting">if (globus_l_fake_state.log == NULL)
{
    globus_l_fake_state.log = fopen(globus_l_fake_state.log_path, "r");
    if (globus_l_fake_state.log != NULL)
    {
        /* Enable line buffering */
        setvbuf(globus_l_fake_state.log, NULL, _IOLBF, 0);
    }
}
if (globus_l_fake_state.log == NULL)
{
    result = GLOBUS_FAILURE;
    GlobusTimeReltimeSet(delay, 30, 0);
    goto reregister;
}</pre><p>
</p><p><a name="gram5-lrm-seg-read-read-log"></a><b>Read Log. </b>
Now we will read all of the log entries from our current position until the end
of file. If we've already parsed an entry for a particular job, we will zero
out its timestamps and replace with the new timestamps to handle cancel events
in the fake job log.

</p><pre class="programlisting">
/* previous read might have hit EOF, so clear it before trying to read */
clearerr(globus_l_fake_state.log);

/* Read any new job info from the log */
while (fscanf(globus_l_fake_state.log, "%63[^;];%ld;%ld;%ld;%ld\n",
            jobid,
            &amp;pending_time,
            &amp;active_time,
            &amp;done_time,
            &amp;failed_time) == 5)
{
    l = globus_list_search_pred(globus_l_fake_state.jobs, globus_l_fake_find_by_job_id, jobid);
    if (l != NULL)
    {
        info = globus_list_first(l);
        /* If there's a second entry for the same job, it was cancelled, so
         * clear done/failed timestamps and copy them below
         */
        info-&gt;done = info-&gt;failed = 0;
    }
    else
    {
        /* First time we've seen this job, set jobid and insert*/
        info = malloc(sizeof(fake_job_info_t));
        *info = fake_job_info_initializer;
        strcpy(info-&gt;jobid, jobid);
        globus_list_insert(&amp;globus_l_fake_state.jobs, info);
    }
    /* set timestamps */
    info-&gt;pending = pending_time;
    info-&gt;active = active_time;
    info-&gt;done = done_time;
    info-&gt;failed = failed_time;
}</pre><p>
</p><p><a name="gram5-lrm-seg-read-create-events"></a><b>Create Events. </b>
Now, we'll walk our list of jobs and create SEG events for each state transition
which has occurred since our last timestamp and the current time. These events
will be out of order in our events list, because they are created in order of
job IDs in the jobs list, and not in timestamp list. We'll deal with this later.
Note that we set the timestamp values in the job info to 0 after we create an event.
This keeps us from generating an event multiple times.

</p><pre class="programlisting">/* Create set of events that we'll emit this time through: jobs which will
 * changed state since our last event update
 */
now = time(NULL);

events = NULL;
for (l = globus_l_fake_state.jobs; l != NULL; l = globus_list_rest(l))
{
    info = globus_list_first(l);

    if (info-&gt;pending &gt;= globus_l_fake_state.start_timestamp &amp;&amp;
        info-&gt;pending &lt; now)
    {
        e = malloc(sizeof(globus_scheduler_event_t));
        e-&gt;event_type = GLOBUS_SCHEDULER_EVENT_PENDING;
        e-&gt;job_id = info-&gt;jobid;
        e-&gt;timestamp = info-&gt;pending;
        e-&gt;exit_code = 0;
        e-&gt;failure_code = 0;
        e-&gt;raw_event = NULL;

        info-&gt;pending = 0;

        globus_list_insert(&amp;events, e);
    }
    if (info-&gt;active &gt;= globus_l_fake_state.start_timestamp &amp;&amp;
        info-&gt;active &lt; now)
    {
        e = malloc(sizeof(globus_scheduler_event_t));
        e-&gt;event_type = GLOBUS_SCHEDULER_EVENT_ACTIVE;
        e-&gt;job_id = info-&gt;jobid;
        e-&gt;timestamp = info-&gt;active;
        e-&gt;exit_code = 0;
        e-&gt;failure_code = 0;
        e-&gt;raw_event = NULL;

        info-&gt;active = 0;

        globus_list_insert(&amp;events, e);
    }
    if (info-&gt;done != 0 &amp;&amp;
        info-&gt;done &gt;= globus_l_fake_state.start_timestamp &amp;&amp;
        info-&gt;done &lt; now)
    {
        e = malloc(sizeof(globus_scheduler_event_t));
        e-&gt;event_type = GLOBUS_SCHEDULER_EVENT_DONE;
        e-&gt;job_id = info-&gt;jobid;
        e-&gt;timestamp = info-&gt;done;
        e-&gt;exit_code = 0;
        e-&gt;failure_code = 0;
        e-&gt;raw_event = NULL;

        info-&gt;done = 0;

        globus_list_insert(&amp;events, e);
    }
    if (info-&gt;failed != 0 &amp;&amp;
        info-&gt;failed &gt;= globus_l_fake_state.start_timestamp &amp;&amp;
        info-&gt;failed &lt; now)
    {
        e = malloc(sizeof(globus_scheduler_event_t));
        e-&gt;event_type = GLOBUS_SCHEDULER_EVENT_FAILED;
        e-&gt;job_id = info-&gt;jobid;
        e-&gt;timestamp = info-&gt;failed;
        e-&gt;exit_code = 0;
        e-&gt;failure_code = GLOBUS_GRAM_PROTOCOL_ERROR_USER_CANCELLED;
        e-&gt;raw_event = NULL;

        info-&gt;failed = 0;

        globus_list_insert(&amp;events, e);
    }
}</pre><p>

</p><p><a name="gram5-lrm-seg-read-emit-events"></a><b>Emit Events. </b>
Now we have a set of events, we will sort them by timestamp and then use the
SEG API to emit them. After we've emitted an event, we have to free it. If the
event is a terminal one (DONE or FAILED) we'll remove the job from the list
of jobs in the state structure.

</p><pre class="programlisting">/* Sort the events so that they're in timestamp order */
events = globus_list_sort_destructive(events, globus_l_fake_compare_events, NULL);

/* Emit events in proper order */
while (! globus_list_empty(events))
{
    e = globus_list_remove(&amp;events, events);
    last_timestamp = e-&gt;timestamp;

    switch (e-&gt;event_type)
    {
        case GLOBUS_SCHEDULER_EVENT_PENDING:
            globus_scheduler_event_pending(e-&gt;timestamp, e-&gt;job_id);
            break;
        case GLOBUS_SCHEDULER_EVENT_ACTIVE:
            globus_scheduler_event_active(e-&gt;timestamp, e-&gt;job_id);
            break;
        case GLOBUS_SCHEDULER_EVENT_FAILED:
            globus_scheduler_event_failed(e-&gt;timestamp, e-&gt;job_id, e-&gt;failure_code);
            break;
        case GLOBUS_SCHEDULER_EVENT_DONE:
            globus_scheduler_event_done(e-&gt;timestamp, e-&gt;job_id, e-&gt;exit_code);
            break;
    }
    /* If this is a terminal event, we can remove the job from the list */
    if (e-&gt;event_type == GLOBUS_SCHEDULER_EVENT_FAILED ||
        e-&gt;event_type == GLOBUS_SCHEDULER_EVENT_DONE)
    {
        l = globus_list_search_pred(globus_l_fake_state.jobs, globus_l_fake_find_by_job_id, e-&gt;job_id);
        info = globus_list_remove(&amp;globus_l_fake_state.jobs, l);
        free(info);
    }

    free(e);
}
globus_l_fake_state.start_timestamp = last_timestamp;
</pre><p>
</p><p><a name="gram5-lrm-seg-read-reregister"></a><b>Reregister Callback. </b>
We'll register a new callback instance now (provided we haven't had an error occur)
so that we can continue to process jobs later.

</p><pre class="programlisting">GlobusTimeReltimeSet(delay, 1, 0);
reregister:
result = globus_callback_register_oneshot(
        NULL,
        &amp;delay,
        globus_l_fake_read_callback,
        &amp;globus_l_fake_state);
if (result != GLOBUS_SUCCESS)
{
    goto error;
}
globus_mutex_unlock(&amp;globus_l_fake_state.mutex);
return;
</pre><p>
</p><p><a name="gram5-lrm-seg-read-error-handling"></a><b>Error Handling. </b>
If an error occurred registering the event or the shutdown handler is invoked,
we'll exit this function without registering a new event. In the case the 
shutdown handling is in place, we'll signal that as well

</p><pre class="programlisting">error:
if (globus_l_fake_state.shutdown_called)
{
    globus_l_fake_state.callback_count--;

    if (globus_l_fake_state.callback_count == 0)
    {
        globus_cond_signal(&amp;globus_l_fake_state.cond);
    }
}
else
{
    fprintf(stderr,
            "FATAL: Unable to register callback. FAKE SEG exiting\n");
    exit(EXIT_FAILURE);
}
globus_mutex_unlock(&amp;globus_l_fake_state.mutex);

return;

</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gram5-lrm-seg-module-utils"></a>6.10. Utility Functions</h3></div></div></div><p>
We have two utility functions to implement for this module to manage our lists
of pending events and jobs.

</p><pre class="programlisting"><a class="xref" href="#gram5-lrm-seg-module-find-job" title="Find By Job ID">Find By Job ID</a>
<a class="xref" href="#gram5-lrm-seg-module-compare-events" title="Sort Events">Sort Events</a></pre><p>
</p><p><a name="gram5-lrm-seg-module-find-job"></a><b>Find By Job ID. </b>
The <code class="function">globus_l_fake_find_by_job_id()</code> function is used to search
the <em class="structfield"><code>jobs</code></em> field of the state structure for a
<span class="structname">fake_job_info_t</span> containing info about a particular job. This
predicate returns a non-zero value if the <em class="parameter"><code>datum</code></em> passed to the function
has the same job ID as the <em class="parameter"><code>arg</code></em> parameter.

</p><pre class="programlisting">static
int
globus_l_fake_find_by_job_id(void * datum, void * arg)
{
    fake_job_info_t * info = datum;

    return (strcmp(info-&gt;jobid, arg) == 0);
} /* globus_l_fake_find_by_job_id() */</pre><p>
</p><p><a name="gram5-lrm-seg-module-compare-events"></a><b>Sort Events. </b>The <code class="function">globus_l_fake_compare_events()</code> function is used as
a predicate to compare the timestamps and job ids of a pair of events. If the
<em class="parameter"><code>log_datum</code></em> points to an event which happens earlier in the
job lifecycle than the <em class="parameter"><code>high_datum</code></em>, this function returns
<code class="literal">GLOBUS_TRUE</code>; otherwise it returns <code class="literal">GLOBUS_FALSE</code>.

</p><pre class="programlisting">static
int
globus_l_fake_compare_events(void * low_datum, void * high_datum, void * relation_args)
{
    globus_scheduler_event_t *low_event = low_datum, *high_event = high_datum;

    if (low_event-&gt;timestamp &lt; high_event-&gt;timestamp)
    {
        return GLOBUS_TRUE;
    }
    else if (low_event-&gt;timestamp == high_event-&gt;timestamp)
    {
        if (low_event-&gt;event_type == GLOBUS_SCHEDULER_EVENT_PENDING)
        {
            return GLOBUS_TRUE;
        }
        else if (low_event-&gt;event_type == GLOBUS_SCHEDULER_EVENT_ACTIVE &amp;&amp;
                 high_event-&gt;event_type != GLOBUS_SCHEDULER_EVENT_PENDING)
        {
            return GLOBUS_TRUE;
        }
        else if (high_event-&gt;event_type != GLOBUS_SCHEDULER_EVENT_PENDING &amp;&amp;
                 high_event-&gt;event_type != GLOBUS_SCHEDULER_EVENT_ACTIVE)
        {
            return GLOBUS_TRUE;
        }
    }
    return GLOBUS_FALSE;
} /* globus_l_fake_compare_events() */</pre><p>

</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-lrma-tutorial-perl-changes"></a>7. Changes from Previous Versions</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136336255856"></a>7.1. Changes in GT 5.2</h3></div></div></div><p>GRAM5 is now designed to work as a native debian or RPM package,
    with default configuration being done at configuration time, so the setup
    script description has been removed. 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136336254112"></a>7.2. Changes in GT 5.0</h3></div></div></div><p>GRAM5 is based again on the C code base used for GRAM2 (also known
    as Pre-WS GRAM). The SEG module interface from GRAM4 is retained and
    optionally used by GRAM5. The GRAM job manager will avoid reloading
    the GRAM LRM Adapter script for each operation, so all variables not
    intended to be global state in the Perl LRM Adapter module must be
    lexically scoped, or state will leak between jobs and cause potentially
    cause problems.
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136336252096"></a>7.3. Changes in GT 4.0</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136336251392"></a>7.3.1. Module Methods</h4></div></div></div><p>The GT-4.0 ws-GRAM service only calls a subset of the Perl methods
    which were used by the pre-ws GRAM services. Most importantly for script
    implementors, the polling method is no longer used. Instead, the
    scheduler-event-generator monitors jobs to signal the service when job
    change changes occur. Staging is now done via the Reliable File Transfer
    service, so the file_stage_in and file_stage_out methods are no longer
    called. Schedulers typically did not implement the staging methods,
    so this shouldn't affect most scheduler modules.
    </p><p>That being said, scheduler implementers which would like to have
    their scheduler both with pre-ws GRAM and WS-GRAM should definitely
    implement the poll() method described in the pre-WS version of this
    tutorial.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136336267088"></a>7.3.2. GASS Cache</h4></div></div></div><p>The GT-4.0 ws-GRAM service does not use the GASS cache for storing
    temporary files or for staging files. </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136336284640"></a>7.4. Changes in GT 3.2</h3></div></div></div><p>
    In GT 3.2, additional error message context info was added. Scripts can
    optionally add one of these fields to the return hash from an operation
    to provide extra error information to the client:
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">GT3_FAILURE_MESSAGE</span></dt><dd>Error message from underlying script processing
        indicating what caused a job request to fail</dd><dt><span class="term">GT3_FAILURE_TYPE</span></dt><dd>One of <code class="literal">filestagein</code>,
        <code class="literal">filestageout</code>, <code class="literal">filestageinshared</code>,
        <code class="literal">executable</code>, or <code class="literal">stdin</code> indicating
        what job request element caused a staging fault.</dd><dt><span class="term">GT3_FAILURE_SOURCE</span></dt><dd>Source URL or file for a failed staging
        operation</dd><dt><span class="term">GT3_FAILURE_DESTINATION</span></dt><dd>Destination URL or file for a failed staging
        operation</dd></dl></div><p>
    </p></div></div></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="idm136351893664"></a>GRAM5 Developer's Reference</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="chapter"><a href="#gram5-apis">6. APIs</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136313777376">1. Programming Model Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136313764096">1.1. C API Documentation Links</a></span></dt><dt><span class="section"><a href="#idm136315038960">1.2. GRAM5 Perl API Reference</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#Globus::GRAM::Error">Globus::GRAM::Error</a></span><span class="refpurpose"> &#8212; GRAM Protocol Error Constants</span></dt><dt><span class="refentrytitle"><a href="#Globus::GRAM::JobDescription">Globus::GRAM::JobDescription</a></span><span class="refpurpose"> &#8212; GRAM Job Description</span></dt><dt><span class="refentrytitle"><a href="#Globus::GRAM::JobManager">Globus::GRAM::JobManager</a></span><span class="refpurpose"> &#8212; Base class for all Job Manager scripts</span></dt><dt><span class="refentrytitle"><a href="#Globus::GRAM::JobSignal">Globus::GRAM::JobSignal</a></span><span class="refpurpose"> &#8212; GRAM Protocol JobSignal Constants</span></dt><dt><span class="refentrytitle"><a href="#Globus::GRAM::JobState">Globus::GRAM::JobState</a></span><span class="refpurpose"> &#8212; GRAM Protocol JobState Constants</span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="#gram5-rsl">7. RSL Specification v1.1</a></span></dt><dd><dl><dt><span class="section"><a href="#gram5-rsl-syntax-overview">1. RSL Syntax Overview</a></span></dt><dt><span class="section"><a href="#gram5-rsl-tokenization-overview">2. RSL Tokenization Overview</a></span></dt><dt><span class="section"><a href="#gram5-rsl-substitution-semantics">3. RSL Substitution Semantics</a></span></dt><dt><span class="section"><a href="#gram5-rsl-attribute-summary">4. RSL Attribute Summary</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#idm136312716704">rsl</a></span><span class="refpurpose"> &#8212; GRAM5 RSL Attributes</span></dt></dl></dd><dt><span class="section"><a href="#gram5-rsl-examples">5. Simple RSL Examples</a></span></dt><dt><span class="section"><a href="#gram5-rsl-grammar-and-tokenization-rules">6. RSL grammar and tokenization rules</a></span></dt></dl></dd><dt><span class="chapter"><a href="#gram5-debugging">8. Debugging</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136317281280">1. Basic Debugging Methods</a></span></dt><dt><span class="section"><a href="#idm136339247968">2. Advanced Debugging Methods</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136339246784">2.1. Debugging the Job Manager</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#gram5-troubleshooting">9. Troubleshooting</a></span></dt><dd><dl><dt><span class="section"><a href="#gram5-troubleshooting-client">1. GRAM Client Troubleshooting</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136318052688">1.1. Credential Problems</a></span></dt><dt><span class="section"><a href="#idm136339225792">1.2. Connection Problems</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136313565968">1.2.1. Invalid Resource Name</a></span></dt><dt><span class="section"><a href="#idm136313750736">1.2.2. Mutual Authentication Failure</a></span></dt><dt><span class="section"><a href="#idm136313463664">1.2.3. Certificate Trust Issues</a></span></dt><dt><span class="section"><a href="#idm136313409856">1.2.4. Authentication with the Remote Server Failed</a></span></dt><dt><span class="section"><a href="#idm136313604592">1.2.5. Unable to Find the Requested Service</a></span></dt><dt><span class="section"><a href="#idm136313599200">1.2.6. Failed to Run the Job Manager</a></span></dt></dl></dd><dt><span class="section"><a href="#idm136313256336">1.3. Jobs are Hanging</a></span></dt><dt><span class="section"><a href="#idm136313645040">1.4. Logs and Debugging</a></span></dt><dt><span class="section"><a href="#idm136313543936">1.5. Diagnosing LRM Errors</a></span></dt><dt><span class="section"><a href="#idm136313535872">1.6. Email Support</a></span></dt></dl></dd><dt><span class="section"><a href="#gram5-troubleshooting-admin">2. Admin Troubleshooting</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136313531392">2.1. Security</a></span></dt><dt><span class="section"><a href="#idm136313407344">2.2. Verify that Services are Running</a></span></dt><dt><span class="section"><a href="#idm136313397136">2.3. Verify that LRM packages are installed</a></span></dt><dt><span class="section"><a href="#idm136313499984">2.4. Verify that the LRM packages are configured</a></span></dt><dt><span class="section"><a href="#gram5-troubleshooting-gatekeeper-log">2.5. Check the Gatekeeper Log</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136313496176">2.5.1. Authorization failures</a></span></dt><dt><span class="section"><a href="#idm136313494144">2.5.2. Gridmap failures</a></span></dt></dl></dd><dt><span class="section"><a href="#gram5-troubleshooting-jobmanager-log">2.6. Job Manager Logs</a></span></dt><dt><span class="section"><a href="#idm136313920048">2.7. Email Support</a></span></dt></dl></dd><dt><span class="section"><a href="#gram5-error-codes">3. Errors</a></span></dt></dl></dd><dt><span class="chapter"><a href="#gram5-developer-protocols">10. Semantics and syntax of protocols</a></span></dt><dd><dl><dt><span class="section"><a href="#gram5-interface-protocol">1. GRAM5 Protocol</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136340584064">1.1. Framing</a></span></dt><dt><span class="section"><a href="#idm136336970640">1.2. Message Format</a></span></dt><dt><span class="section"><a href="#idm136318072608">1.3. Message Types</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136318071968">1.3.1. Ping Request</a></span></dt><dt><span class="section"><a href="#idm136318104208">1.3.2. Job Request</a></span></dt><dt><span class="section"><a href="#idm136316035056">1.3.3. Status Request</a></span></dt><dt><span class="section"><a href="#idm136315037024">1.3.4. Callback Register Request</a></span></dt><dt><span class="section"><a href="#idm136315384016">1.3.5. Callback Unregister Request</a></span></dt><dt><span class="section"><a href="#idm136315444656">1.3.6. Job Cancel Request</a></span></dt><dt><span class="section"><a href="#idm136315874576">1.3.7. Job Signal Request</a></span></dt><dt><span class="section"><a href="#idm136315035648">1.3.8. Job State Updates</a></span></dt><dt><span class="section"><a href="#idm136315753216">1.3.9. Proxy Delegation</a></span></dt><dt><span class="section"><a href="#idm136315580816">1.3.10. Security Attributes</a></span></dt></dl></dd><dt><span class="section"><a href="#gram5-state-model">1.4. Job State Model</a></span></dt></dl></dd></dl></dd></dl></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-apis"></a>Chapter 6. APIs</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#idm136313777376">1. Programming Model Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136313764096">1.1. C API Documentation Links</a></span></dt><dt><span class="section"><a href="#idm136315038960">1.2. GRAM5 Perl API Reference</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#Globus::GRAM::Error">Globus::GRAM::Error</a></span><span class="refpurpose"> &#8212; GRAM Protocol Error Constants</span></dt><dt><span class="refentrytitle"><a href="#Globus::GRAM::JobDescription">Globus::GRAM::JobDescription</a></span><span class="refpurpose"> &#8212; GRAM Job Description</span></dt><dt><span class="refentrytitle"><a href="#Globus::GRAM::JobManager">Globus::GRAM::JobManager</a></span><span class="refpurpose"> &#8212; Base class for all Job Manager scripts</span></dt><dt><span class="refentrytitle"><a href="#Globus::GRAM::JobSignal">Globus::GRAM::JobSignal</a></span><span class="refpurpose"> &#8212; GRAM Protocol JobSignal Constants</span></dt><dt><span class="refentrytitle"><a href="#Globus::GRAM::JobState">Globus::GRAM::JobState</a></span><span class="refpurpose"> &#8212; GRAM Protocol JobState Constants</span></dt></dl></dd></dl></dd></dl></div><a class="indexterm" name="idm136313895744"></a><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="idm136313777376"></a>1. Programming Model Overview</h2></div></div></div><a class="indexterm" name="idm136313724832"></a><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136313764096"></a>1.1. C API Documentation Links</h3></div></div></div><div class="table"><a name="idm136313711296"></a><p class="title"><b>Table 6.1. GRAM Client APIs</b></p><div class="table-contents"><table summary="GRAM Client APIs" border="1" width="700px"><colgroup><col><col></colgroup><thead><tr><th><p>Name</p></th><th><p>Purpose</p></th></tr></thead><tbody><tr><td><p><a class="ulink" href="http://www.globus.org/api/c-globus-6.0/globus_gram_protocol/html/" target="_top">GRAM Protocol</a></p></td><td><p>Low-level functions for
                            processing GRAM protocol messages. Symbolic
                            constants for RSL attributes, signals, and job
                            states.</p></td></tr><tr><td><p><a class="ulink" href="http://www.globus.org/api/c-globus-6.0/globus_gram_client/html/" target="_top">GRAM Client</a></p></td><td><p>Functions for submitting job
                            requests, sending signals, and listening for
                            job state updates.</p></td></tr><tr><td><p><a class="ulink" href="http://www.globus.org/api/c-globus-6.0/globus_rsl/html/" target="_top">RSL</a></p></td><td><p>Functions for parsing and
                            manipulating job specifications in the RSL
                            language.</p></td></tr><tr><td><p><a class="ulink" href="http://www.globus.org/api/c-globus-6.0/globus_scheduler_event_generator/html/" target="_top">Scheduler Event Generator</a></p></td><td><p>Functions for generating and
                            parsing LRM-independent job state change
                            events.</p></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136315038960"></a>1.2. GRAM5 Perl API Reference</h3></div></div></div><div class="refentry"><a name="Globus::GRAM::Error"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>Globus::GRAM::Error &#8212; GRAM Protocol Error Constants</p></div><div class="refsection"><a name="ID-c60796a234d35f578606676c401dfc40"></a><h2>DESCRIPTION</h2><p>
      The Globus::GRAM::Error module defines symbolic names for the Error
      constants in the GRAM Protocol.
    </p><p>
      The Globus::GRAM::Error module methods return an object consisting of
      an integer erorr code, and (optionally) a string explaining the
      error.
    </p><div class="refsection"><a name="ID-e31d1ff6b6a89fcd7541fdba326160a1"></a><h3>Methods</h3><p>
        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><a name="ID-5a600439bd8665c3bf7e2be659db821e"></a>$error = new Globus::GRAM::Error($number, $string);</span></dt><dd><p>
		Create a new error object with the given error number and
		string description. This is called by the error-specific
		factory methods described below.
              </p></dd><dt><span class="term"><a name="ID-72513f9bc57b231df33564db3465cc3d"></a>$error-&gt;string()</span></dt><dd><p>
		Return the error string associated with a
		Globus::GRAM::Error object.
              </p></dd><dt><span class="term"><a name="ID-8cb8cccba69067d5c2c4bb670388b0f7"></a>$error-&gt;value()</span></dt><dd><p>
		Return the integer error code associated with a
		Globus::GRAM::Error object.
              </p></dd><dt><span class="term"><a name="ID-e0479f7fbcd4c79cb80310ac8f3046e9"></a>$error = Globus::GRAM::Error::PARAMETER_NOT_SUPPORTED()</span></dt><dd><p>
		Create a new PARAMETER_NOT_SUPPORTED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-53aed1c4b4869df71e4041fa4b43272e"></a>$error = Globus::GRAM::Error::INVALID_REQUEST()</span></dt><dd><p>
		Create a new INVALID_REQUEST GRAM error.
              </p></dd><dt><span class="term"><a name="ID-be5d55dbda0b375b3d3284e44757d99d"></a>$error = Globus::GRAM::Error::NO_RESOURCES()</span></dt><dd><p>
		Create a new NO_RESOURCES GRAM error.
              </p></dd><dt><span class="term"><a name="ID-5eb332b5bcb004ef91d2b26b4e5c1d38"></a>$error = Globus::GRAM::Error::BAD_DIRECTORY()</span></dt><dd><p>
		Create a new BAD_DIRECTORY GRAM error.
              </p></dd><dt><span class="term"><a name="ID-4a3fd8e64c6668d4b7d52e327189008d"></a>$error = Globus::GRAM::Error::EXECUTABLE_NOT_FOUND()</span></dt><dd><p>
		Create a new EXECUTABLE_NOT_FOUND GRAM error.
              </p></dd><dt><span class="term"><a name="ID-221a62d9a9b41717c361124368c39470"></a>$error = Globus::GRAM::Error::INSUFFICIENT_FUNDS()</span></dt><dd><p>
		Create a new INSUFFICIENT_FUNDS GRAM error.
              </p></dd><dt><span class="term"><a name="ID-7c9f5bb868ce31561115f898eb2a24ae"></a>$error = Globus::GRAM::Error::AUTHORIZATION()</span></dt><dd><p>
		Create a new AUTHORIZATION GRAM error.
              </p></dd><dt><span class="term"><a name="ID-525ff9d85a1e76b48e587426e11f40ef"></a>$error = Globus::GRAM::Error::USER_CANCELLED()</span></dt><dd><p>
		Create a new USER_CANCELLED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-7027703cf6eeb3f1f159cfba3b52b50a"></a>$error = Globus::GRAM::Error::SYSTEM_CANCELLED()</span></dt><dd><p>
		Create a new SYSTEM_CANCELLED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-cd36061a549ff631c2b1439d3f60a874"></a>$error = Globus::GRAM::Error::PROTOCOL_FAILED()</span></dt><dd><p>
		Create a new PROTOCOL_FAILED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-d23bcfe83ebf125c8e826807190f4fbe"></a>$error = Globus::GRAM::Error::STDIN_NOT_FOUND()</span></dt><dd><p>
		Create a new STDIN_NOT_FOUND GRAM error.
              </p></dd><dt><span class="term"><a name="ID-1109de1ce023093593fef93138f99aaa"></a>$error = Globus::GRAM::Error::CONNECTION_FAILED()</span></dt><dd><p>
		Create a new CONNECTION_FAILED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-d29b773c6eb1137b216eb48486a56447"></a>$error = Globus::GRAM::Error::INVALID_MAXTIME()</span></dt><dd><p>
		Create a new INVALID_MAXTIME GRAM error.
              </p></dd><dt><span class="term"><a name="ID-70afb8b85a683ecaf7bba1bae50978b1"></a>$error = Globus::GRAM::Error::INVALID_COUNT()</span></dt><dd><p>
		Create a new INVALID_COUNT GRAM error.
              </p></dd><dt><span class="term"><a name="ID-2f64e74ae36278cfd7d32951ed5fb98a"></a>$error = Globus::GRAM::Error::NULL_SPECIFICATION_TREE()</span></dt><dd><p>
		Create a new NULL_SPECIFICATION_TREE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-c9f0374c5582484b9ebad92188ef2c2d"></a>$error = Globus::GRAM::Error::JM_FAILED_ALLOW_ATTACH()</span></dt><dd><p>
		Create a new JM_FAILED_ALLOW_ATTACH GRAM error.
              </p></dd><dt><span class="term"><a name="ID-59996c31d30960368459b302260ffa1b"></a>$error = Globus::GRAM::Error::JOB_EXECUTION_FAILED()</span></dt><dd><p>
		Create a new JOB_EXECUTION_FAILED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-ab12712ad22a001581279a0c8a69b3bb"></a>$error = Globus::GRAM::Error::INVALID_PARADYN()</span></dt><dd><p>
		Create a new INVALID_PARADYN GRAM error.
              </p></dd><dt><span class="term"><a name="ID-443a3bdc2885be595e17e9fc483db39a"></a>$error = Globus::GRAM::Error::INVALID_JOBTYPE()</span></dt><dd><p>
		Create a new INVALID_JOBTYPE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-8bf1fbacfdb11610ce307bac0e4579ec"></a>$error = Globus::GRAM::Error::INVALID_GRAM_MYJOB()</span></dt><dd><p>
		Create a new INVALID_GRAM_MYJOB GRAM error.
              </p></dd><dt><span class="term"><a name="ID-07ec4372a2735c354ab07b1da953c8d1"></a>$error = Globus::GRAM::Error::BAD_SCRIPT_ARG_FILE()</span></dt><dd><p>
		Create a new BAD_SCRIPT_ARG_FILE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-88dc066a05558db7a60328a1355191d1"></a>$error = Globus::GRAM::Error::ARG_FILE_CREATION_FAILED()</span></dt><dd><p>
		Create a new ARG_FILE_CREATION_FAILED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-547164319d42eaf76741010c2e8ca6c8"></a>$error = Globus::GRAM::Error::INVALID_JOBSTATE()</span></dt><dd><p>
		Create a new INVALID_JOBSTATE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-7bee787424c7f06d8ca7be7c57102ca2"></a>$error = Globus::GRAM::Error::INVALID_SCRIPT_REPLY()</span></dt><dd><p>
		Create a new INVALID_SCRIPT_REPLY GRAM error.
              </p></dd><dt><span class="term"><a name="ID-3d7ce3008d19f8b9babb27b24d3fc24b"></a>$error = Globus::GRAM::Error::INVALID_SCRIPT_STATUS()</span></dt><dd><p>
		Create a new INVALID_SCRIPT_STATUS GRAM error.
              </p></dd><dt><span class="term"><a name="ID-4d3691747b9abdf34b8ea1a3332081b0"></a>$error = Globus::GRAM::Error::JOBTYPE_NOT_SUPPORTED()</span></dt><dd><p>
		Create a new JOBTYPE_NOT_SUPPORTED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-edc8f13b74a2f6a7c8d398d60ea2e0ab"></a>$error = Globus::GRAM::Error::UNIMPLEMENTED()</span></dt><dd><p>
		Create a new UNIMPLEMENTED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-acb674c759a37f6405148ff8cc73612f"></a>$error = Globus::GRAM::Error::TEMP_SCRIPT_FILE_FAILED()</span></dt><dd><p>
		Create a new TEMP_SCRIPT_FILE_FAILED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-3df6c00809fca9cfb966f25b62a4c1d3"></a>$error = Globus::GRAM::Error::USER_PROXY_NOT_FOUND()</span></dt><dd><p>
		Create a new USER_PROXY_NOT_FOUND GRAM error.
              </p></dd><dt><span class="term"><a name="ID-03c58d25bbca2e95d5be9e1d91601939"></a>$error = Globus::GRAM::Error::OPENING_USER_PROXY()</span></dt><dd><p>
		Create a new OPENING_USER_PROXY GRAM error.
              </p></dd><dt><span class="term"><a name="ID-a2497cd929628ec84b3ae6523bfa963f"></a>$error = Globus::GRAM::Error::JOB_CANCEL_FAILED()</span></dt><dd><p>
		Create a new JOB_CANCEL_FAILED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-4139f58311371f5760bfd4ae8e30c947"></a>$error = Globus::GRAM::Error::MALLOC_FAILED()</span></dt><dd><p>
		Create a new MALLOC_FAILED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-f347f600dbee81a2def13c492ccc6076"></a>$error = Globus::GRAM::Error::DUCT_INIT_FAILED()</span></dt><dd><p>
		Create a new DUCT_INIT_FAILED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-c1305972aed3dc05b9a26cdf8886b23f"></a>$error = Globus::GRAM::Error::DUCT_LSP_FAILED()</span></dt><dd><p>
		Create a new DUCT_LSP_FAILED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-458dd915462b8ce50404c33f7c7ffcb7"></a>$error = Globus::GRAM::Error::INVALID_HOST_COUNT()</span></dt><dd><p>
		Create a new INVALID_HOST_COUNT GRAM error.
              </p></dd><dt><span class="term"><a name="ID-816e4f498d25252f6ee8d1933fd9593c"></a>$error = Globus::GRAM::Error::UNSUPPORTED_PARAMETER()</span></dt><dd><p>
		Create a new UNSUPPORTED_PARAMETER GRAM error.
              </p></dd><dt><span class="term"><a name="ID-3a93d49d7f0fe1ba54892ba082b6123a"></a>$error = Globus::GRAM::Error::INVALID_QUEUE()</span></dt><dd><p>
		Create a new INVALID_QUEUE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-2b63eb6338f55cca3823e9c27249cb5f"></a>$error = Globus::GRAM::Error::INVALID_PROJECT()</span></dt><dd><p>
		Create a new INVALID_PROJECT GRAM error.
              </p></dd><dt><span class="term"><a name="ID-80bd3fa0ae0bd741898a326aeed6c444"></a>$error = Globus::GRAM::Error::RSL_EVALUATION_FAILED()</span></dt><dd><p>
		Create a new RSL_EVALUATION_FAILED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-47b495c4cb85bb58cc5d9f8b7e93f24c"></a>$error = Globus::GRAM::Error::BAD_RSL_ENVIRONMENT()</span></dt><dd><p>
		Create a new BAD_RSL_ENVIRONMENT GRAM error.
              </p></dd><dt><span class="term"><a name="ID-889a9134d0a9d715f7b9cdf89feaede3"></a>$error = Globus::GRAM::Error::DRYRUN()</span></dt><dd><p>
		Create a new DRYRUN GRAM error.
              </p></dd><dt><span class="term"><a name="ID-6a79259eb4b96490e842b8b9e1530276"></a>$error = Globus::GRAM::Error::ZERO_LENGTH_RSL()</span></dt><dd><p>
		Create a new ZERO_LENGTH_RSL GRAM error.
              </p></dd><dt><span class="term"><a name="ID-9a02ca21b994c71800a2be1dcab65af0"></a>$error = Globus::GRAM::Error::STAGING_EXECUTABLE()</span></dt><dd><p>
		Create a new STAGING_EXECUTABLE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-32ecf8aec40d09898ab810dd58353d79"></a>$error = Globus::GRAM::Error::STAGING_STDIN()</span></dt><dd><p>
		Create a new STAGING_STDIN GRAM error.
              </p></dd><dt><span class="term"><a name="ID-908a0b57ddf83e78a72a9f4a0e9e25d6"></a>$error = Globus::GRAM::Error::INVALID_JOB_MANAGER_TYPE()</span></dt><dd><p>
		Create a new INVALID_JOB_MANAGER_TYPE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-0500a35d9a17a01cb439c2733f2127cf"></a>$error = Globus::GRAM::Error::BAD_ARGUMENTS()</span></dt><dd><p>
		Create a new BAD_ARGUMENTS GRAM error.
              </p></dd><dt><span class="term"><a name="ID-0108d4231bb4cb497359657f6bd77ebb"></a>$error = Globus::GRAM::Error::GATEKEEPER_MISCONFIGURED()</span></dt><dd><p>
		Create a new GATEKEEPER_MISCONFIGURED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-371763e1c8da933be56450251ae36b9c"></a>$error = Globus::GRAM::Error::BAD_RSL()</span></dt><dd><p>
		Create a new BAD_RSL GRAM error.
              </p></dd><dt><span class="term"><a name="ID-06488817ea25a59cd61a69f0f2d0f0b9"></a>$error = Globus::GRAM::Error::VERSION_MISMATCH()</span></dt><dd><p>
		Create a new VERSION_MISMATCH GRAM error.
              </p></dd><dt><span class="term"><a name="ID-11ae5030ab37018548a17c3bc3199e88"></a>$error = Globus::GRAM::Error::RSL_ARGUMENTS()</span></dt><dd><p>
		Create a new RSL_ARGUMENTS GRAM error.
              </p></dd><dt><span class="term"><a name="ID-023007f229040663c37aa4bcb7221acb"></a>$error = Globus::GRAM::Error::RSL_COUNT()</span></dt><dd><p>
		Create a new RSL_COUNT GRAM error.
              </p></dd><dt><span class="term"><a name="ID-a1758f240f8bcd0b1d32d1a6ad1ff809"></a>$error = Globus::GRAM::Error::RSL_DIRECTORY()</span></dt><dd><p>
		Create a new RSL_DIRECTORY GRAM error.
              </p></dd><dt><span class="term"><a name="ID-8bfa7bf6670e0f3952fcce93a3ad861b"></a>$error = Globus::GRAM::Error::RSL_DRYRUN()</span></dt><dd><p>
		Create a new RSL_DRYRUN GRAM error.
              </p></dd><dt><span class="term"><a name="ID-c954710e7a0a85ab8d0b86d3f59e8896"></a>$error = Globus::GRAM::Error::RSL_ENVIRONMENT()</span></dt><dd><p>
		Create a new RSL_ENVIRONMENT GRAM error.
              </p></dd><dt><span class="term"><a name="ID-fb028c343a5243048070b89213750d53"></a>$error = Globus::GRAM::Error::RSL_EXECUTABLE()</span></dt><dd><p>
		Create a new RSL_EXECUTABLE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-4ef345a36c9454d1edcc911dbac589e1"></a>$error = Globus::GRAM::Error::RSL_HOST_COUNT()</span></dt><dd><p>
		Create a new RSL_HOST_COUNT GRAM error.
              </p></dd><dt><span class="term"><a name="ID-2f75c88b7b4720ff903476441f9562f0"></a>$error = Globus::GRAM::Error::RSL_JOBTYPE()</span></dt><dd><p>
		Create a new RSL_JOBTYPE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-a0157be0fe3e84b65cfa2495157fe5c6"></a>$error = Globus::GRAM::Error::RSL_MAXTIME()</span></dt><dd><p>
		Create a new RSL_MAXTIME GRAM error.
              </p></dd><dt><span class="term"><a name="ID-3f87e3744174ec35a0d6b81f414218b2"></a>$error = Globus::GRAM::Error::RSL_MYJOB()</span></dt><dd><p>
		Create a new RSL_MYJOB GRAM error.
              </p></dd><dt><span class="term"><a name="ID-1d1a49ca20cca7d3273619c97b85b2f2"></a>$error = Globus::GRAM::Error::RSL_PARADYN()</span></dt><dd><p>
		Create a new RSL_PARADYN GRAM error.
              </p></dd><dt><span class="term"><a name="ID-65c1f686b5b3dbcb8024da4383093975"></a>$error = Globus::GRAM::Error::RSL_PROJECT()</span></dt><dd><p>
		Create a new RSL_PROJECT GRAM error.
              </p></dd><dt><span class="term"><a name="ID-40482c5477d217579768bb75c1a4711a"></a>$error = Globus::GRAM::Error::RSL_QUEUE()</span></dt><dd><p>
		Create a new RSL_QUEUE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-e96fe51e63c4a8475cf21d107d4ec89d"></a>$error = Globus::GRAM::Error::RSL_STDERR()</span></dt><dd><p>
		Create a new RSL_STDERR GRAM error.
              </p></dd><dt><span class="term"><a name="ID-ef629e8c5b26bcc380e401c64dc9aac2"></a>$error = Globus::GRAM::Error::RSL_STDIN()</span></dt><dd><p>
		Create a new RSL_STDIN GRAM error.
              </p></dd><dt><span class="term"><a name="ID-16224441cfb3c40b9514d33bce34b12b"></a>$error = Globus::GRAM::Error::RSL_STDOUT()</span></dt><dd><p>
		Create a new RSL_STDOUT GRAM error.
              </p></dd><dt><span class="term"><a name="ID-cc637b53fcf59fb279d7c37f43541ce7"></a>$error = Globus::GRAM::Error::OPENING_JOBMANAGER_SCRIPT()</span></dt><dd><p>
		Create a new OPENING_JOBMANAGER_SCRIPT GRAM error.
              </p></dd><dt><span class="term"><a name="ID-a19792637132fcc9afa75679938c3962"></a>$error = Globus::GRAM::Error::CREATING_PIPE()</span></dt><dd><p>
		Create a new CREATING_PIPE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-c3c25a896255bf2f6f4504d95dfefe24"></a>$error = Globus::GRAM::Error::FCNTL_FAILED()</span></dt><dd><p>
		Create a new FCNTL_FAILED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-08bedcfe423d764b57e3872576c2e747"></a>$error = Globus::GRAM::Error::STDOUT_FILENAME_FAILED()</span></dt><dd><p>
		Create a new STDOUT_FILENAME_FAILED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-a5d50b0162d7942385e3416e17d96d0f"></a>$error = Globus::GRAM::Error::STDERR_FILENAME_FAILED()</span></dt><dd><p>
		Create a new STDERR_FILENAME_FAILED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-553868006465e3a66be9fd5b74cf423e"></a>$error = Globus::GRAM::Error::FORKING_EXECUTABLE()</span></dt><dd><p>
		Create a new FORKING_EXECUTABLE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-3a434c6da4c6353d0cc6c97e021a837a"></a>$error = Globus::GRAM::Error::EXECUTABLE_PERMISSIONS()</span></dt><dd><p>
		Create a new EXECUTABLE_PERMISSIONS GRAM error.
              </p></dd><dt><span class="term"><a name="ID-30df5b2074173ccd02d7c7e662ac3d83"></a>$error = Globus::GRAM::Error::OPENING_STDOUT()</span></dt><dd><p>
		Create a new OPENING_STDOUT GRAM error.
              </p></dd><dt><span class="term"><a name="ID-27da25d7ea0bf30bb944b3cf7eff7d26"></a>$error = Globus::GRAM::Error::OPENING_STDERR()</span></dt><dd><p>
		Create a new OPENING_STDERR GRAM error.
              </p></dd><dt><span class="term"><a name="ID-f703180693e2bcdd4f9edb1749f5d410"></a>$error = Globus::GRAM::Error::OPENING_CACHE_USER_PROXY()</span></dt><dd><p>
		Create a new OPENING_CACHE_USER_PROXY GRAM error.
              </p></dd><dt><span class="term"><a name="ID-393f996f0ec0967091d9c33fc7ee4502"></a>$error = Globus::GRAM::Error::OPENING_CACHE()</span></dt><dd><p>
		Create a new OPENING_CACHE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-ca75c1feaca120b249347d606622a113"></a>$error = Globus::GRAM::Error::INSERTING_CLIENT_CONTACT()</span></dt><dd><p>
		Create a new INSERTING_CLIENT_CONTACT GRAM error.
              </p></dd><dt><span class="term"><a name="ID-682b6b1012f1047b4e93adb86d9fe274"></a>$error = Globus::GRAM::Error::CLIENT_CONTACT_NOT_FOUND()</span></dt><dd><p>
		Create a new CLIENT_CONTACT_NOT_FOUND GRAM error.
              </p></dd><dt><span class="term"><a name="ID-1f7748188037a3d3ee34f6e9c1d9694c"></a>$error = Globus::GRAM::Error::CONTACTING_JOB_MANAGER()</span></dt><dd><p>
		Create a new CONTACTING_JOB_MANAGER GRAM error.
              </p></dd><dt><span class="term"><a name="ID-cb59bc55267f938d0b2878e6838cbd77"></a>$error = Globus::GRAM::Error::INVALID_JOB_CONTACT()</span></dt><dd><p>
		Create a new INVALID_JOB_CONTACT GRAM error.
              </p></dd><dt><span class="term"><a name="ID-42b9ee8a1aa5841d268fa67713ec2e20"></a>$error = Globus::GRAM::Error::UNDEFINED_EXE()</span></dt><dd><p>
		Create a new UNDEFINED_EXE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-48ded15e76c942c7e6f305d07a3a94ac"></a>$error = Globus::GRAM::Error::CONDOR_ARCH()</span></dt><dd><p>
		Create a new CONDOR_ARCH GRAM error.
              </p></dd><dt><span class="term"><a name="ID-1ea2e012e1716f1d94747c8e9eb49e27"></a>$error = Globus::GRAM::Error::CONDOR_OS()</span></dt><dd><p>
		Create a new CONDOR_OS GRAM error.
              </p></dd><dt><span class="term"><a name="ID-a0f02a5454cc31522263933f4d9da3ef"></a>$error = Globus::GRAM::Error::RSL_MIN_MEMORY()</span></dt><dd><p>
		Create a new RSL_MIN_MEMORY GRAM error.
              </p></dd><dt><span class="term"><a name="ID-1b3ece0bd4f4252f01396a2b50138876"></a>$error = Globus::GRAM::Error::RSL_MAX_MEMORY()</span></dt><dd><p>
		Create a new RSL_MAX_MEMORY GRAM error.
              </p></dd><dt><span class="term"><a name="ID-dfdb0c8ca90d8f5c97869af65ed76108"></a>$error = Globus::GRAM::Error::INVALID_MIN_MEMORY()</span></dt><dd><p>
		Create a new INVALID_MIN_MEMORY GRAM error.
              </p></dd><dt><span class="term"><a name="ID-55246066ce2fcd5ff470edfc8231e10c"></a>$error = Globus::GRAM::Error::INVALID_MAX_MEMORY()</span></dt><dd><p>
		Create a new INVALID_MAX_MEMORY GRAM error.
              </p></dd><dt><span class="term"><a name="ID-dd8a9387e36d6cfc2d23bc6edc637a0a"></a>$error = Globus::GRAM::Error::HTTP_FRAME_FAILED()</span></dt><dd><p>
		Create a new HTTP_FRAME_FAILED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-92ed4d5c263799ca6c9c56fc351036bd"></a>$error = Globus::GRAM::Error::HTTP_UNFRAME_FAILED()</span></dt><dd><p>
		Create a new HTTP_UNFRAME_FAILED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-5933741496cfb83f9aa5dc06b4e99bac"></a>$error = Globus::GRAM::Error::HTTP_PACK_FAILED()</span></dt><dd><p>
		Create a new HTTP_PACK_FAILED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-3e4a435566bb04ad47fbf1d32cd7ed82"></a>$error = Globus::GRAM::Error::HTTP_UNPACK_FAILED()</span></dt><dd><p>
		Create a new HTTP_UNPACK_FAILED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-1c77eb0c2ff071fee3f477d51420f559"></a>$error = Globus::GRAM::Error::INVALID_JOB_QUERY()</span></dt><dd><p>
		Create a new INVALID_JOB_QUERY GRAM error.
              </p></dd><dt><span class="term"><a name="ID-27cee21633c83f4efe5ff7193ff4705b"></a>$error = Globus::GRAM::Error::SERVICE_NOT_FOUND()</span></dt><dd><p>
		Create a new SERVICE_NOT_FOUND GRAM error.
              </p></dd><dt><span class="term"><a name="ID-8d8489e736e51978930567e8b2b094b1"></a>$error = Globus::GRAM::Error::JOB_QUERY_DENIAL()</span></dt><dd><p>
		Create a new JOB_QUERY_DENIAL GRAM error.
              </p></dd><dt><span class="term"><a name="ID-48e0abd3566bb4215167ff33fba944d3"></a>$error = Globus::GRAM::Error::CALLBACK_NOT_FOUND()</span></dt><dd><p>
		Create a new CALLBACK_NOT_FOUND GRAM error.
              </p></dd><dt><span class="term"><a name="ID-c32adab3a6c69035b6693eef6b925f0f"></a>$error = Globus::GRAM::Error::BAD_GATEKEEPER_CONTACT()</span></dt><dd><p>
		Create a new BAD_GATEKEEPER_CONTACT GRAM error.
              </p></dd><dt><span class="term"><a name="ID-55870c8572cedc4ac6d362037b942411"></a>$error = Globus::GRAM::Error::POE_NOT_FOUND()</span></dt><dd><p>
		Create a new POE_NOT_FOUND GRAM error.
              </p></dd><dt><span class="term"><a name="ID-6b2b235b7de8e09072d1177e256c0541"></a>$error = Globus::GRAM::Error::MPIRUN_NOT_FOUND()</span></dt><dd><p>
		Create a new MPIRUN_NOT_FOUND GRAM error.
              </p></dd><dt><span class="term"><a name="ID-ea84b064dbdb133e92144c1c967ab34e"></a>$error = Globus::GRAM::Error::RSL_START_TIME()</span></dt><dd><p>
		Create a new RSL_START_TIME GRAM error.
              </p></dd><dt><span class="term"><a name="ID-78a53a0816158f208812c6d313843942"></a>$error = Globus::GRAM::Error::RSL_RESERVATION_HANDLE()</span></dt><dd><p>
		Create a new RSL_RESERVATION_HANDLE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-0ffd240d2d4586a893df546027042992"></a>$error = Globus::GRAM::Error::RSL_MAX_WALL_TIME()</span></dt><dd><p>
		Create a new RSL_MAX_WALL_TIME GRAM error.
              </p></dd><dt><span class="term"><a name="ID-7175a0297e49ecad7d0566200a4b494b"></a>$error = Globus::GRAM::Error::INVALID_MAX_WALL_TIME()</span></dt><dd><p>
		Create a new INVALID_MAX_WALL_TIME GRAM error.
              </p></dd><dt><span class="term"><a name="ID-f7c606ebc65c8dd5d815479fc5b83279"></a>$error = Globus::GRAM::Error::RSL_MAX_CPU_TIME()</span></dt><dd><p>
		Create a new RSL_MAX_CPU_TIME GRAM error.
              </p></dd><dt><span class="term"><a name="ID-759e360b2137a15a852353b644f250b8"></a>$error = Globus::GRAM::Error::INVALID_MAX_CPU_TIME()</span></dt><dd><p>
		Create a new INVALID_MAX_CPU_TIME GRAM error.
              </p></dd><dt><span class="term"><a name="ID-7d2b1f18ea7a457a24e2afe01f3d71c9"></a>$error = Globus::GRAM::Error::JM_SCRIPT_NOT_FOUND()</span></dt><dd><p>
		Create a new JM_SCRIPT_NOT_FOUND GRAM error.
              </p></dd><dt><span class="term"><a name="ID-2ad23f502a5165d6c2dd2cd9c95bfd68"></a>$error = Globus::GRAM::Error::JM_SCRIPT_PERMISSIONS()</span></dt><dd><p>
		Create a new JM_SCRIPT_PERMISSIONS GRAM error.
              </p></dd><dt><span class="term"><a name="ID-aa9a1569b6666a0efd365795790d2d3d"></a>$error = Globus::GRAM::Error::SIGNALING_JOB()</span></dt><dd><p>
		Create a new SIGNALING_JOB GRAM error.
              </p></dd><dt><span class="term"><a name="ID-3593a12686928ad3d91accda963d3b47"></a>$error = Globus::GRAM::Error::UNKNOWN_SIGNAL_TYPE()</span></dt><dd><p>
		Create a new UNKNOWN_SIGNAL_TYPE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-96397fb614b48490ef2e13e4e2387b56"></a>$error = Globus::GRAM::Error::GETTING_JOBID()</span></dt><dd><p>
		Create a new GETTING_JOBID GRAM error.
              </p></dd><dt><span class="term"><a name="ID-13bf797fee5d96f265337dcc7a4719c9"></a>$error = Globus::GRAM::Error::WAITING_FOR_COMMIT()</span></dt><dd><p>
		Create a new WAITING_FOR_COMMIT GRAM error.
              </p></dd><dt><span class="term"><a name="ID-1dc0bb5dea7e0d8a3cffea14f13385bb"></a>$error = Globus::GRAM::Error::COMMIT_TIMED_OUT()</span></dt><dd><p>
		Create a new COMMIT_TIMED_OUT GRAM error.
              </p></dd><dt><span class="term"><a name="ID-2d1214d1873223a559a7a4fcd6d64a81"></a>$error = Globus::GRAM::Error::RSL_SAVE_STATE()</span></dt><dd><p>
		Create a new RSL_SAVE_STATE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-0374f1d010d6552d54959e303fd1d45c"></a>$error = Globus::GRAM::Error::RSL_RESTART()</span></dt><dd><p>
		Create a new RSL_RESTART GRAM error.
              </p></dd><dt><span class="term"><a name="ID-0f1f94fde504cccc19e16585527e5d6a"></a>$error = Globus::GRAM::Error::RSL_TWO_PHASE_COMMIT()</span></dt><dd><p>
		Create a new RSL_TWO_PHASE_COMMIT GRAM error.
              </p></dd><dt><span class="term"><a name="ID-2e0d6ed83f8334bb9404bdf367dee226"></a>$error = Globus::GRAM::Error::INVALID_TWO_PHASE_COMMIT()</span></dt><dd><p>
		Create a new INVALID_TWO_PHASE_COMMIT GRAM error.
              </p></dd><dt><span class="term"><a name="ID-1d25bd4b6c3b4c859a0c988169022313"></a>$error = Globus::GRAM::Error::RSL_STDOUT_POSITION()</span></dt><dd><p>
		Create a new RSL_STDOUT_POSITION GRAM error.
              </p></dd><dt><span class="term"><a name="ID-80985958cf66afe004119a1a683be188"></a>$error = Globus::GRAM::Error::INVALID_STDOUT_POSITION()</span></dt><dd><p>
		Create a new INVALID_STDOUT_POSITION GRAM error.
              </p></dd><dt><span class="term"><a name="ID-5896d306006ff63949ce50041331b555"></a>$error = Globus::GRAM::Error::RSL_STDERR_POSITION()</span></dt><dd><p>
		Create a new RSL_STDERR_POSITION GRAM error.
              </p></dd><dt><span class="term"><a name="ID-2b400ea99dcab977d16ca8e3d6245af9"></a>$error = Globus::GRAM::Error::INVALID_STDERR_POSITION()</span></dt><dd><p>
		Create a new INVALID_STDERR_POSITION GRAM error.
              </p></dd><dt><span class="term"><a name="ID-06c71cf366c2076a093cc8f948efba07"></a>$error = Globus::GRAM::Error::RESTART_FAILED()</span></dt><dd><p>
		Create a new RESTART_FAILED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-e717a0ba0073b754caf17770dac38b0b"></a>$error = Globus::GRAM::Error::NO_STATE_FILE()</span></dt><dd><p>
		Create a new NO_STATE_FILE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-7f5ea37578d214da6f20e50138b95809"></a>$error = Globus::GRAM::Error::READING_STATE_FILE()</span></dt><dd><p>
		Create a new READING_STATE_FILE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-dc6e8c1bd66d25c3b9cc76d4458e7537"></a>$error = Globus::GRAM::Error::WRITING_STATE_FILE()</span></dt><dd><p>
		Create a new WRITING_STATE_FILE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-36a536a26bc27fcc2e0fe853877c5b70"></a>$error = Globus::GRAM::Error::OLD_JM_ALIVE()</span></dt><dd><p>
		Create a new OLD_JM_ALIVE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-654df09164e091c0e4640258f1527345"></a>$error = Globus::GRAM::Error::TTL_EXPIRED()</span></dt><dd><p>
		Create a new TTL_EXPIRED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-87d4673631e10d5f15207be5f8b0ca97"></a>$error = Globus::GRAM::Error::SUBMIT_UNKNOWN()</span></dt><dd><p>
		Create a new SUBMIT_UNKNOWN GRAM error.
              </p></dd><dt><span class="term"><a name="ID-7659a48bc30b8a00165533f3ec01e24a"></a>$error = Globus::GRAM::Error::RSL_REMOTE_IO_URL()</span></dt><dd><p>
		Create a new RSL_REMOTE_IO_URL GRAM error.
              </p></dd><dt><span class="term"><a name="ID-bce72a5ff1c006a6537c901560c6b990"></a>$error = Globus::GRAM::Error::WRITING_REMOTE_IO_URL()</span></dt><dd><p>
		Create a new WRITING_REMOTE_IO_URL GRAM error.
              </p></dd><dt><span class="term"><a name="ID-58d90daa38c90af64c0dc8142b2b968c"></a>$error = Globus::GRAM::Error::STDIO_SIZE()</span></dt><dd><p>
		Create a new STDIO_SIZE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-e9f9a9d60b10d643767838979b5c8215"></a>$error = Globus::GRAM::Error::JM_STOPPED()</span></dt><dd><p>
		Create a new JM_STOPPED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-d6433ea66c1c45fe9ef8722d1784d925"></a>$error = Globus::GRAM::Error::USER_PROXY_EXPIRED()</span></dt><dd><p>
		Create a new USER_PROXY_EXPIRED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-c32f89c1690cb55b6e66941c32abd3d8"></a>$error = Globus::GRAM::Error::JOB_UNSUBMITTED()</span></dt><dd><p>
		Create a new JOB_UNSUBMITTED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-6f5cf29f0d40abb3f368212ff313a674"></a>$error = Globus::GRAM::Error::INVALID_COMMIT()</span></dt><dd><p>
		Create a new INVALID_COMMIT GRAM error.
              </p></dd><dt><span class="term"><a name="ID-8fb3666b7b82f81dfb694ceb1925b4d5"></a>$error = Globus::GRAM::Error::RSL_SCHEDULER_SPECIFIC()</span></dt><dd><p>
		Create a new RSL_SCHEDULER_SPECIFIC GRAM error.
              </p></dd><dt><span class="term"><a name="ID-aa2db95d0dd084c6026469321bd16484"></a>$error = Globus::GRAM::Error::STAGE_IN_FAILED()</span></dt><dd><p>
		Create a new STAGE_IN_FAILED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-755a584bf3b3a20b525ea43f9c7e2ce7"></a>$error = Globus::GRAM::Error::INVALID_SCRATCH()</span></dt><dd><p>
		Create a new INVALID_SCRATCH GRAM error.
              </p></dd><dt><span class="term"><a name="ID-29c2d64b89d4c88bd09bd29e93372b6e"></a>$error = Globus::GRAM::Error::RSL_CACHE()</span></dt><dd><p>
		Create a new RSL_CACHE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-71fb5baed2104c84d9d4e14d62fe648c"></a>$error = Globus::GRAM::Error::INVALID_SUBMIT_ATTRIBUTE()</span></dt><dd><p>
		Create a new INVALID_SUBMIT_ATTRIBUTE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-c78e6b86eca6bbd1718855bc2a4ec3e7"></a>$error = Globus::GRAM::Error::INVALID_STDIO_UPDATE_ATTRIBUTE()</span></dt><dd><p>
		Create a new INVALID_STDIO_UPDATE_ATTRIBUTE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-18ec30cf085e6c5acb6dc2738828fb57"></a>$error = Globus::GRAM::Error::INVALID_RESTART_ATTRIBUTE()</span></dt><dd><p>
		Create a new INVALID_RESTART_ATTRIBUTE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-e190c751b326bf02cd7fe48bd2e31620"></a>$error = Globus::GRAM::Error::RSL_FILE_STAGE_IN()</span></dt><dd><p>
		Create a new RSL_FILE_STAGE_IN GRAM error.
              </p></dd><dt><span class="term"><a name="ID-a2f0f2f426707f6252dff21f3f3491ed"></a>$error = Globus::GRAM::Error::RSL_FILE_STAGE_IN_SHARED()</span></dt><dd><p>
		Create a new RSL_FILE_STAGE_IN_SHARED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-10f7f6561e4addb3a5f342bfbe2ae3d9"></a>$error = Globus::GRAM::Error::RSL_FILE_STAGE_OUT()</span></dt><dd><p>
		Create a new RSL_FILE_STAGE_OUT GRAM error.
              </p></dd><dt><span class="term"><a name="ID-488a7c609c71e51b0952dca604459495"></a>$error = Globus::GRAM::Error::RSL_GASS_CACHE()</span></dt><dd><p>
		Create a new RSL_GASS_CACHE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-e467e6fc7114eb2f7ee72520e46e15cb"></a>$error = Globus::GRAM::Error::RSL_FILE_CLEANUP()</span></dt><dd><p>
		Create a new RSL_FILE_CLEANUP GRAM error.
              </p></dd><dt><span class="term"><a name="ID-12bc45d63528132dcbd969da2270b1f6"></a>$error = Globus::GRAM::Error::RSL_SCRATCH()</span></dt><dd><p>
		Create a new RSL_SCRATCH GRAM error.
              </p></dd><dt><span class="term"><a name="ID-3db5f370d5e8a52c0acf7c4700b81d50"></a>$error = Globus::GRAM::Error::INVALID_SCHEDULER_SPECIFIC()</span></dt><dd><p>
		Create a new INVALID_SCHEDULER_SPECIFIC GRAM error.
              </p></dd><dt><span class="term"><a name="ID-6dc742d7accf858f0b48898fd80cc4e6"></a>$error = Globus::GRAM::Error::UNDEFINED_ATTRIBUTE()</span></dt><dd><p>
		Create a new UNDEFINED_ATTRIBUTE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-75c87b2ab4b70fc1c0c3cbb5ecbb31c9"></a>$error = Globus::GRAM::Error::INVALID_CACHE()</span></dt><dd><p>
		Create a new INVALID_CACHE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-24e7c0cbdcdebc2756b8ea866aa0a920"></a>$error = Globus::GRAM::Error::INVALID_SAVE_STATE()</span></dt><dd><p>
		Create a new INVALID_SAVE_STATE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-cac4d1c66e5378a357c8b53cae761168"></a>$error = Globus::GRAM::Error::OPENING_VALIDATION_FILE()</span></dt><dd><p>
		Create a new OPENING_VALIDATION_FILE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-870a2aa32786a89332b31a9c2b43cd8f"></a>$error = Globus::GRAM::Error::READING_VALIDATION_FILE()</span></dt><dd><p>
		Create a new READING_VALIDATION_FILE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-c960e937022765f62e3ddad8466fa751"></a>$error = Globus::GRAM::Error::RSL_PROXY_TIMEOUT()</span></dt><dd><p>
		Create a new RSL_PROXY_TIMEOUT GRAM error.
              </p></dd><dt><span class="term"><a name="ID-c78449341b8de5dd849bb25821ce9524"></a>$error = Globus::GRAM::Error::INVALID_PROXY_TIMEOUT()</span></dt><dd><p>
		Create a new INVALID_PROXY_TIMEOUT GRAM error.
              </p></dd><dt><span class="term"><a name="ID-e18927966bee4da26a197b6b21ee7eaa"></a>$error = Globus::GRAM::Error::STAGE_OUT_FAILED()</span></dt><dd><p>
		Create a new STAGE_OUT_FAILED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-5d34bb2bbafbabff757981f1e6409304"></a>$error = Globus::GRAM::Error::JOB_CONTACT_NOT_FOUND()</span></dt><dd><p>
		Create a new JOB_CONTACT_NOT_FOUND GRAM error.
              </p></dd><dt><span class="term"><a name="ID-7093e360b4b1673527f0d95c80ed596c"></a>$error = Globus::GRAM::Error::DELEGATION_FAILED()</span></dt><dd><p>
		Create a new DELEGATION_FAILED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-16b40fc60c9c1b1d57aa5ffd7d7a64f4"></a>$error = Globus::GRAM::Error::LOCKING_STATE_LOCK_FILE()</span></dt><dd><p>
		Create a new LOCKING_STATE_LOCK_FILE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-32de5cb3044c87b2df722fa304a51f48"></a>$error = Globus::GRAM::Error::INVALID_ATTR()</span></dt><dd><p>
		Create a new INVALID_ATTR GRAM error.
              </p></dd><dt><span class="term"><a name="ID-296e665117c596bbbaecd63ddad42248"></a>$error = Globus::GRAM::Error::NULL_PARAMETER()</span></dt><dd><p>
		Create a new NULL_PARAMETER GRAM error.
              </p></dd><dt><span class="term"><a name="ID-fedbe078f9670dc1d202e2bf55e8b402"></a>$error = Globus::GRAM::Error::STILL_STREAMING()</span></dt><dd><p>
		Create a new STILL_STREAMING GRAM error.
              </p></dd><dt><span class="term"><a name="ID-ce6df6a214be74c9468e705d901ec7e3"></a>$error = Globus::GRAM::Error::AUTHORIZATION_DENIED()</span></dt><dd><p>
		Create a new AUTHORIZATION_DENIED GRAM error.
              </p></dd><dt><span class="term"><a name="ID-52c3d28c5b6886530202845fe97ab3a6"></a>$error = Globus::GRAM::Error::AUTHORIZATION_SYSTEM_FAILURE()</span></dt><dd><p>
		Create a new AUTHORIZATION_SYSTEM_FAILURE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-4ffba9f65b716105d9a57c3a0646daa9"></a>$error = Globus::GRAM::Error::AUTHORIZATION_DENIED_JOB_ID()</span></dt><dd><p>
		Create a new AUTHORIZATION_DENIED_JOB_ID GRAM error.
              </p></dd><dt><span class="term"><a name="ID-37f7a477ba4b531ab7fd909b7768ca2c"></a>$error = Globus::GRAM::Error::AUTHORIZATION_DENIED_EXECUTABLE()</span></dt><dd><p>
		Create a new AUTHORIZATION_DENIED_EXECUTABLE GRAM error.
              </p></dd><dt><span class="term"><a name="ID-dcb25fb20d3a79bd18556f773806c764"></a>$error = Globus::GRAM::Error::RSL_USER_NAME()</span></dt><dd><p>
		Create a new RSL_USER_NAME GRAM error.
              </p></dd><dt><span class="term"><a name="ID-a2a46f7ab2b608461588bd0d6c5faf6e"></a>$error = Globus::GRAM::Error::INVALID_USER_NAME()</span></dt><dd><p>
		Create a new INVALID_USER_NAME GRAM error.
              </p></dd><dt><span class="term"><a name="ID-001edce5356d9c130314dc1dd22e1eec"></a>$error = Globus::GRAM::Error::LAST()</span></dt><dd><p>
		Create a new LAST GRAM error.
              </p></dd></dl></div><p>
      </p></div></div></div><div class="refentry"><a name="Globus::GRAM::JobDescription"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>Globus::GRAM::JobDescription &#8212; GRAM Job Description</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="synopsis">use Globus::GRAM::JobDescription;</pre><pre class="synopsis">$hash = { executable =&gt; [ '/bin/echo' ], arguments =&gt; [ 'hello' ] };
$description = new Globus::GRAM::JobDescription($filename);
$description = new Globus::GRAM::JobDescription($hash);
$executable = $description-&gt;executable();
$description-&gt;add($new_attribute, $new_value);
$description-&gt;save();
$description-&gt;save($filename);
$description-&gt;print_recursive($file_handle);</pre></div><div class="refsection"><a name="ID-0438a8e2a51c2613b43085fb482b3c22"></a><h2>DESCRIPTION</h2><p>
      This object contains the parameters of a job request in a simple
      object wrapper. The object may be queried to determine the value of
      any RSL parameter, may be updated with new parameters, and may be
      saved in the filesystem for later use.
    </p><div class="refsection"><a name="ID-2f6bf008e67124e4a12aa84b09ebfce3"></a><h3>Methods</h3><p>
        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><a name="ID-74385b5162c5e23f79e412f6afc5e8ad"></a>new Globus::GRAM::JobDescription(<span class="italic">$filename</span>)</span></dt><dd><p>
		A JobDescription is constructed from a file consisting of a
		Perl hash of parameter =&gt; array mappings. Every value in
		the Job Description is stored internally as an array, even
		single literals, similar to the way an RSL tree is parsed
		in C. An example of such a file is
              </p><pre class="screen">$description =
{
    executable  =&gt; [ '/bin/echo' ], 
    arguments   =&gt; [ 'hello', 'world' ],
    environment =&gt; [
                       [
                           'GLOBUS_GRAM_JOB_CONTACT',
                           'https://globus.org:1234/2345/4332'
                       ]
                   ]
};</pre><p>
		which corresponds to the rsl fragment
              </p><pre class="screen">&amp;(executable  = /bin/echo)
 (arguments   = hello world)
 (environment =
     (GLOBUS_GRAM_JOB_CONTACT 'https://globus.org:1234/2345/4332')
 )</pre><p>
		When the library_path RSL attribute is specified, this
		object modifies the environment RSL attribute value to
		append its value to any system specific variables.
              </p></dd><dt><span class="term"><a name="ID-abb69df1b240687f8e028b70941194b0"></a>$description-&gt;<span class="italic">add</span>('name', <span class="italic">$value</span>);</span></dt><dd><p>
		Add a parameter to a job description. The parameter will be
		normalized internally so that the access methods described
		below will work with this new parameter. As an example,
              </p><pre class="screen">$description-&gt;add('new_attribute', $new_value)</pre><p>
		will create a new attribute in the JobDescription, which
		can be accessed by calling the <span class="italic">$description-</span>new_attribute&gt;()
		method.
              </p></dd><dt><span class="term"><a name="ID-ada8ea436a907ef2d73d291cb105ec4d"></a><span class="italic">$value</span> $description-&gt;<span class="italic">get</span>('name');</span></dt><dd><p>
		Get a parameter from a job description. As an example,
              </p><pre class="screen">$description-&gt;get('attribute')</pre><p>
		will return the appropriate attribute in the JobDescription
		by name.
              </p></dd><dt><span class="term"><a name="ID-14d7b20c9e1cdeda353d9017e46c5d66"></a>$description-&gt;<span class="italic">save</span>([$filename])</span></dt><dd><p>
		Save the JobDescription, including any added parameters, to
		the file named by $filename if present, or replacing the
		file used in constructing the object.
              </p></dd><dt><span class="term"><a name="ID-1a5a86b1c3053bcde3f55ebbb82a82d5"></a>$description-&gt;<span class="italic">print_recursive</span>($file_handle)</span></dt><dd><p>
		Write the value of the job description object to the file
		handle specified in the argument list.
              </p></dd><dt><span class="term"><a name="ID-8e9378d37c657b780fd10e0023540e33"></a>$description-&gt;<span class="italic">parameter</span>()</span></dt><dd><p>
		For any parameter defined in the JobDescription can be
		accessed by calling the method named by the parameter. The
		method names are automatically created when the
		JobDescription is created, and may be invoked with
		arbitrary SillyCaps or underscores. That is, the parameter
		gram_myjob may be accessed by the GramMyJob, grammyjob, or
		gram_my_job method names (and others).
              </p><p>
		If the attributes does not in this object, then undef will
		be returned.
              </p><p>
		In a list context, this returns the list of values
		associated with an attribute.
              </p><p>
		In a scalar context, if the attribute's value consist of a
		single literal, then that literal will be returned,
		otherwise undef will be returned.
              </p><p>
		For example, from a JobDescription called $d constructed
		from a description file containing
              </p><pre class="screen">{
    executable =&gt; [ '/bin/echo' ],
    arguments  =&gt; [ 'hello', 'world' ]
}</pre><p>
		The following will hold:
              </p><pre class="screen">$executable = $d-&gt;executable()    # '/bin/echo'
$arguments = $d-&gt;arguments()      # undef
@executable = $d-&gt;executable()    # ('/bin/echo')
@arguments = $d-&gt;arguments()      # ('hello', 'world')
$not_present = $d-&gt;not_present()  # undef
@not_present = $d-&gt;not_present()  # ()</pre><p>
		To test for existence of a value:
              </p><pre class="screen">@not_present = $d-&gt;not_present()
print "Not defined\n" if(!defined($not_present[0]));</pre></dd></dl></div><p>
      </p></div></div></div><div class="refentry"><a name="Globus::GRAM::JobManager"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>Globus::GRAM::JobManager &#8212; Base class for all Job Manager scripts</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="synopsis">$manager = new Globus::GRAM::JobManager($job_description);</pre><pre class="synopsis">$manager-&gt;log("Starting new operation");
$manager-&gt;nfssync($fileobj,$createflag);
$manager-&gt;respond($hashref);
$hashref = $manager-&gt;submit();
$hashref = $manager-&gt;poll();
$hashref = $manager-&gt;cancel();
$hashref = $manager-&gt;signal();
$hashref = $manager-&gt;make_scratchdir();
$hashref = $manager-&gt;remove_scratchdir();
$hashref = $manager-&gt;rewrite_urls();
$hashref = $manager-&gt;stage_in();
$hashref = $manager-&gt;stage_out();
$hashref = $manager-&gt;cache_cleanup();
$hashref = $manager-&gt;remote_io_file_create();
$hashref = $manager-&gt;proxy_relocate();
$hashref = $manager-&gt;proxy_update();
$scalar  = $manager-&gt;pipe_out_cmd(@arglist);
($stderr, $rc) = $manager-&gt;pipe_err_cmd(@arglist);
$status  = $manager-&gt;fork_and_exec_cmd(@arglist);
$manager-&gt;append_path($hash, $variable, $path);
$scalar = $manager-&gt;setup_softenv();</pre></div><div class="refsection"><a name="ID-e96f19759006b55f2a0d9c05142531b8"></a><h2>DESCRIPTION</h2><p>
      The Globus::GRAM::JobManager module implements the base behavior for
      a Job Manager script interface. Scheduler-specific job manager
      scripts must inherit from this module in order to be used by the job
      manager.
    </p><div class="refsection"><a name="ID-68252c34977081809bd73a304acda1f6"></a><h3>Methods</h3><p>
        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><a name="ID-f1a4bd07a91c2437a872f22bef743a61"></a>$manager = Globus::GRAM::JobManager-&gt;new($JobDescription)</span></dt><dd><p>
		Each Globus::GRAM::JobManager object is created by calling
		the constructor with a single argument, a
		Globus::GRAM::JobDescription object containing the
		information about the job request which the script will be
		modifying. Modules which subclass Globus::GRAM::JobManager
		MUST call the super-class's constructor, as in this code
		fragment:
              </p><pre class="screen">my $proto = shift;
my $class = ref($proto) || $proto;
my $self = $class-&gt;SUPER::new(@_);

bless $self, $class;</pre></dd><dt><span class="term"><a name="ID-5661a979efb43cfbf221c511a6dbfc34"></a>$manager-&gt;log($string)</span></dt><dd><p>
		Log a message to the job manager log file. The message is
		preceded by a timestamp.
              </p></dd><dt><span class="term"><a name="ID-9776ef1009a8a80280bb9c3b7e663582"></a>$manager-&gt;nfssync($object,$create)</span></dt><dd><p>
		Send an NFS update by touching the file (or directory) in
		question. If the $create is true, a file will be created.
		If it is false, the $object will not be created.
              </p></dd><dt><span class="term"><a name="ID-00e1765fdce34a7ea59d2e1c3272563d"></a>$manager-&gt;respond($message)</span></dt><dd><p>
		Send a response to the job manager program. The response
		may either be a hash reference consisting of a hash of
		(variable, value) pairs, which will be returned to the job
		manager, or an already formatted string. This only needs to
		be directly called by a job manager implementation when the
		script wants to send a partial response while processing
		one of the scheduler interface methods (for example, to
		indicate that a file has been staged).
              </p><p>
		The valid keys for a response are defined in the RESPONSES
		section.
              </p></dd><dt><span class="term"><a name="ID-153f150e87f8248d358d9354b7bd8c94"></a>$manager-&gt;submit()</span></dt><dd><p>
		Submit a job request to the scheduler. The default
		implementation returns with the
		Globus::GRAM::Error::UNIMPLEMENTED error. Scheduler
		specific subclasses should reimplement this method to
		submit the job to the scheduler.
              </p><p>
		A scheduler which implements this method should return a
		hash reference containing a scheduler-specific job
		identifier as the value of the hash's JOB_ID key, and
		optionally, the a GRAM job state as the value of the hash's
		JOB_STATE key if the job submission was successful;
		otherwise a Globus::GRAM::Error value should be returned.
		The job state values are defined in the
		Globus::GRAM::JobState module. The job parameters (as found
		in the job rsl) are defined in Globus::GRAM::Jobdescription
		object in $self-&gt;{JobDescription}.
              </p><p>
		For example:
              </p><pre class="screen">return {JOB_STATE =&gt; Globus::GRAM::JobState::PENDING,
        JOB_ID =&gt; $job_id};</pre></dd><dt><span class="term"><a name="ID-c5f57900a40e9e419144bb602a2c944d"></a>$manager-&gt;poll()</span></dt><dd><p>
		Poll a job's status. The default implementation returns
		with the Globus::GRAM::Error::UNIMPLEMENTED error.
		Scheduler specific subclasses should reimplement this
		method to poll the scheduler.
              </p><p>
		A scheduler which implements this method should return a
		hash reference containing the JOB_STATE value. The job's ID
		can be accessed by calling the
		$self-&gt;{JobDescription}-&gt;jobid() method.
              </p></dd><dt><span class="term"><a name="ID-4a349cc3019364a76106f3f051e90751"></a>$manager-&gt;cancel()</span></dt><dd><p>
		Cancel a job. The default implementation returns with the
		Globus::GRAM::Error::UNIMPLEMENTED error. Scheduler
		specific subclasses should reimplement this method to
		remove the job from the scheduler.
              </p><p>
		A scheduler which implements this method should return a
		hash reference containing the JOB_STATE value. The job's ID
		can be accessed by calling the
		$self-&gt;{JobDescription}-&gt;jobid() method.
              </p></dd><dt><span class="term"><a name="ID-a3cb8b8490de619f9595436eb937ce91"></a>$manager-&gt;signal()</span></dt><dd><p>
		Signal a job. The default implementation returns with the
		Globus::GRAM::Error::UNIMPLEMENTED error. Scheduler
		specific subclasses should reimplement this method to
		remove the job from the scheduler. The JobManager module
		can determine the job's ID, the signal number, and the
		(optional) signal arguments from the Job Description by
		calling it's job_id(), signal(), and and signal_arg()
		methods, respectively.
              </p><p>
		Depending on the signal, it may be appropriate for the
		JobManager object to return a hash reference containing a
		JOB_STATE update.
              </p></dd><dt><span class="term"><a name="ID-3e9f3b20104272b031385f09961fc4f5"></a>$manager-&gt;make_scratchdir()</span></dt><dd><p>
		Create a scratch directory for a job. The scratch directory
		location is based on the JobDescription's
		scratch_dir_base() and scratch_dir() methods.
              </p><p>
		If the scratch_dir() value is a relative path, then a
		directory will be created as a subdirectory of
		scratch_dir_base()/scratch_dir(), otherwise, it will be
		created as a subdirectory of scratch_dir().  This method
		will return a hash reference containing mapping SCRATCH_DIR
		to the absolute path of newly created scratch directory if
		successful.
              </p></dd><dt><span class="term"><a name="ID-de07007fccf276770e60e3e268b83e7f"></a>$manager-&gt;remove_scratchdir()</span></dt><dd><p>
		Delete a job's scratch directory. All files and
		subdirectories of the JobDescription's scratch_directory()
		will be deleted.
              </p></dd><dt><span class="term"><a name="ID-4159d9ea9a5431081d5fbcb295ddf46f"></a>$manager-&gt;file_cleanup()</span></dt><dd><p>
		Delete some job-related files. All files listed in the
		JobDescription's file_cleanup() array will be deleted.
              </p></dd><dt><span class="term"><a name="ID-dad2ce58b4c3b28536074d909bb447d3"></a>$manager-&gt;rewrite_urls()</span></dt><dd><p>
		Looks up URLs listed in the JobDescription's stdin() and
		executable(), and replaces them with paths to locally
		cached copies.
              </p></dd><dt><span class="term"><a name="ID-768d39610a5dac33f97323cd0a4da486"></a>$manager-&gt;stage_in()</span></dt><dd><p>
		Stage input files need for the job from remote storage. The
		files to be staged are defined by the array of [URL, path]
		pairs in the job description's file_stage_in() and
		file_stage_in_shared() methods. The
		Globus::GRAM::JobManager module provides an implementation
		of this functionality using the globus-url-copy and
		globus-gass-cache programs. Files which are staged in are
		not automatically removed when the job terminates.
              </p><p>
		This function returns intermediate responses using the
		Globus::GRAM::JobManager::response() method to let the job
		manager know when each individual file has been staged.
              </p></dd><dt><span class="term"><a name="ID-119cb24a5ad939da51c222f4432c7683"></a>$manager-&gt;stage_out()</span></dt><dd><p>
		Stage output files generated by this job to remote storage.
		The files to be staged are defined by the array of [URL,
		destination] pairs in the job description's
		file_stage_out() method. The Globus::GRAM::JobManager
		module provides an implementation of this functionality
		using the globus-url-copy program.  Files which are staged
		out are not removed by this method.
              </p></dd><dt><span class="term"><a name="ID-7815404153c9b6c7bcd8d13d31aaa08e"></a>$manager-&gt;cache_cleanup()</span></dt><dd><p>
		Clean up cache references in the GASS which match this
		job's cache tag .
              </p></dd><dt><span class="term"><a name="ID-03ece962c4144c053cc4ee0347af745c"></a>$manager-&gt;remote_io_file_create()</span></dt><dd><p>
		Create the remote I/O file in the job dir which will
		contain the remote_io_url RSL attribute's value.
              </p></dd><dt><span class="term"><a name="ID-d7633d4adbf1c137bd170b41fd310fe8"></a>$manager-&gt;proxy_relocate()</span></dt><dd><p>
		Relocate the delegated proxy for job execution. Job
		Managers need to override the default if they intend to
		relocate the proxy into some common file system other than
		the cache. The job manager program does not depend on the
		new location of the proxy. Job Manager modules must not
		remove the default proxy.
              </p></dd><dt><span class="term"><a name="ID-6a2bc7731ef59a20927a785ba55bc1e6"></a>$hashref = $manager-&gt;proxy_update();</span></dt><dd><p></p></dd><dt><span class="term"><a name="ID-cda37eb31e0d9d121dbb66a282b134f1"></a>$manager-&gt;append_path($ref, $var, $path)</span></dt><dd><p>
		Append $path to the value of $ref-&gt;{$var}, dealing with
		the case where $ref-&gt;{$var} is not yet defined.
              </p></dd><dt><span class="term"><a name="ID-d0833062becb06e55fbbb13a3874ed1f"></a>$manager-&gt;pipe_out_cmd(@arg)</span></dt><dd><p>
		Create a new process to run the first argument application
		with the remaining arguments (which may be empty). No shell
		metacharacter will be evaluated, avoiding a shell
		invocation. Stderr is redirected to /dev/null and stdout is
		being captured by the parent process, which is also the
		result returned.  In list mode, all lines are returned, in
		scalar mode, only the first line is being returned. The
		line termination character is already cut off. Use this
		function as more efficient backticks, if you do not need
		shell metacharacter evaluation.
              </p><p>
		Caution: This function deviates in two manners from regular
		backticks. Firstly, it chomps the line terminator from the
		output. Secondly, it returns only the first line in scalar
		context instead of a multiline concatinated string. As with
		regular backticks, the result may be undefined in scalar
		context, if no result exists.
              </p><p>
		A child error code with an exit code of 127 indicates that
		the application could not be run. The scalar result
		returned by this function is usually undef'ed in this case.
              </p></dd><dt><span class="term"><a name="ID-0153f5589caafb644c3720b192410153"></a>($stder, $rc) = $manager-&gt;pipe_err_cmd(@arg)</span></dt><dd><p>
		Create a new process to run the first argument application
		with the remaining arguments (which may be empty). No shell
		metacharacter will be evaluated, avoiding a shell
		invocation.
              </p><p>
		This method returns a list of two items, the standard error
		of the program, and the exit code of the program.  If the
		error code is 127, then the application could not be run. 
		Standard output is discarded.
              </p></dd><dt><span class="term"><a name="ID-a8a41d1993a179ebd64c6835f2abdfd2"></a>$manager-&gt;fork_and_exec_cmd(@arg)</span></dt><dd><p>
		Fork off a child to run the first argument in the list.
		Remaining arguments will be passed, but shell interpolation
		is avoided. Signals SIGINT and SIGQUIT are ignored in the
		child process. Stdout is appended to /dev/null, and stderr
		is dup2 from stdout. The parent waits for the child to
		finish, and returns the value for the CHILD_ERROR variable
		as result. Use this function as more efficient system()
		call, if you can do not need shell metacharacter
		evaluation.
              </p><p>
		Note that the inability to execute the program will result
		in a status code of 127.
              </p></dd><dt><span class="term"><a name="ID-32c38475691eb00c5e8c6a62552cd978"></a>$manager-&gt;job_dir()</span></dt><dd><p>
		Return the temporary directory to store job-related files,
		which have no need for file caching.
              </p></dd><dt><span class="term"><a name="ID-ab6ca04c6b90775f97ceb83837a62f07"></a>$manager-&gt;setup_softenv()</span></dt><dd><p>
		Either add a line to the specified command script file
		handle to load the user's default SoftEnv configuration, or
		create a custom SoftEnv script and add commands to the
		specified command script file handle to load it.
              </p></dd></dl></div><p>
      </p></div></div><div class="refsection"><a name="ID-bcb5fd9dba9a920db0007cc56619dab1"></a><h2>RESPONSES</h2><p>
      When returning from a job interface method, or when sending an
      intermediate response via the <span class="italic">response</span>() method, the following hash keys
      are valid:
    </p><p>
      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><a name="ID-16358532f63dae6e705b970cda79f8f6"></a>* JOB_STATE</span></dt><dd><p>
	      An integer job state value. These are enumerated in the
	      Globus::GRAM::JobState module.
            </p></dd><dt><span class="term"><a name="ID-692f8c03eebeb01d83454e2fb7c0eabc"></a>* ERROR</span></dt><dd><p>
	      An integer error code. These are enumerated in the
	      Globus::GRAM::Error module.
            </p></dd><dt><span class="term"><a name="ID-5c48854cbbf2aabcad2ba36b91b93bc0"></a>* JOB_ID</span></dt><dd><p>
	      A string containing a job identifier, which can be used to
	      poll, cancel, or signal a job in progress. This response
	      should only be returned by the <span class="italic">submit</span> method.
            </p></dd><dt><span class="term"><a name="ID-4d7fe40cdacdc6b615d6c152578652fe"></a>* SCRATCH_DIR</span></dt><dd><p>
	      A string containing the path to a newly-created scratch
	      directory. This response should only be returned by the
	      <span class="italic">make_scratchdir</span> method.
            </p></dd><dt><span class="term"><a name="ID-9034b7c1f844652f4877ae9996a5a8db"></a>* STAGED_IN</span></dt><dd><p>
	      A string containing the (URL, path) pair for a file which has
	      now been staged in. This response should only be returned by
	      the <span class="italic">stage_in</span> method.
            </p></dd><dt><span class="term"><a name="ID-57fbff256acaaf1077c6f2caafbd1210"></a>* STAGED_IN_SHARED</span></dt><dd><p>
	      A string containing the (URL, path) pair for a file which has
	      now been staged in and symlinked from the cache. This
	      response should only be returned by the <span class="italic">stage_in_shared</span> method.
            </p></dd><dt><span class="term"><a name="ID-579b4aa8913a426b3f984875f648ae33"></a>* STAGED_OUT</span></dt><dd><p>
	      A string containing the (path, URL) pair for a file which has
	      now been staged out by the script. This response should only
	      be returned by the <span class="italic">stage_out</span> method.
            </p></dd></dl></div><p>
    </p></div></div><div class="refentry"><a name="Globus::GRAM::JobSignal"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>Globus::GRAM::JobSignal &#8212; GRAM Protocol JobSignal Constants</p></div><div class="refsection"><a name="ID-dde2a5ed0f147b3205232afefdde1cf6"></a><h2>DESCRIPTION</h2><p>
      The Globus::GRAM::JobSignal module defines symbolic names for the
      JobSignal constants in the GRAM Protocol.
    </p><pre class="screen"></pre><div class="refsection"><a name="ID-0b9db17dce2bf5bf77e6e0e93adbbea3"></a><h3>Methods</h3><div class="blockquote"><blockquote class="blockquote"><pre class="screen"></pre></blockquote></div><p>
        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><a name="ID-1d401a21f4d448cacc01de3675c3785d"></a>$value = Globus::GRAM::CANCEL()</span></dt><dd><p>
		Return the value of the CANCEL constant.
              </p></dd><dt><span class="term"><a name="ID-405fd293449f3d57498fcd767764fc28"></a>$value = Globus::GRAM::SUSPEND()</span></dt><dd><p>
		Return the value of the SUSPEND constant.
              </p></dd><dt><span class="term"><a name="ID-fa72f66c3836288a64214f4d0de37384"></a>$value = Globus::GRAM::RESUME()</span></dt><dd><p>
		Return the value of the RESUME constant.
              </p></dd><dt><span class="term"><a name="ID-8a382f7300403f5a0784775266438580"></a>$value = Globus::GRAM::PRIORITY()</span></dt><dd><p>
		Return the value of the PRIORITY constant.
              </p></dd><dt><span class="term"><a name="ID-54d8953c67be0dde617ae497bf80d8be"></a>$value = Globus::GRAM::COMMIT_REQUEST()</span></dt><dd><p>
		Return the value of the COMMIT_REQUEST constant.
              </p></dd><dt><span class="term"><a name="ID-1b06815caa94a555b49a11656ec0bb42"></a>$value = Globus::GRAM::COMMIT_EXTEND()</span></dt><dd><p>
		Return the value of the COMMIT_EXTEND constant.
              </p></dd><dt><span class="term"><a name="ID-2e6a5f636aee316104ffbbacd222c109"></a>$value = Globus::GRAM::STDIO_UPDATE()</span></dt><dd><p>
		Return the value of the STDIO_UPDATE constant.
              </p></dd><dt><span class="term"><a name="ID-46515555974510bd72b7013b5d264d66"></a>$value = Globus::GRAM::STDIO_SIZE()</span></dt><dd><p>
		Return the value of the STDIO_SIZE constant.
              </p></dd><dt><span class="term"><a name="ID-c211f62d6bb9d806ac873b4a1b6d1dfe"></a>$value = Globus::GRAM::STOP_MANAGER()</span></dt><dd><p>
		Return the value of the STOP_MANAGER constant.
              </p></dd><dt><span class="term"><a name="ID-78c31f0d13b3ec879c463dd482de0ed7"></a>$value = Globus::GRAM::COMMIT_END()</span></dt><dd><p>
		Return the value of the COMMIT_END constant.
              </p></dd></dl></div><p>
      </p></div></div></div><div class="refentry"><a name="Globus::GRAM::JobState"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>Globus::GRAM::JobState &#8212; GRAM Protocol JobState Constants</p></div><div class="refsection"><a name="ID-419977e2b3d9757b513072e147336574"></a><h2>DESCRIPTION</h2><p>
      The Globus::GRAM::JobState module defines symbolic names for the
      JobState constants in the GRAM Protocol.
    </p><pre class="screen"></pre><div class="refsection"><a name="ID-578427db2c7ceece9803b48cb0e9fe8c"></a><h3>Methods</h3><div class="blockquote"><blockquote class="blockquote"><pre class="screen"></pre></blockquote></div><p>
        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><a name="ID-09c82129e4107a7a92b1dab7b96b1309"></a>$value = Globus::GRAM::PENDING()</span></dt><dd><p>
		Return the value of the PENDING constant.
              </p></dd><dt><span class="term"><a name="ID-5c760c5745c4362d7df0b4c568f13284"></a>$value = Globus::GRAM::ACTIVE()</span></dt><dd><p>
		Return the value of the ACTIVE constant.
              </p></dd><dt><span class="term"><a name="ID-d82924c761ac0c80cdb854957656c35f"></a>$value = Globus::GRAM::FAILED()</span></dt><dd><p>
		Return the value of the FAILED constant.
              </p></dd><dt><span class="term"><a name="ID-94cde18e19f1df771f3c19c37dfa33ea"></a>$value = Globus::GRAM::DONE()</span></dt><dd><p>
		Return the value of the DONE constant.
              </p></dd><dt><span class="term"><a name="ID-44d955e5aa1e3bbcec8e1f5bafdd28fa"></a>$value = Globus::GRAM::SUSPENDED()</span></dt><dd><p>
		Return the value of the SUSPENDED constant.
              </p></dd><dt><span class="term"><a name="ID-7981de690ec9d003b55618517a57e8a4"></a>$value = Globus::GRAM::UNSUBMITTED()</span></dt><dd><p>
		Return the value of the UNSUBMITTED constant.
              </p></dd><dt><span class="term"><a name="ID-58ac70a2cd6a36f8c1da219122a3d4c1"></a>$value = Globus::GRAM::STAGE_IN()</span></dt><dd><p>
		Return the value of the STAGE_IN constant.
              </p></dd><dt><span class="term"><a name="ID-bcd56bc6a81178e512d0665f12cc79c5"></a>$value = Globus::GRAM::STAGE_OUT()</span></dt><dd><p>
		Return the value of the STAGE_OUT constant.
              </p></dd><dt><span class="term"><a name="ID-d4646a745b7f5ab0beb237d37ed5035b"></a>$value = Globus::GRAM::ALL()</span></dt><dd><p>
		Return the value of the ALL constant.
              </p></dd></dl></div><p>
      </p></div></div></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-rsl"></a>Chapter 7. RSL Specification v1.1</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#gram5-rsl-syntax-overview">1. RSL Syntax Overview</a></span></dt><dt><span class="section"><a href="#gram5-rsl-tokenization-overview">2. RSL Tokenization Overview</a></span></dt><dt><span class="section"><a href="#gram5-rsl-substitution-semantics">3. RSL Substitution Semantics</a></span></dt><dt><span class="section"><a href="#gram5-rsl-attribute-summary">4. RSL Attribute Summary</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#idm136312716704">rsl</a></span><span class="refpurpose"> &#8212; GRAM5 RSL Attributes</span></dt></dl></dd><dt><span class="section"><a href="#gram5-rsl-examples">5. Simple RSL Examples</a></span></dt><dt><span class="section"><a href="#gram5-rsl-grammar-and-tokenization-rules">6. RSL grammar and tokenization rules</a></span></dt></dl></div><p>This is a document to specify the existing RSL v1.0 implementation
    and interfaces, as they are provided in
    the GT 6.0 release. This
    document serves as a reference, and more introductory
    text.</p><p>The Globus Resource
    Specification Language (RSL) provides a common interchange language to
    describe resources.  The various components of the Globus Resource
    Management architecture manipulate RSL strings to perform their management
    functions in cooperation with the other components in the system. The RSL
    provides the skeletal syntax used to compose complicated resource
    descriptions, and the various resource management components introduce
    specific
    <em class="replaceable"><code>ATTRIBUTE</code></em>,<em class="replaceable"><code>VALUE</code></em>&gt;
    pairings into this common structure. Each attribute in a resource
    description serves as a parameter to control the behavior of one or more
    components in the resource management
    system.
    </p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-rsl-syntax-overview"></a>1. RSL Syntax Overview</h2></div></div></div><p>
    The core syntax of the RSL syntax is the <span class="emphasis"><em>relation</em></span>.
    Relations associate an attribute name with a value, eg the relation
    <code class="literal">executable=a.out</code> provides the name of an executable in a
    resource request. There are two generative syntactic structures
    in the RSL that are used to build more complicated resource descriptions
    out of the basic relations: <span class="emphasis"><em>compound requests</em></span> and
    <span class="emphasis"><em>value sequences</em></span>. In addition, the RSL
    syntax includes a facility to both introduce and dereference string
    <span class="emphasis"><em>substitution variables</em></span>.
    </p><p>The simplest form of compound request, utilized by all resource
    management components, is the conjunct-request. The conjuct-request
    expresses a conjunction of simple relations or compound requests (like a
    boolean AND). The most common conjunct-request in Globus RSL strings is the
    combination of multiple relations such as executable name, node count,
    executable arguments, and output files for a basic GRAM job request.
    Similarly, the core RSL syntax includes a disjunct-request form to
    represent disjunctive relations (like a boolean OR). Currently, however, no
    resource management component utilizes the disjunct-request form.
    </p><p>The last form of compound request is the multi-request.
    The multi-request expresses multiple parallel resources that
    make up a resource description. The multi-request form differs
    from the conjunction and disjunction in two ways: multi-requests introduce
    new variable scope, meaning variables defined in one clause of a
    multi-request are not visible to the other clauses, and multi-requests
    introduce a non-reducible hierarchy to the resource
    description. Whereas relations within a conjunct-request can be thought of
    as <span class="emphasis"><em>constraints</em></span> on the resource being described, the
    subclauses of a
    multi-request are best thought of as individual resource descriptions that
    together constitute an abstract
    resource collection; the same attributes may be
    <span class="emphasis"><em>constrained</em></span> in different ways in each
    subclause without causing a logical contradiction. An example of a
    contradiction would be to constrain the <code class="literal">executable</code>
    attribute to be two conflicting values within a conjunction. Currently,
    however, no resource management component utilizes the disjunct-request
    form.
    </p><p>The simplest form of value in the RSL syntax is the string literal.
    When explicitly quoted, literals can contain any character, and many common
    literals that don't contain special characters can appear without quotes.
    Values can also be variable references, in which case the variable
    reference is in essence <span class="emphasis"><em>replaced</em></span> with the string
    value defined for that variable. RSL descriptions can also express
    string-concatenation of values, especially useful to construct long strings
    out of several variable references.  String concatenation is supported with
    both an explicit concatenation operator and implicit concatenation for many
    idiomatic constructions involving variable references and literals.
    </p><p>In addition to the simple value forms given above, the RSL syntax
    includes the value sequence to express ordered sets of values. The value
    sequence syntax is used primarily for defining variables and for providing
    the argument list for a program.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-rsl-tokenization-overview"></a>2. RSL Tokenization Overview</h2></div></div></div><p> Each RSL string consists of a sequence of RSL tokens, whitespace,
    and comments. The RSL tokens are either special syntax or regular unquoted
    literals, where special syntax contains one or more of the following listed
    special characters and unquoted literals are made of sequences of
    characters excluding the special characters.
    </p><p>The complete set of special characters that cannot appear as part of
    an unquoted literal is:
    
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">+</code> (plus)</li><li class="listitem"><code class="literal">&amp;</code> (ampersand)</li><li class="listitem"><code class="literal">|</code> (pipe)</li><li class="listitem"><code class="literal">(</code>(left paren)</li><li class="listitem"><code class="literal">)</code> (right paren)</li><li class="listitem"><code class="literal">=</code> (equal)</li><li class="listitem"><code class="literal">&lt;</code> (left angle)</li><li class="listitem"><code class="literal">&gt;</code> (right angle)</li><li class="listitem"><code class="literal">!</code> (exclamation)</li><li class="listitem"><code class="literal">"</code> (double quote)</li><li class="listitem"><code class="literal">'</code> (apostrophe)</li><li class="listitem"><code class="literal">^</code> (carat)</li><li class="listitem"><code class="literal">#</code> (pound)</li><li class="listitem"><code class="literal">$</code> (dollar)</li></ul></div><p>
    
    These characters can only be used for the special syntactic forms described
    in the section and in the
    section or as within quoted literals.
    </p><p>Quoted literals are introduced with the <code class="literal">"</code>
    (double quote) or <code class="literal">'</code> (single quote/apostrophe)
    and consist of all the characters up to (but not including) the next solo
    double or single quote, respectively. To escape a quote character within a
    quoted literal, the appearance of the quote character twice in a row is
    converted to a single instance of the character and the literal continues
    until the next solo quote character. For any quoted literal, there is only
    one possible escape sequence, eg within a literal delimited by the single
    quote character only the single quote character uses the escape notation
    and the double quote character can appear without escape.

    </p><p>Quoted literals can also be introduced with an alternate
    <span class="emphasis"><em>user delimiter</em></span> notation. User delimited literals are
    introduced with the <code class="literal">^</code> (carat) character followed
    immediately by a user-provided delimiter; the literal consists of all
    the characters after the user's delimiter up to (but not including) the
    next solo instance of the delimiter. The delimiter itself may be escaped
    within the literal by providing two instances in a row, just as the regular
    quote delimiters are escaped in regular quoted literals.
    </p><p>
    RSL string comments use a notation similar to comments in the C programming
    language.  Comments are introduced by the prefix <code class="literal">(*</code>.
    Comments continue to the first
    terminating suffix <code class="literal">*)</code> and cannot be nested. Comments are
    stripped from the RSL string during processing and are syntactically
    equivalent to whitespace.
    </p><div class="example"><a name="idm136312731008"></a><p class="title"><b>Example 7.1. Quoted Literal Examples</b></p><div class="example-contents"><p>Assign the value <code class="literal">Hello. Welcome to "The Grid"</code> to
    the attribute <code class="literal">arguments</code>, using double-quote as the
    delimiter and the escaping sequence.
    </p><pre class="programlisting">arguments = "Hello. Welcome to ""The Grid"""</pre><p>
    </p><p>Assign the value <code class="literal">Hello. Welcome to "The Grid"</code> to
    the attribute <code class="literal">arguments</code> using the single-quote delimiter.
    </p><pre class="programlisting">arguments = 'Hello. Welcome to "The Grid'</pre><p>
    </p><p>Assign the value <code class="literal">Hello. Welcome to "The Grid"</code> to
    the attribute <code class="literal">arguments</code> using a user-defined quoting
    character <code class="literal">!</code>.
    </p><pre class="programlisting">arguments = ^!Hello. Welcome to "The Grid"!</pre><p>
    </p></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-rsl-substitution-semantics"></a>3. RSL Substitution Semantics</h2></div></div></div><p>RSL strings can introduce and reference string variables. String
    substitution variables are defined in a special relation using the
    <code class="literal">rsl_substitution</code> attribute, and the definitions affect
    variable references made in the same conjunct-request (or
    disjunct-request), as well as references made within any multi-request
    nested inside one of the clauses of the conjunction (or disjunction). Each
    multi-request introduces a new variable scope for each subrequest, and
    variable definitions do not escape the closest enclosing scope.
    </p><p>Within any given scope, variable definitions are processed
    left-to-right in the resource description. Outermost scopes are processed
    before inner scopes, and the definitions in inner scopes augment the
    inherited definitions with new and/or updated variable definitions.
    </p><p>Variable definitions and variable references are processed in a
    single pass, with each definition updating the
    <span class="emphasis"><em>environment</em></span> prior to processing the next definition.
    The value provided in a variable definition may include a reference to a
    previously-defined variable. References to variables that are not yet
    provided with definitions in the standard RSL variable processing order are
    replaced with an empty literal string.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-rsl-attribute-summary"></a>4. RSL Attribute Summary</h2></div></div></div><p>The RSL syntax is extensible because it defines structure without too
    many keywords.  Each Globus resource management component introduces
    additional attributes to the set recognized by RSL-aware components, so it
    is difficult to provide a complete listing of attributes which might appear
    in a resource description. Resource management components are designed to
    utilize attributes they recognize and pass unrecongnized relations through
    unchanged. This allows powerful compositions of different resource
    management functions.
    </p><p>The following listing summarizes the attribute names utilized by
    existing resource management components in the standard Globus release.
    Please see the individual component documentation for discussion of the
    attribute semantics.</p><div class="refentry"><a name="idm136312716704"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>rsl &#8212; GRAM5 RSL Attributes</p></div><div class="refsect1"><a name="idm136312713632"></a><h2>Description</h2><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">arguments</code></span></dt><dd>The command line arguments for the executable. Use quotes, if a space is required in a single argument.</dd><dt><span class="term"><code class="literal">count</code></span></dt><dd>The number of executions of the executable. [Default: <code class="literal">1</code>]</dd><dt><span class="term"><code class="literal">directory</code></span></dt><dd>Specifies the path of the directory the jobmanager will use as the default directory for the requested job. [Default: <code class="literal">$(HOME)</code>]</dd><dt><span class="term"><code class="literal">dry_run</code></span></dt><dd>If dryrun = yes then the jobmanager will not submit the job for execution and will return success. [Default: <code class="literal">no</code>]</dd><dt><span class="term"><code class="literal">environment</code></span></dt><dd>The environment variables that will be defined for the executable in addition to default set that is given to the job by the jobmanager.</dd><dt><span class="term"><code class="literal">executable</code></span></dt><dd>The name of the executable file to run on the remote machine. If the value is a GASS URL, the file is transferred to the remote gass cache before executing the job and removed after the job has terminated.</dd><dt><span class="term"><code class="literal">expiration</code></span></dt><dd>Time (in seconds) after a a job fails to receive a two-phase commit end signal before it is cleaned up. [Default: <code class="literal">14400</code>]</dd><dt><span class="term"><code class="literal">file_clean_up</code></span></dt><dd>Specifies a list of files which will be removed after the job is completed.</dd><dt><span class="term"><code class="literal">file_stage_in</code></span></dt><dd>Specifies a list of ("remote URL" "local file") pairs which indicate files to be staged to the nodes which will run the job.</dd><dt><span class="term"><code class="literal">file_stage_in_shared</code></span></dt><dd>Specifies a list of ("remote URL" "local file") pairs which indicate files to be staged into the cache. A symlink from the cache to the "local file" path will be made.</dd><dt><span class="term"><code class="literal">file_stage_out</code></span></dt><dd>Specifies a list of ("local file" "remote URL") pairs which indicate files to be staged from the job to a GASS-compatible file server.</dd><dt><span class="term"><code class="literal">gass_cache</code></span></dt><dd>Specifies location to override the GASS cache location.</dd><dt><span class="term"><code class="literal">gram_my_job</code></span></dt><dd>Obsolete and ignored. [Default: <code class="literal">collective</code>]</dd><dt><span class="term"><code class="literal">host_count</code></span></dt><dd>Only applies to clusters of SMP computers, such as newer IBM SP systems. Defines the number of nodes ("pizza boxes") to distribute the "count" processes across.</dd><dt><span class="term"><code class="literal">job_type</code></span></dt><dd>This specifies how the jobmanager should start the job. Possible values are single (even if the count &gt; 1, only start 1 process or thread), multiple (start count processes or threads), mpi (use the appropriate method (e.g. mpirun) to start a program compiled with a vendor-provided MPI library. Program is started with count nodes), and condor (starts condor jobs in the "condor" universe.) [Default: <code class="literal">multiple</code>]</dd><dt><span class="term"><code class="literal">library_path</code></span></dt><dd>Specifies a list of paths to be appended to the system-specific library path environment variables. [Default: <code class="literal">$(GLOBUS_LOCATION)/lib</code>]</dd><dt><span class="term"><code class="literal">loglevel</code></span></dt><dd>Override the default log level for this job. The value of this attribute consists of a combination of the strings FATAL, ERROR, WARN, INFO, DEBUG, TRACE joined by the | character</dd><dt><span class="term"><code class="literal">logpattern</code></span></dt><dd>Override the default log path pattern for this job. The value of this attribute is a string (potentially containing RSL substitutions) that is evaluated to the path to write the log to. If the resulting string contains the string $(DATE) (or any other RSL substitution), it will be reevaluated at log time.</dd><dt><span class="term"><code class="literal">max_cpu_time</code></span></dt><dd>Explicitly set the maximum cputime for a single execution of the executable. The units is in minutes. The value will go through an atoi() conversion in order to get an integer. If the GRAM scheduler cannot set cputime, then an error will be returned.</dd><dt><span class="term"><code class="literal">max_memory</code></span></dt><dd>Explicitly set the maximum amount of memory for a single execution of the executable. The units is in Megabytes. The value will go through an atoi() conversion in order to get an integer. If the GRAM scheduler cannot set maxMemory, then an error will be returned.</dd><dt><span class="term"><code class="literal">max_time</code></span></dt><dd>The maximum walltime or cputime for a single execution of the executable. Walltime or cputime is selected by the GRAM scheduler being interfaced. The units is in minutes. The value will go through an atoi() conversion in order to get an integer.</dd><dt><span class="term"><code class="literal">max_wall_time</code></span></dt><dd>Explicitly set the maximum walltime for a single execution of the executable. The units is in minutes. The value will go through an atoi() conversion in order to get an integer. If the GRAM scheduler cannot set walltime, then an error will be returned. </dd><dt><span class="term"><code class="literal">min_memory</code></span></dt><dd>Explicitly set the minimum amount of memory for a single execution of the executable. The units is in Megabytes. The value will go through an atoi() conversion in order to get an integer. If the GRAM scheduler cannot set minMemory, then an error will be returned.</dd><dt><span class="term"><code class="literal">project</code></span></dt><dd>Target the job to be allocated to a project account as defined by the scheduler at the defined (remote) resource.</dd><dt><span class="term"><code class="literal">proxy_timeout</code></span></dt><dd>Obsolete and ignored. Now a job-manager-wide setting.</dd><dt><span class="term"><code class="literal">queue</code></span></dt><dd>Target the job to a queue (class) name as defined by the scheduler at the defined (remote) resource.</dd><dt><span class="term"><code class="literal">remote_io_url</code></span></dt><dd>Writes the given value (a URL base string) to a file, and adds the path to that file to the environment throught the GLOBUS_REMOTE_IO_URL environment variable. If this is specified as part of a job restart RSL, the job manager will update the file's contents. This is intended for jobs that want to access files via GASS, but the URL of the GASS server has changed due to a GASS server restart.</dd><dt><span class="term"><code class="literal">restart</code></span></dt><dd>Start a new job manager, but instead of submitting a new job, start managing an existing job. The job manager will search for the job state file created by the original job manager. If it finds the file and successfully reads it, it will become the new manager of the job, sending callbacks on status and streaming stdout/err if appropriate. It will fail if it detects that the old jobmanager is still alive (via a timestamp in the state file). If stdout or stderr was being streamed over the network, new stdout and stderr attributes can be specified in the restart RSL and the jobmanager will stream to the new locations (useful when output is going to a GASS server started by the client that's listening on a dynamic port, and the client was restarted). The new job manager will return a new contact string that should be used to communicate with it. If a jobmanager is restarted multiple times, any of the previous contact strings can be given for the restart attribute.</dd><dt><span class="term"><code class="literal">rsl_substitution</code></span></dt><dd>Specifies a list of values which can be substituted into other rsl attributes' values through the $(SUBSTITUTION) mechanism.</dd><dt><span class="term"><code class="literal">save_state</code></span></dt><dd>Causes the jobmanager to save it's job state information to a persistent file on disk. If the job manager exits or is suspended, the client can later start up a new job manager which can continue monitoring the job.</dd><dt><span class="term"><code class="literal">savejobdescription</code></span></dt><dd>Save a copy of the job description to $HOME [Default: <code class="literal">no</code>]</dd><dt><span class="term"><code class="literal">scratch_dir</code></span></dt><dd>Specifies the location to create a scratch subdirectory in. A SCRATCH_DIRECTORY RSL substitution will be filled with the name of the directory which is created.</dd><dt><span class="term"><code class="literal">stderr</code></span></dt><dd>The name of the remote file to store the standard error from the job. If the value is a GASS URL, the standard error from the job is transferred dynamically during the execution of the job. There are two accepted forms of this value. It can consist of a single destination: stderr = URL, or a sequence of destinations: stderr = (DESTINATION) (DESTINATION). In the latter case, the DESTINATION may itself be a URL or a sequence of an x-gass-cache URL followed by a cache tag. [Default: <code class="literal">/dev/null</code>]</dd><dt><span class="term"><code class="literal">stderr_position</code></span></dt><dd>Specifies where in the file remote standard error streaming should be restarted from. Must be 0.</dd><dt><span class="term"><code class="literal">stdin</code></span></dt><dd>The name of the file to be used as standard input for the executable on the remote machine. If the value is a GASS URL, the file is transferred to the remote gass cache before executing the job and removed after the job has terminated. [Default: <code class="literal">/dev/null</code>]</dd><dt><span class="term"><code class="literal">stdout</code></span></dt><dd>The name of the remote file to store the standard output from the job. If the value is a GASS URL, the standard output from the job is transferred dynamically during the execution of the job. There are two accepted forms of this value. It can consist of a single destination: stdout = URL, or a sequence of destinations: stdout = (DESTINATION) (DESTINATION). In the latter case, the DESTINATION may itself be a URL or a sequence of an x-gass-cache URL followed by a cache tag. [Default: <code class="literal">/dev/null</code>]</dd><dt><span class="term"><code class="literal">stdout_position</code></span></dt><dd>Specifies where in the file remote output streaming should be restarted from. Must be 0.</dd><dt><span class="term"><code class="literal">two_phase</code></span></dt><dd>Use a two-phase commit for job submission and completion. The job manager will respond to the initial job request with a WAITING_FOR_COMMIT error. It will then wait for a signal from the client before doing the actual job submission. The integer supplied is the number of seconds the job manager should wait before timing out. If the job manager times out before receiving the commit signal, or if a client issues a cancel signal, the job manager will clean up the job's files and exit, sending a callback with the job status as GLOBUS_GRAM_PROTOCOL_JOB_STATE_FAILED. After the job manager sends a DONE or FAILED callback, it will wait for a commit signal from the client. If it receives one, it cleans up and exits as usual. If it times out and save_state was enabled, it will leave all of the job's files in place and exit (assuming the client is down and will attempt a job restart later). The timeoutvalue can be extended via a signal. When one of the following errors occurs, the job manager does not delete the job state file when it exits: GLOBUS_GRAM_PROTOCOL_ERROR_COMMIT_TIMED_OUT, GLOBUS_GRAM_PROTOCOL_ERROR_TTL_EXPIRED, GLOBUS_GRAM_PROTOCOL_ERROR_JM_STOPPED, GLOBUS_GRAM_PROTOCOL_ERROR_USER_PROXY_EXPIRED. In these cases, it can not be restarted, so the job manager will not wait for the commit signal after sending the FAILED callback</dd><dt><span class="term"><code class="literal">username</code></span></dt><dd>Verify that the job is running as this user.</dd></dl></div><p>
</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-rsl-examples"></a>5. Simple RSL Examples</h2></div></div></div><p>The following are some simple example RSL strings to illustrate
    idiomatic usage with existing tools and to make concrete some of the more
    interesting cases of tokenization, concatenation, and variable semantics.
    These are meant to illustrate the use of the RSL notation without much
    regard for the specific details of a particular resource management
    component.
    </p><p>Typical GRAM5 resource descriptions contain at least a few relations
    in a conjunction:</p><div class="example"><a name="idm136312774896"></a><p class="title"><b>Example 7.2. GRAM5 Job Request Examples</b></p><div class="example-contents"><p>This example shows a conjunct request containing values that are
    unquoted literals and ordered sequences of a mix of quoted and unquoted
    literals.
    </p><pre class="programlisting">(* this is a comment *)
&amp; (executable = a.out (* &lt;-- that is an unquoted literal *))
  (directory  = /home/nobody )
  (arguments  = arg1 "arg 2")
  (count = 1)</pre><p>
    </p><p>This example demonstrates RSL substitutions, which can be used to
    make sure a string is used consistently multiple times in a
    resource description:
    </p><pre class="programlisting">
&amp; (rsl_substitution  = (TOPDIR  "/home/nobody")
                       (DATADIR $(TOPDIR)"/data")
                       (EXECDIR $(TOPDIR)/bin) )
  (executable = $(EXECDIR)/a.out
        (* ^-- implicit concatenation *))
  (directory  = $(TOPDIR) )
  (arguments  = $(DATADIR)/file1 
        (* ^-- implicit concatenation *)
                $(DATADIR) # /file2
        (* ^-- explicit concatenation *)
                '$(FOO)'            (* &lt;-- a quoted literal *))
  (environment = (DATADIR $(DATADIR)))
  (count = 1)</pre><p>
    </p><p>Performing all variable substitution and removing comments yields an
    equivalent RSL string:
    </p><pre class="programlisting">
&amp; (rsl_substitution  = (TOPDIR "/home/nobody")
                       (DATADIR "/home/nobody/data") 
                       (EXECDIR "/home/nobody/bin") )
  (executable = "/home/nobody/bin/a.out" )
  (directory  = "/home/nobody" )
  (arguments  = "/home/nobody/data/file1"
                "/home/nobody/data/file2"
                "$(FOO)" )
  (environment = (DATADIR "/home/nobody/data"))
  (count = 1)</pre><p>
   </p><p>Note in the above variable-substitution example, the variable
    substitution definitions are not automatically made a part of the job's
    environment.  And explicit <code class="literal">environment</code> attribute must be
    used to add environment variables for the job.  Also note that the third
    value in the arguments clause is not a variable reference but
    only quoted literal that happens to contain one of the special characters.
    </p></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-rsl-grammar-and-tokenization-rules"></a>6. RSL grammar and tokenization rules</h2></div></div></div><p>The following is a modified BNF grammar for the Resource
    Specification Language.  Lexical rules are provided for
    the implicit concatenation sequences in the form of conventional regular
    expressions; for the <span class="emphasis"><em>implicit-concat</em></span> non-terminal
    rules, whitespace is not allowed between juxtaposed non-terminals. Grammar
    comments are provided in square brackets in a column to the right
    of the productions, eg <code class="literal">[comment]</code> to help relate
    productions in the grammar to the terminology used in the above discussion.
    </p><p>Regular expressions are provided for the terminal class
    <code class="literal">string-literal</code> and for RSL comments. These regular
    expression make use of a common inverted character-class notation,
    as popularized by the various <span class="application">lex</span> tools.
    Comments are syntactically equivalent to whitespace and can only appear
    where the comment prefix cannot be mistaken for the trailing part of a
    multi-character unquoted literal.</p><table width="100%" cellpadding="5" bgcolor="#F5DCB3" border="1" class="productionset" summary="EBNF for RSL Grammar"><tr><th align="left" valign="top" class="productionset">RSL Grammar</th></tr><tr><td><table border="0" width="99%" cellpadding="0" bgcolor="#F5DCB3" class="productionset" summary="EBNF productions"><tr><td align="left" valign="top" width="3%">[1]</td><td align="right" valign="top" width="10%"><a name="gram5-rsl.specification"></a>specification</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
            <a href="gram5-rsl.relation">relation</a>
            
            <br>
            | '+'
            <a href="#gram5-rsl.spec-list">spec-list</a>
            
            <br>
            |
            '&amp;' <a href="#gram5-rsl.spec-list">spec-list</a>
            
            <br>
            |
            '|' <a href="#gram5-rsl.spec-list">spec-list</a>
            
          <br>
        </td><td align="left" valign="top" width="30%">/* relation */<br>/* multi-request */<br>/* conjunct-request */<br>/* disjunct-request */<br></td></tr><tr><td align="left" valign="top" width="3%">[2]</td><td align="right" valign="top" width="10%"><a name="gram5-rsl.spec-list"></a>spec-list</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
            '('
            <a href="#gram5-rsl.specification">specification</a>
            ')'
            <a href="#gram5-rsl.spec-list">spec-list</a>
            <br>
            |
            '('
            <a href="#gram5-rsl.specification">specification</a>
            ')'
        </td><td align="left" valign="top" width="30%"> </td></tr><tr><td align="left" valign="top" width="3%">[3]</td><td align="right" valign="top" width="10%"><a name="gram5-rsl.relation"></a>relation</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
            'rsl_substitution'
            '=' 
            <a href="#gram5-rsl.binding-sequence">binding-sequence
            </a>
            
            <br>
            |
            <a href="#gram5-rsl.attribute">attribute</a>
            <a href="#gram5-rsl.op">op</a>
            <a href="#gram5-rsl.value-sequence">value-sequence</a>
            
        </td><td align="left" valign="top" width="30%">/* Substitution variable definition */<br>/* Attribute binding relation */<br></td></tr><tr><td align="left" valign="top" width="3%">[4]</td><td align="right" valign="top" width="10%"><a name="gram5-rsl.binding-sequence"></a>binding-sequence</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
            <a href="#gram5-rsl.binding">binding</a>
            <a href="#gram5-rsl.binding-sequence">binding-sequence</a>
            <br>
            |
            <a href="#gram5-rsl.binding">binding</a>
        </td><td align="left" valign="top" width="30%"> </td></tr><tr><td align="left" valign="top" width="3%">[5]</td><td align="right" valign="top" width="10%"><a name="gram5-rsl.binding"></a>binding</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
            '('
            <a href="#gram5-rsl.string-literal">string-literal</a>
            <a href="#gram5-rsl.simple-value">simple-value</a>
            ')'
            
        </td><td align="left" valign="top" width="30%">/* Substitution variable definition */<br></td></tr><tr><td align="left" valign="top" width="3%">[6]</td><td align="right" valign="top" width="10%"><a name="gram5-rsl.attribute"></a>attribute</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
            <a href="#gram5-rsl.string-literal">string-literal</a>
            
        </td><td align="left" valign="top" width="30%">/* attribute */<br></td></tr><tr><td align="left" valign="top" width="3%">[7]</td><td align="right" valign="top" width="10%"><a name="gram5-rsl.op"></a>op</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">'=' | '!=' | '&gt;' | '&gt;=' | '&lt;' | '&lt;='</td><td align="left" valign="top" width="30%"> </td></tr><tr><td align="left" valign="top" width="3%">[8]</td><td align="right" valign="top" width="10%"><a name="gram5-rsl.value-sequence"></a>value-sequence</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
            <a href="#gram5-rsl.value">value</a>
            <a href="#gram5-rsl.value-sequence">value-sequence</a>
            |
            <a href="#gram5-rsl.value">value</a>
        </td><td align="left" valign="top" width="30%"> </td></tr><tr><td align="left" valign="top" width="3%">[9]</td><td align="right" valign="top" width="10%"><a name="gram5-rsl.value"></a>value</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
            '('
            <a href="#gram5-rsl.value-sequence">value-sequence</a>
            ')' |

            <a href="#gram5-rsl.simple-value">simple-value</a>
        </td><td align="left" valign="top" width="30%"> </td></tr><tr><td align="left" valign="top" width="3%">[10]</td><td align="right" valign="top" width="10%"><a name="gram5-rsl.simple-value"></a>simple-value</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
            <a href="#gram5-rsl.string-literal">string-literal</a>
            
            <br>
            |
            <a href="#gram5-rsl.simple-value">simple-value</a>
            '#'
            <a href="#gram5-rsl.simple-value">simple-value</a>
            
            <br>
            |
            <a href="#gram5-rsl.implicit-concat">implicit-concat</a>
            |
            <a href="#gram5-rsl.variable-reference">variable-reference</a>
        </td><td align="left" valign="top" width="30%">/* String */<br>/* Concatenation */<br></td></tr><tr><td align="left" valign="top" width="3%">[11]</td><td align="right" valign="top" width="10%"><a name="gram5-rsl.variable-reference"></a>variable-reference</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
            '$(' 
            <a href="#gram5-rsl.string-literal">string-literal</a>
            ')'
            
        </td><td align="left" valign="top" width="30%">/* Variable Reference */<br></td></tr><tr><td align="left" valign="top" width="3%">[12]</td><td align="right" valign="top" width="10%"><a name="gram5-rsl.implicit-concat"></a>implicit-concat</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
            (<a href="#gram5-rsl.unquoted-literal">unquoted-literal</a>)?
            (<a href="#gram5-rsl.implicit-concat-core">implicit-concat-core</a>)+
            
        </td><td align="left" valign="top" width="30%">/* Implicit concatenation */<br></td></tr><tr><td align="left" valign="top" width="3%">[13]</td><td align="right" valign="top" width="10%"><a name="gram5-rsl.implicit-concat-core"></a>implicit-concat-core</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
            <a href="#gram5-rsl.variable-reference">variable-reference</a>
            <br>
            |
            (<a href="#gram5-rsl.variable-reference">variable-reference</a>)
            (<a href="#gram5-rsl.unquoted-literal">unquoted-literal</a>)
        </td><td align="left" valign="top" width="30%"> </td></tr><tr><td align="left" valign="top" width="3%">[14]</td><td align="right" valign="top" width="10%"><a name="gram5-rsl.string-literal"></a>string-literal</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
            <a href="#gram5-rsl.quoted-literal">quoted-literal</a>
            <br>
            |
            <a href="#gram5-rsl.unquoted-literal">unquoted-literal</a>
        </td><td align="left" valign="top" width="30%"> </td></tr><tr><td align="left" valign="top" width="3%">[15]</td><td align="right" valign="top" width="10%"><a name="gram5-rsl.quoted-literal"></a>quoted-literal</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">''' (([^']) | (''''))* '''
            
            <br>|
            '"' (([^"]) | ('""')* '"'
            
            <br>|
            '^' c(([^c]|(cc))* c
            
        </td><td align="left" valign="top" width="30%">/* Single-quote delimiter with
            escaping */<br>/* Double-quote delimiter with
            escaping */<br>/* User defined delimiter <em class="replaceable"><code>c</code></em>
            with escaping */<br></td></tr><tr><td align="left" valign="top" width="3%">[16]</td><td align="right" valign="top" width="10%"><a name="gram5-rsl.unquoted-literal"></a>unquoted-literal</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">([^\t\v\n+&amp;|()=&lt;&gt;!"'^#$])+
        
        </td><td align="left" valign="top" width="30%">/* Non-special characters */<br></td></tr><tr><td align="left" valign="top" width="3%">[17]</td><td align="right" valign="top" width="10%"><a name="gram5-rsl.comment"></a>comment</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
            '(*' (([^*])|('*'[^)]))* '*)'
        
        </td><td align="left" valign="top" width="30%">/* Comment */<br></td></tr></table></td></tr></table></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-debugging"></a>Chapter 8. Debugging</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#idm136317281280">1. Basic Debugging Methods</a></span></dt><dt><span class="section"><a href="#idm136339247968">2. Advanced Debugging Methods</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136339246784">2.1. Debugging the Job Manager</a></span></dt></dl></dd></dl></div><a class="indexterm" name="idm136340411856"></a><p>Log output from GRAM5 is a useful tool for debugging issues.
    GRAM5 can log to either local files or syslog. See the
    <a href="../admin/#gram5-troubleshooting-admin" class="olink">Admin
    Guide</a> for information about how to configure logging.</p><p>In most cases, logging at the <code class="literal">INFO</code> level will
    produce enough information to show progress of most operations. Adding
    <code class="literal">DEBUG</code> will also allow log information from the GRAM
    LRM scripts.
    </p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="idm136317281280"></a>1. Basic Debugging Methods</h2></div></div></div><p>
        The first thing to determine when debugging unexpected failures is
        to determine whether the gatekeeper service is running, reachable
        from the client, and properly configured.
        </p><p>
        First, determine that the gatekeeper is running by using a tool such
        as <span class="command"><strong>telnet</strong></span> to connect to the TCP/IP port that the
        gatekeeper is listening on. From the GRAM service node, using a
        default configuration, use a command like:
        </p><pre class="screen"><code class="prompt">% </code><span class="command"><strong>telnet localhost 2119</strong></span>
<code class="computeroutput">Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'</code></pre><p>
        </p><p>
        An error message like the following indicates that the gatekeeper 
        service is not starting:
        </p><pre class="screen"><code class="computeroutput">telnet: connect to address 127.0.0.1: Connection refused
telnet: Unable to connect to remote host</code></pre><p>
        </p><p>
        If the telnet command exits immediately, then the gatekeeper service
        is being started but not running. Check the gatekeeper log (by default
        <code class="filename"><code class="envar">$GLOBUS_LOCATION</code>/var/globus-gatekeeper.log</code>)
        to see if there is an error message. A common error is having a missing
        library path environment variable in the gatekeeper's environment or
        having a malformed configuration file. See <a href="../pi/#gram5-globus-gatekeeper" class="olink">the <span class="command"><strong>globus-gatekeeper</strong></span></a> for information
        on the configuration options.
        </p><p> 
        The next recommended diagnostic is to run the same telnet command from
        the machine which is acting as the GRAM client if it is distinct from
        the GRAM service node. Be sure to replace <code class="literal">localhost</code>
        with the actual host name of the GRAM service. Again, check for log
        entries in the case of immediate exit or refused connection. If the
        connection does not work, then there may be some network connectivity
        or firewall issues preventing access.
        </p><p>
        Next use a tool like <span class="command"><strong>globusrun</strong></span> to diagnose whether
        the client is authorized to contact the gatekeeper service. This is
        done by using the <code class="option">-a</code> command-line option. For example:

        </p><pre class="screen"><code class="prompt">% </code><span class="command"><strong>globusrun -a -r grid.example.org</strong></span>
<code class="computeroutput">
GRAM Authentication test successful
</code></pre><p>
        </p><p>
        If you do not get the success message above, then check the gatekeeper
        log to see if there is a diagnostic message. A common problem is
        that the identity of the client is not in the grid mapfile used by
        the gatekeeper.
        </p><p>
        The next test is to use the <code class="option">-dryrun</code> option to
        <span class="command"><strong>globusrun</strong></span> to verify that the job manager service
        is properly configured. To do so, try the following:
        </p><pre class="screen"><code class="prompt">% </code><span class="command"><strong>globusrun -dryrun -r grid.example.org "&amp;(executable=/bin/sh)"</strong></span>
<code class="computeroutput">globus_gram_client_callback_allow successful
Dryrun successful</code></pre><p>
        </p><p>
        If you do not get the success message above, first check the error
        number in the <a href="#gram5-error-codes" class="olink">GRAM5 Error codes
        table</a> to determine how to proceed. If the result is unclear,
        check the job manager log (default
        <code class="filename"><code class="envar">$HOME</code>/gram_<em class="replaceable"><code>DATE</code></em>.log</code>)
        to see if there are any further details of the error.
        </p><p>
        The final test is to submit a test job to the GRAM5 service and wait
        for it to terminate, such as this example shows:

        </p><pre class="screen"><code class="prompt">% </code><span class="command"><strong>globus-job-run grid.example.org /bin/sh -c 'echo "hello, grid"'</strong></span>
<code class="computeroutput">hello, grid</code></pre><p>
        </p><p>
        If the process appears to hang, it might be that the job manager is
        unable to send state callbacks to the client. Check that there
        are no firewalls or network issues that would prevent the job manager
        process from connecting from the GRAM service node to the client node.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="idm136339247968"></a>2. Advanced Debugging Methods</h2></div></div></div><p>
        The methods described in this section are intended for debugging
        problems in the GRAM code, not in the user environment. 
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136339246784"></a>2.1. Debugging the Job Manager</h3></div></div></div><p>
        To debug the GRAM5 job manager, run the command located in 
        <code class="filename"><code class="envar">$GLOBUS_LOCATION</code>/etc/grid-services/jobmnager-<em class="replaceable"><code>LRM</code></em></code>
        (ignoring the first 3 fields). For example:

        </p><pre class="screen"><code class="prompt">% </code><span class="command"><strong>$GLOBUS_LOCATION/libexec/globus-job-manager \
    -conf $GLOBUS_LOCATION/etc/globus-job-manager.conf -type fork</strong></span></pre><p>
        </p><p>
        When the job manager is started in this way, it will log messages to
        standard error and will terminate 60 seconds after its last job has
        completed. This only works if there are no job managers
        running for this particular user. The job manager can be started in a
        debugger such as <span class="command"><strong>gdb</strong></span> or <span class="command"><strong>valgrind</strong></span>
        using a similar command-line.
        </p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-troubleshooting"></a>Chapter 9. Troubleshooting</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#gram5-troubleshooting-client">1. GRAM Client Troubleshooting</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136318052688">1.1. Credential Problems</a></span></dt><dt><span class="section"><a href="#idm136339225792">1.2. Connection Problems</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136313565968">1.2.1. Invalid Resource Name</a></span></dt><dt><span class="section"><a href="#idm136313750736">1.2.2. Mutual Authentication Failure</a></span></dt><dt><span class="section"><a href="#idm136313463664">1.2.3. Certificate Trust Issues</a></span></dt><dt><span class="section"><a href="#idm136313409856">1.2.4. Authentication with the Remote Server Failed</a></span></dt><dt><span class="section"><a href="#idm136313604592">1.2.5. Unable to Find the Requested Service</a></span></dt><dt><span class="section"><a href="#idm136313599200">1.2.6. Failed to Run the Job Manager</a></span></dt></dl></dd><dt><span class="section"><a href="#idm136313256336">1.3. Jobs are Hanging</a></span></dt><dt><span class="section"><a href="#idm136313645040">1.4. Logs and Debugging</a></span></dt><dt><span class="section"><a href="#idm136313543936">1.5. Diagnosing LRM Errors</a></span></dt><dt><span class="section"><a href="#idm136313535872">1.6. Email Support</a></span></dt></dl></dd><dt><span class="section"><a href="#gram5-troubleshooting-admin">2. Admin Troubleshooting</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136313531392">2.1. Security</a></span></dt><dt><span class="section"><a href="#idm136313407344">2.2. Verify that Services are Running</a></span></dt><dt><span class="section"><a href="#idm136313397136">2.3. Verify that LRM packages are installed</a></span></dt><dt><span class="section"><a href="#idm136313499984">2.4. Verify that the LRM packages are configured</a></span></dt><dt><span class="section"><a href="#gram5-troubleshooting-gatekeeper-log">2.5. Check the Gatekeeper Log</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136313496176">2.5.1. Authorization failures</a></span></dt><dt><span class="section"><a href="#idm136313494144">2.5.2. Gridmap failures</a></span></dt></dl></dd><dt><span class="section"><a href="#gram5-troubleshooting-jobmanager-log">2.6. Job Manager Logs</a></span></dt><dt><span class="section"><a href="#idm136313920048">2.7. Email Support</a></span></dt></dl></dd><dt><span class="section"><a href="#gram5-error-codes">3. Errors</a></span></dt></dl></div><a class="indexterm" name="idm136317180160"></a><a class="indexterm" name="idm136317328864"></a><p>For a list of error codes generated by GRAM5, see <a href="#gram5-error-codes" class="olink">Section 3, &#8220;Errors&#8221;</a>.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-troubleshooting-client"></a>1. GRAM Client Troubleshooting</h2></div></div></div><a class="indexterm" name="idm136340006176"></a><a class="indexterm" name="idm136339541552"></a><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136318052688"></a>1.1. Credential Problems</h3></div></div></div><p>
        GRAM requires a client certificate and private key in order
        authenticate with the GRAM service. If these are not available, the
        GRAM client will fail. In typical use, a user will create a temporary
        proxy certificate either derived from their identity certificate issued
        by some certificate authority, or from a service such as myproxy. If a
        GRAM client command returns any error containing the string
        <code class="literal">GSS Major Status</code> you've hit a credential problem.
        Look at the <a href="../../gsic/user/#security-credential-errors" class="olink">Troubleshooting Section</a>
        of the GSI manual for details about how to diagnose and correct these
        errors. The <span class="command"><strong><a href="../../gsic/user/#grid-cert-diagnostics" class="olink">grid-cert-diagnostics</a></strong></span> tool
        with the <code class="option">-p</code> command-line option is especially helpful
        for diagnosing some of these types of problems.
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136339225792"></a>1.2. Connection Problems</h3></div></div></div><p>
    There are a few things which can go wrong when trying to contact a GRAM
    service. These have slightly different error types which can help diagnose
    which problem is occurring.
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136313565968"></a>1.2.1. Invalid Resource Name</h4></div></div></div><p>If the hostname or TCP port you are using for a GRAM
    resource name is not correct, then the GRAM client will be
    unable to access the service. Errors of this type will look
    like this:

    </p><pre class="screen"><code class="prompt">% </code><span class="command"><strong>globus-job-run grid.example.org/jobmanager-fork /bin/hostname</strong></span>
<code class="computeroutput">
GRAM Job submission failed because the connection to the server failed (check host and port) (error code 12)</code>
    </pre><p>

    When this occurs, check with the resource administrator for
    correct resource naming so that you can contact the
    service.
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136313750736"></a>1.2.2. Mutual Authentication Failure</h4></div></div></div><p>
    GRAM performs mutual authentication, that is, both the client and service
    provide certificates indicating who they are. The service uses the client's
    identity to map the user to a local unix account. The client uses the
    server's identity to verify that the service is running with a host
    credential. The failure of the client to trust the server's certificate
    will generate an error message that looks like this:

    <code class="computeroutput">globus_gsi_gssapi: Authorization denied: The expected name for the remote host (host@alias.example.org) does not match the authenticated name of the remote host (host@grid.example.org). This happens when the name in the host certificate does not match the information obtained from DNS and is often a DNS configuration problem.</code>
    </p><p>
    This mismatch can happen for a number of reasons: a site administrator has
    multiple hosts sharing a certificate, a host has multiple DNS aliases, and
    the client is not aware of which name the server is using for its
    certificate, or a host's name has changed since the certificate was issued.
    The remedy for the client, after confirming with the GRAM administrator
    that the name after "authenticated name of the remote host" is the correct
    certificate name is to use a form of the GRAM resource name which includes
    this name. For example, explicitly adding a name to the abbreviated GRAM 
    contact so that instead of <code class="literal">alias.example.org</code>, you would
    use <code class="literal">alias.example.org::host@grid.example.org</code>.
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136313463664"></a>1.2.3. Certificate Trust Issues</h4></div></div></div><p>
    Because of the mutual authentication, both GRAM users and services can hit
    problems if they do not trust their peer's certificate or the Certificate
    Authority which issued it. If the client doesn't trust the server's
    certificate, it is easier to diagnose, because the GRAM service doesn't
    send much information back to the client if it doesn't trust it. However,
    working with the system administrator to get information from the GRAM
    logs will usually fix these problems fairly easily.
    </p><p>
    If the service's certificate is not trusted, the client will receive a
    message like this:

    </p><pre class="screen"><code class="prompt">% </code> <span class="command"><strong>globus-job-run grid.example.org /bin/hostname</strong></span>
<code class="computeroutput">GRAM Job submission failed because an authentication operation failed
OpenSSL Error: s3_clnt.c:915: in library: SSL routines, function SSL3_GET_SERVER_CERTIFICATE: certificate verify failed
globus_gsi_callback_module: Could not verify credential
globus_gsi_callback_module: Can't get the local trusted CA certificate: Untrusted self-signed certificate in chain with hash bbfccedf</code></pre><p>
    </p><p>This error indicates that certificate chain from the service
    certificate to the client contained a self-signed certificate (usually an
    indication that it's a CA certificate), which the client doesn't trust, and
    includes the hash of the certificate name (<code class="literal">bbfccedf</code> in
    this case). If you hit this particular type
    of error, you should send the information to the GRAM administrator and
    determine which CA should be trusted and what its signing policy is, to
    determine if you want to add it to your local set of trust roots.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../docbook/xsl/docbook-xsl-1.78.1/images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
    Different versions of OpenSSL produce different hashes for the same
    certificate names. If you upgrade a system (or transfer CA certificates
    between systems) to a different version of OpenSSL, you may hit this
    problem even if you think you have the CA certificate in your trusted
    certificate directory. If so, run the
    <span class="command"><strong>globus-update-certificate-dir</strong></span> program to update your
    hashes.
    </p></td></tr></table></div><p>
    There are other reasons why a certificate might not be trusted (it's in a
    revoked list, it has expired or was issued in the future, etc). For more details look at the 
    <a href="../../gsic/user/#gsic-user-troubleshooting" class="olink">troubleshooting information</a>
    in the GSI user's guide.
    </p><p>
    If for some reason the service does not trust your certificate, you'll get
    a rather cryptic message from GRAM that looks like this:
    </p><pre class="screen"><code class="prompt">% </code><span class="command"><strong>globus-job-run grid.example.org /bin/hostname</strong></span>
<code class="computeroutput">GRAM Job submission failed because an authentication operation failed
globus_gsi_gssapi: Unable to verify remote side's credentials
globus_gsi_gssapi: Unable to verify remote side's credentials: Couldn't verify the remote certificate
OpenSSL Error: s3_pkt.c:1086: in library: SSL routines, function SSL3_READ_BYTES: sslv3 alert bad certificate SSL alert number 42
 (error code 7)</code></pre><p>
    </p><p>
    To remedy this, consult the GRAM administrator to get information from the
    <code class="filename">/var/log/globus-gatekeeper.log</code> file to determine the
    reason why the gatekeeper didn't like your certificate. Again it could be
    CA trust issues, clock skew, or a revoked certificate. The error in the 
    gatekeeper log would typically look like the client-side trust issue above.
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136313409856"></a>1.2.4. Authentication with the Remote Server Failed</h4></div></div></div><p>
    Once the GRAM service has authenticated the client, it maps the client's identity
    to a local user account using a grid-mapfile or other mapping service. If this fails,
    the client will receive a message that looks like this:

    </p><pre class="screen"><code class="prompt">% </code><span class="command"><strong>globus-job-run grid.example.org /bin/hostname</strong></span>
<code class="computeroutput">GRAM Job submission failed because authentication with the remote server failed (error code 7)</code></pre><p>
    </p><p>
    To remedy this, consult the system administrator of the GRAM resource to be added to
    the authorized user's list. Be sure to send your credential subject name to make it
    easier for them. To get that information, run the command <span class="command"><strong>grid-cert-info -s</strong></span>.
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136313604592"></a>1.2.5. Unable to Find the Requested Service</h4></div></div></div><p>
    Recall that a GRAM resource name includes a component called the
    <code class="literal">service name</code>. The default if not specified is
    <code class="literal">jobmanager</code>, but some sites may not use that
    name, or have a different LRM name than you expect. If you specify
    an incorrect service name, or the default is not present, you'll get
    an error that looks like this:

    </p><pre class="screen"><code class="prompt">% </code><span class="command"><strong>globus-job-run grid.example.org /bin/hostname</strong></span>
<code class="computeroutput">GRAM Job submission failed because the gatekeeper failed to find the requested service (error code 93)</code></pre><p>
    </p><p>
    If you get this error, you'll need to determine which services are
    available on that GRAM resource, either by asking the admin or by looking
    at the entries in <code class="filename">/etc/grid-services</code>
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136313599200"></a>1.2.6. Failed to Run the Job Manager</h4></div></div></div><p>
    The GRAM service is split between a priveleged process called the
    <code class="filename">globus-gatekeeper</code> and a non-privileged process called
    the <code class="filename">globus-job-manager</code> which runs as a user process. If the
    <code class="filename">globus-gatekeeper</code> is unable to locate the
    <code class="filename">globus-job-manager</code> process, then this misconfiguration will 
    show up like this:
    </p><pre class="screen"><code class="prompt">% </code><span class="command"><strong>globus-job-run grid.example.org /bin/hostname</strong></span>
<code class="computeroutput">GRAM Job submission failed because the gatekeeper failed to run the job manager (error code 47)</code></pre><p>
    </p><p>
    This is an installation mistake, and the administrator of the GRAM resource must fix this.
    </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136313256336"></a>1.3. Jobs are Hanging</h3></div></div></div><p>
    One problem GRAM users sometimes encounter is that it looks like jobs
    submitted to GRAM are not making any progress, even though the local
    resource manager thinks they've run. There are a couple of reasons why this
    might occur: GRAM is not getting the information it needs from the local
    resource manager or the GRAM client is not getting the information it
    needs. We'll cover diagnosing and handling the latter case in this
    document, as the other is an system administrator issue.
    </p><p>
    The way <span class="command"><strong>globus-job-run</strong></span> and <span class="command"><strong>globusrun</strong></span>
    determine that jobs have completed is via GRAM job state callbacks. These are
    messages sent by the GRAM service to the client node indicating that something
    significant has happened in the lifecycle of the job. If for some reason the
    GRAM service can not get those messages to the client, the client will not
    be able to detect job state changes.
    </p><p>
    In order to determine if this is the case, submit a job using
    <span class="command"><strong>globus-job-submit</strong></span>, and then use the
    <span class="command"><strong>globus-job-status</strong></span> command to see if the job state
    changes. If it does not, then consult the GRAM administrator---there might be
    some problem with the installation. If it does, then for some reason the
    callbacks are not happening. This might be firewall issues or host naming issues.
    </p><p>
    The GRAM client sends a "callback contact" to the GRAM service when it submits 
    a job, in order that it can receive notifications. This contact is a reference
    to a https server embedded in the GRAM client which only handles GRAM state
    callbacks. As with all web servers, it has a URL which defines how to contact it,
    which in this case consists of the client host name and the service port number.
    If the host name that is used is not resolvable (such as a for a laptop with a 
    dynamic address), then the GRAM service will not be able to contact it. If
    that's the case, you can set the <code class="envar">GLOBUS_HOSTNAME </code>
    environment variable to the IP address that your client can be reached at, and 
    then submit your jobs. This will cause GRAM to publish that address instead of
    what it thinks the client's host name is.
    </p><p>
    Another way that the GRAM service would be unable to send job state updates to
    a client would be if there's a firewall between the service and the client.
    If that's the case, you might need to set the <code class="envar">GLOBUS_TCP_PORT_RANGE</code>
    environment variable to a comma-separated list of numbers which represent a range of 
    minimum and maximum TCP port numbers to listen on. You might have to contact
    your site administrator to determine what TCP ports are allowed. If there are none,
    you can still use <span class="command"><strong>globus-job-submit</strong></span> and
    <span class="command"><strong>globus-job-status</strong></span> to track your job's state changes, or
    use another tool like those mentioned in the <a href="../user/#gram5-user-client-tools" class="olink">section about client tools</a>.
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136313645040"></a>1.4. Logs and Debugging</h3></div></div></div><p>
    The GRAM service has a log file which contains information about the job as
    it is processed. These logs are located by default in
    <code class="filename">/var/log/globus/gram_<em class="replaceable"><code>$USERNAME</code></em>.log</code>.
    There are some different logging levels available, as
    <a href="../admin/#gram5-log-levels" class="olink">described in 
    the GRAM Adminstrator's Guide</a>. These can be controlled on a per-job
    basis by adding the <code class="literal">loglevel</code> RSL attribute to your job
    description. The default is to log only <code class="literal">FATAL</code> and
    <code class="literal">ERROR</code> messages, but other levels can sometimes help
    understand what is going on.
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136313543936"></a>1.5. Diagnosing LRM Errors</h3></div></div></div><p>
    Sometimes, bugs creep into the LRM adapter scripts. When that occurs, the GRAM job will
    usually fail with an error like this: 
    </p><pre class="screen"><code class="computeroutput">GRAM Job failed because the job manager detected an invalid script status (error
code 25)</code></pre><p>
    </p><p>If this occurs, you may have to work with a GRAM administrator to
    help debug this problem. One helpful thing you can do when reporting it is
    to save the GRAM internal script data so that it can be used outside of the
    GRAM service to see what the low-level error looks like. To do this, add the
    RSL fragment <code class="literal">(savejobdescription = yes)</code> to your job
    request. This will cause GRAM to leave a file called something like
    <code class="filename">$HOME/gram_[0-9]*.pl</code> in your home directory. You can use this with
    the internal tool <code class="filename">/usr/share/globus/globus-job-manager-script.pl</code> to
    try to submit the job to the LRM without using the GRAM service. The command line
    <span class="command"><strong>/usr/share/globus/globus-job-manager-script.pl -m <em class="replaceable"><code>LRM</code></em> -c submit -f <em class="replaceable"><code>GRAM-PL-FILE</code></em></strong></span> will attempt to submit the job to the LRM. It will show all the information the LRM
    script sends to the GRAM service, which might include some perl-language error or badly formatted output from the script (which must only output lines which begin with <code class="literal">GRAM_SCRIPT_</code>.
    </p><p>
    In some extreme cases, the savejobdescription option will not generate a
    file. If that's the case, pass <code class="filename">/dev/null</code> as the argument
    to the <code class="option">-f</code> command-line option. The problem is likely a
    perl syntax error which will be reached before the job description is loaded.
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136313535872"></a>1.6. Email Support</h3></div></div></div><p>
    If all else fails, please send information about your problem to <code class="email">&lt;<a class="email" href="mailto:gram-user@globus.org">gram-user@globus.org</a>&gt;</code>.
    You'll have to subscribe to a list before you can send an e-mail to it.
    See <a class="ulink" href="http://dev.globus.org/wiki/Mailing_Lists" target="_top">here</a> for
    general e-mail lists and information on how to subscribe to a list and
    <a class="ulink" href="http://dev.globus.org/wiki/GRAM#Mailing_Lists" target="_top">here</a>
    for GRAM specific lists. Depending on the problem, you may be requested to file a bug report to
    the globus project's <a class="ulink" href="http://jira.globus.org" target="_top">Issue Tracker</a>.
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-troubleshooting-admin"></a>2. Admin Troubleshooting</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136313531392"></a>2.1. Security</h3></div></div></div><p>GRAM requires a host certificate and private key in order for the <span class="command"><strong>globus-gatekeeeper</strong></span> service to run. These are typically located in
                <code class="filename">/etc/grid-security/hostcert.pem</code> and <code class="filename">/etc/grid-security/hostkey.pem</code>, but the path is configurable in the
                <a href="../admin/#gram5-configuring-gatekeeper" class="olink">gatekeeper
                configuration file</a>. The key must be protected by file permissions allowing
            only the root user to read it. </p><p>GRAM also (by default) uses a <code class="filename">grid-mapfile</code> to authorize Grid
            users as local users. This file is typically located in <code class="filename">/etc/grid-security/grid-mapfile</code>, but is configurable in the <a href="../admin/#gram5-configuring-gatekeeper" class="olink">gatekeeper
                configuration file</a>. </p><p>Problems in either of these configurations will show up in the gatekeeper log
            described below. See the <a href="../../gsic/#gsic" class="olink">GSI</a> documentation for more
            detailed information about obtaining and installing host certificates and maintaining a
                <code class="filename">grid-mapfile</code>. </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136313407344"></a>2.2. Verify that Services are Running</h3></div></div></div><p>GRAM relies on the <span class="command"><strong>globus-gatekeeper</strong></span> program and (in some cases)
            the <span class="command"><strong>globus-scheduler-event-generator</strong></span> programs to process jobs. If the
            former is not running, jobs requests will fail with a "connection refused" error. If the
            latter is not running, GRAM jobs will appear to "hang" in the <code class="literal">PENDING</code>
            state. </p><p>The <span class="command"><strong>globus-gatekeeper</strong></span> is typically started via an init script
            installed in <code class="filename">/etc/init.d/globus-gatekeeper</code>. The command <span class="command"><strong>/etc/init.d/globus-gatekeeper status</strong></span> will indicate whether the service is
            running. See <a href="../admin/#gram5-admin-starting-and-stopping" class="olink">Section 2, &#8220;Starting and Stopping GRAM5 services&#8221;</a> for more information about starting and stopping the <span class="command"><strong>globus-gatekeeper</strong></span> program. </p><p>If the <span class="command"><strong>globus-gatekeeper</strong></span> service fails to start, the output of the
            command <span class="command"><strong>globus-gatekeeper -test</strong></span> will output information describing
            some types of configuration problems. </p><p>The <span class="command"><strong>globus-scheduler-event-generator</strong></span> is typically started via an
            init script installed in <code class="filename">/etc/init.d/globus-scheduler-event-generator</code>. It is only needed when the
            LRM-specific "setup-seg" package is installed. The command <span class="command"><strong>/etc/init.d/globus-scheduler-event-generator status</strong></span> will indicate whether
            the service is running. See <a href="../admin/#gram5-admin-starting-and-stopping" class="olink">Section 2, &#8220;Starting and Stopping GRAM5 services&#8221;</a> for more information about starting
            and stopping the <span class="command"><strong>globus-scheduler-event-generator</strong></span> program. </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136313397136"></a>2.3. Verify that LRM packages are installed</h3></div></div></div><p> The <span class="command"><strong>globus-gatekeeper</strong></span> program starts the <span class="command"><strong>globus-job-manager</strong></span> service with different command-line parameters
            depending on the LRM being used. Use the command <span class="command"><strong>globus-gatekeeper-admin
                -l</strong></span> to list which LRMs the gatekeeper is configured to use. </p><p> The <span class="command"><strong>globus-job-manager-script.pl</strong></span> is the interface between the GRAM
            job manager process and the LRM adapter. The command <span class="command"><strong>/usr/share/globus/globus-job-manager-script.pl -h</strong></span> will print the list of
            available adapters.
            </p><pre class="screen"><code class="prompt">% </code><span class="command"><strong>/usr/share/globus/globus-job-manager-script.pl -h</strong></span>
<code class="computeroutput">USAGE: /usr/share/globus/globus-job-manager-script.pl -m MANAGER -f FILE -c COMMAND
Installed managers: condor fork</code></pre><p> The <span class="command"><strong>globus-scheduler-event-generator</strong></span> also uses an LRM-specific
            module to generate scheduler events for GRAM to reduce the amount of resources GRAM uses
            on the machine where it runs. To determine which LRMs are installed and configured, use
            the command <span class="command"><strong>globus-scheduler-event-generator-admin -l</strong></span>.
            </p><pre class="screen"><code class="prompt">% </code><span class="command"><strong>globus-scheduler-event-generator-admin -l</strong></span>
<code class="computeroutput">fork [DISABLED]</code></pre><p> If any of these do not show the LRM you are trying to use, install the relevant
            packages related to that LRM and restart the GRAM services. See the <a href="../admin/#gram5Admin" class="olink">GRAM Administrator's Guide</a> for more information about
            starting and stopping the GRAM services. </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136313499984"></a>2.4. Verify that the LRM packages are configured</h3></div></div></div><p> All GRAM5 LRM adapters have a configuration file for site customizations, such as
            queue names, paths to executables needed to interface with the LRM, etc. Check that the
            values in these files are correct. These files are described in <a href="../admin/#gram5-configuring-lrm" class="olink">Section 4, &#8220;LRM Adapter Configuration&#8221;</a>. </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gram5-troubleshooting-gatekeeper-log"></a>2.5. Check the Gatekeeper Log</h3></div></div></div><p> The <code class="filename">/var/log/globus-gatekeeper.log</code> file contains information
            about service requests from clients, and will be useful when diagnosing service startup
            failures, authentication failures, and authorization failures. </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136313496176"></a>2.5.1. Authorization failures</h4></div></div></div><p> GRAM uses GSI to authenticate client job requests. If there is a problem with the
                GSI configuration for your host, or a client is trying to connect with a certificate
                signed by a CA your host does not trust, the job request will fail. This will show
                up in the log as a "GSS authentication failure". See the <a href="../../gsic/admin/#gsicAdmin" class="olink">GSI Administrator's Guide</a> for information about
                diagnosing authentication failures. </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136313494144"></a>2.5.2. Gridmap failures</h4></div></div></div><p> After authentication is complete, GRAM maps the Grid identity to a local user
                prior to starting the <span class="command"><strong>globus-job-manager</strong></span> process. If this fails,
                an error will show up in the log as "globus_gss_assist_gridmap() failed
                authorization". See the <a href="../../gsic/admin/#gsicAdmin" class="olink">GSI Administrator's
                    Guide</a> for information about managing gridmap files. </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gram5-troubleshooting-jobmanager-log"></a>2.6. Job Manager Logs</h3></div></div></div><p> A per-user job manager log is typically located in
            <code class="filename">/var/log/globus/gram_<em class="replaceable"><code>$USERNAME</code></em>.log</code>.
            This log contains information from the job manager as it attempts
            to execute GRAM jobs via a local resource manager. The logs can be
            fairly verbose. Sometimes looking for log entries near those
            containing the string <code class="literal">level=ERROR</code> will show more information
            about what caused a particular failure.
        </p><p>
            Once you've found an error in the log, it is generally useful to find log entries
            related to the job which hit that error. There are two job IDs associated with
            each job, one a GRAM-specific ID, and one an LRM-specific ID. To determine the
            GRAM ID associated with a job, look for the attribute
            <code class="literal">gramid</code> in the log message. Finding that, looking for all
            other log messages which contain that <code class="literal">gramid</code> value will
            give a better picture of what the job manager is doing. To determine the
            LRM-specific ID, look for a message at <code class="literal">TRACE</code> level with the
            matching GRAM ID found above with the <code class="literal">response</code> value matching
            <code class="literal">GRAM_SCRIPT_JOB_ID:</code><em class="replaceable"><code>LRM-ID</code></em>. You
            can then find follow the state of the <em class="replaceable"><code>LRM-ID</code></em> as well
            as the GRAM ID in the log, and correlate the <em class="replaceable"><code>LRM-ID</code></em>
            information with local resource manager logs and administrative tools.
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136313920048"></a>2.7. Email Support</h3></div></div></div><p> If all else fails, please send information about your problem to
                <code class="email">&lt;<a class="email" href="mailto:gram-user@globus.org">gram-user@globus.org</a>&gt;</code>. You'll have to subscribe to a list before you
            can send an e-mail to it. See <a class="ulink" href="http://dev.globus.org/wiki/Mailing_Lists" target="_top">here</a> for general e-mail lists and information on how to subscribe to a list
            and <a class="ulink" href="http://dev.globus.org/wiki/GRAM#Mailing_Lists" target="_top">here</a> for
            GRAM-specific lists. Depending on the problem, you may be requested to file a bug report
            to the Globus project's <a class="ulink" href="http://jira.globus.org" target="_top">Issue Tracker</a>.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-error-codes"></a>3. Errors</h2></div></div></div><a class="indexterm" name="idm136312994032"></a><div class="table"><a name="gram5-errors-table"></a><p class="title"><b>Table 9.1. GRAM5 Errors</b></p><div class="table-contents"><table summary="GRAM5 Errors" border="1" width="700px"><colgroup><col align="left" class="c1"><col align="left" class="c2"><col align="left" class="c3"></colgroup><thead><tr><th align="left">Error Code</th><th align="left">Reason</th><th align="left">Possible Solutions</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">one of the RSL parameters is not supported</td><td align="left">Check RSL documentation</td></tr><tr><td align="left">2</td><td align="left">the RSL length is greater than the maximum allowed</td><td align="left">Use RSL substitutions to reduce length of RSL strings</td></tr><tr><td align="left">3</td><td align="left">an I/O operation failed</td><td align="left">Enable trace logging and report to gram-dev@globus.org</td></tr><tr><td align="left">4</td><td align="left">jobmanager unable to set default to the directory requested</td><td align="left">Check that RSL <code class="literal">directory</code> attribute refers to a directory that exists on the target system.</td></tr><tr><td align="left">5</td><td align="left">the executable does not exist</td><td align="left">Check that the RSL <code class="literal">executable</code> attribute refers to an executable that exists on the target system.</td></tr><tr><td align="left">6</td><td align="left">of an unused INSUFFICIENT_FUNDS</td><td align="left">Unimplemented feature.</td></tr><tr><td align="left">7</td><td align="left">authentication with the remote server failed</td><td align="left">Check that the contact string contains the proper X.509 DN.</td></tr><tr><td align="left">8</td><td align="left">the user cancelled the job</td><td align="left">Don't cancel jobs you want to complete.</td></tr><tr><td align="left">9</td><td align="left">the system cancelled the job</td><td align="left">Check RSL requirements such as maximum time and memory are valid for the job.</td></tr><tr><td align="left">10</td><td align="left">data transfer to the server failed</td><td align="left">Check gatekeeper and/or job manager logs to see why the process failed.</td></tr><tr><td align="left">11</td><td align="left">the stdin file does not exist</td><td align="left">Check that the RSL <code class="literal">stdin</code> attribute refers to a file that exists on the target system or has a valid ftp, gsiftp, http, or https URL.</td></tr><tr><td align="left">12</td><td align="left">the connection to the server failed (check host and port)</td><td align="left">Check that the service is running on the expected TCP/IP port.
               Check that no firewall prevents contacting that TCP/IP port.
               Check <code class="filename"><code class="envar">$GLOBUS_LOCATION</code>/var/globus-gatekeeper.log</code> for runtme configuration errors.</td></tr><tr><td align="left">13</td><td align="left">the provided RSL 'maxtime' value is not an integer</td><td align="left">Check that the RSL <code class="literal">maxtime</code> value evaluates to an integer.</td></tr><tr><td align="left">14</td><td align="left">the provided RSL 'count' value is not an integer</td><td align="left">Check that the RSL <code class="literal">count</code> value evaluates to an integer.</td></tr><tr><td align="left">15</td><td align="left">the job manager received an invalid RSL</td><td align="left">Check that the RSL string can be parsed by using <span class="command"><strong>globusrun -p <em class="replaceable"><code>RSL</code></em></strong></span>.</td></tr><tr><td align="left">16</td><td align="left">the job manager failed in allowing others to make contact</td><td align="left">Check job manager log.</td></tr><tr><td align="left">17</td><td align="left">the job failed when the job manager attempted to run it</td><td align="left">Verify that the LRM is configured properly.</td></tr><tr><td align="left">18</td><td align="left">an invalid paradyn was specified</td><td align="left">OBSOLETE IN GRAM2</td></tr><tr><td align="left">19</td><td align="left">the provided RSL 'jobtype' value is invalid</td><td align="left">The RSL <code class="literal">jobtype</code> attribute is not indicated as supported by the LRM. Valid <code class="literal">jobtype</code> values are <code class="literal">single</code>,  <code class="literal">multiple</code>, <code class="literal">mpi</code>, and <code class="literal">condor</code>.</td></tr><tr><td align="left">20</td><td align="left">the provided RSL 'myjob' value is invalid</td><td align="left">OBSOLETE IN GRAM5</td></tr><tr><td align="left">21</td><td align="left">the job manager failed to locate an internal script argument file</td><td align="left">Check that <code class="filename"><code class="envar">$GLOBUS_LOCATION</code>/libexec/globus-job-manager-script.pl</code> exists and is executable.
        Check that the LRM-specific perl module is located in <code class="filename"><code class="envar">$GLOBUS_LOCATION</code>/lib/perl/Globus/GRAM/JobManager/</code> directory and is valid. The command <span class="command"><strong>perl -I$GLOBUS_LOCATION/lib/perl $GLOBUS_LOCATION/lib/perl/Globus/GRAM/JobManager/<em class="replaceable"><code>LRM</code></em>.pm</strong></span> can be used to check if there are any syntax errors in the script.</td></tr><tr><td align="left">22</td><td align="left">the job manager failed to create an internal script argument file</td><td align="left">Check that your home directory is writable and not full.</td></tr><tr><td align="left">23</td><td align="left">the job manager detected an invalid job state</td><td align="left">Check job manager logs.</td></tr><tr><td align="left">24</td><td align="left">the job manager detected an invalid script response</td><td align="left">Check job manager logs. This is likely a bug in the LRM script.</td></tr><tr><td align="left">25</td><td align="left">the job manager detected an invalid script status</td><td align="left">Check job manager logs. This is likely a bug in the LRM script.</td></tr><tr><td align="left">26</td><td align="left">the provided RSL 'jobtype' value is not supported by this job manager</td><td align="left">Check that the RSL <code class="literal">jobtype</code> attribute is implemented by the LRM script. Note that some job types require configuration</td></tr><tr><td align="left">27</td><td align="left">unused ERROR_UNIMPLEMENTED</td><td align="left">LRM does not support some feature included in the job request. </td></tr><tr><td align="left">28</td><td align="left">the job manager failed to create an internal script submission file</td><td align="left">Check that the user's home file system is not full. Check job manager log</td></tr><tr><td align="left">29</td><td align="left">the job manager cannot find the user proxy</td><td align="left">Check that client is delegating a proxy when authenticating with the gatekeeper.
        Check that the user's home filesystem and the <code class="filename">/tmp</code> file system are not full.</td></tr><tr><td align="left">30</td><td align="left">the job manager failed to open the user proxy</td><td align="left">Check that the user's home filesystem and the <code class="filename">/tmp</code> file system are not full.</td></tr><tr><td align="left">31</td><td align="left">the job manager failed to cancel the job as requested</td><td align="left">Check that the user's home filesystem and the <code class="filename">/tmp</code> file system are not full.</td></tr><tr><td align="left">32</td><td align="left">system memory allocation failed</td><td align="left">Check job manager log for details.</td></tr><tr><td align="left">33</td><td align="left">the interprocess job communication initialization failed</td><td align="left">OBSOLETE IN GRAM5</td></tr><tr><td align="left">34</td><td align="left">the interprocess job communication setup failed</td><td align="left">OBSOLETE IN GRAM5</td></tr><tr><td align="left">35</td><td align="left">the provided RSL 'host count' value is invalid</td><td align="left">Check that the RSL <code class="literal">host_count</code> attribute evaluates to an integer.</td></tr><tr><td align="left">36</td><td align="left">one of the provided RSL parameters is unsupported</td><td align="left">Check job manager log for details about invalid parameter.</td></tr><tr><td align="left">37</td><td align="left">the provided RSL 'queue' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">queue</code> attribute evaluates to a string that corresponds to an LRM-specific queue name.</td></tr><tr><td align="left">38</td><td align="left">the provided RSL 'project' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">project</code> attribute evaluates to a string that corresponds to an LRM-specific project name.</td></tr><tr><td align="left">39</td><td align="left">the provided RSL string includes variables that could not be identified</td><td align="left">Check that all RSL substitutions are defined before being used in the job description.</td></tr><tr><td align="left">40</td><td align="left">the provided RSL 'environment' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">environment</code> attribute contains a sequence of <em class="replaceable"><code>VARIABLE</code></em> <em class="replaceable"><code>VALUE</code></em> pairs.</td></tr><tr><td align="left">41</td><td align="left">the provided RSL 'dryrun' parameter is invalid</td><td align="left">Remove the RSL <code class="literal">dryrun</code> attribute from the job description.</td></tr><tr><td align="left">42</td><td align="left">the provided RSL is invalid (an empty string)</td><td align="left">Include a non-empty RSL string in your job submission request.</td></tr><tr><td align="left">43</td><td align="left">the job manager failed to stage the executable</td><td align="left">Check that the file service hosting the executable is reachable from the GRAM5 service node.
        Check that the executable exists on the file service node.
        Check that there is sufficient disk space in the user's home directory on the service node to store the executable.</td></tr><tr><td align="left">44</td><td align="left">the job manager failed to stage the stdin file</td><td align="left">Check that the file service hosting the standard input file is reachable from the GRAM5 service node.
        Check that the standard input file exists on the file service node.
        Check that there is sufficient disk space in the user's home directory on the service node to store the standard input file.</td></tr><tr><td align="left">45</td><td align="left">the requested job manager type is invalid</td><td align="left">OBSOLETE IN GRAM5</td></tr><tr><td align="left">46</td><td align="left">the provided RSL 'arguments' parameter is invalid</td><td align="left">OBSOLETE IN GRAM2</td></tr><tr><td align="left">47</td><td align="left">the gatekeeper failed to run the job manager</td><td align="left">Check the gatekeeper or job manager logs for more information.</td></tr><tr><td align="left">48</td><td align="left">the provided RSL could not be properly parsed</td><td align="left">Check that the RSL string can be parsed by using <span class="command"><strong>globusrun -p <em class="replaceable"><code>RSL</code></em></strong></span>.</td></tr><tr><td align="left">49</td><td align="left">there is a version mismatch between GRAM components</td><td align="left">Ask system administrator to upgrade GRAM service to GRAM2 or GRAM5</td></tr><tr><td align="left">50</td><td align="left">the provided RSL 'arguments' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">arguments</code> attribute evaluates to a sequence of strings.</td></tr><tr><td align="left">51</td><td align="left">the provided RSL 'count' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">count</code> attribute evaluates to a positive integer value.</td></tr><tr><td align="left">52</td><td align="left">the provided RSL 'directory' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">directory</code> attribute evaluates to a string.</td></tr><tr><td align="left">53</td><td align="left">the provided RSL 'dryrun' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">dryrun</code> attribute evaluates to either <code class="literal">yes</code> or <code class="literal">no</code>.</td></tr><tr><td align="left">54</td><td align="left">the provided RSL 'environment' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">environment</code> attribute evaluates to a sequence of <em class="replaceable"><code>VARIABLE</code></em>, <em class="replaceable"><code>VALUE</code></em> pairs.</td></tr><tr><td align="left">55</td><td align="left">the provided RSL 'executable' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">executable</code> attribute evaluates to a string value.</td></tr><tr><td align="left">56</td><td align="left">the provided RSL 'host_count' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">host_count</code> attribute evaluates to a positive integer value.</td></tr><tr><td align="left">57</td><td align="left">the provided RSL 'jobtype' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">jobtype</code> attribute evaluates to one of <code class="literal">single</code>, <code class="literal">multiple</code>, <code class="literal">mpi</code>, or <code class="literal">condor</code></td></tr><tr><td align="left">58</td><td align="left">the provided RSL 'maxtime' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">maxtime</code> attribute evaluates to a positive integer value.</td></tr><tr><td align="left">59</td><td align="left">the provided RSL 'myjob' parameter is invalid</td><td align="left">OBSOLETE IN GRAM5.</td></tr><tr><td align="left">60</td><td align="left">the provided RSL 'paradyn' parameter is invalid</td><td align="left">OBSOLETE IN GRAM2.</td></tr><tr><td align="left">61</td><td align="left">the provided RSL 'project' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">project</code> attribute evaluates to a string value.</td></tr><tr><td align="left">62</td><td align="left">the provided RSL 'queue' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">queue</code> attribute evaluates to a string value.</td></tr><tr><td align="left">63</td><td align="left">the provided RSL 'stderr' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">stderr</code> attribute evaluates to a string value or a sequence of <em class="replaceable"><code>DESTINATION</code></em> URLs with optional <em class="replaceable"><code>CACHE_TAG</code></em> string parameters.</td></tr><tr><td align="left">64</td><td align="left">the provided RSL 'stdin' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">stdin</code> attribute evaluates to a string value.</td></tr><tr><td align="left">65</td><td align="left">the provided RSL 'stdout' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">stdout</code> attribute evaluates to a string value or a sequence of <em class="replaceable"><code>DESTINATION</code></em> URLs with optional <em class="replaceable"><code>CACHE_TAG</code></em> string parameters.</td></tr><tr><td align="left">66</td><td align="left">the job manager failed to locate an internal script</td><td align="left">Check job manager log for more details.</td></tr><tr><td align="left">67</td><td align="left">the job manager failed on the system call pipe()</td><td align="left">OBSOLETE IN GRAM5</td></tr><tr><td align="left">68</td><td align="left">the job manager failed on the system call fcntl()</td><td align="left">OBSOLETE IN GRAM2</td></tr><tr><td align="left">69</td><td align="left">the job manager failed to create the temporary stdout filename</td><td align="left">OBSOLETE IN GRAM5</td></tr><tr><td align="left">70</td><td align="left">the job manager failed to create the temporary stderr filename</td><td align="left">OBSOLETE IN GRAM5</td></tr><tr><td align="left">71</td><td align="left">the job manager failed on the system call fork()</td><td align="left">OBSOLETE IN GRAM2</td></tr><tr><td align="left">72</td><td align="left">the executable file permissions do not allow execution</td><td align="left">Check that the RSL <code class="literal">executable</code> attribute refers to an executable program or script.</td></tr><tr><td align="left">73</td><td align="left">the job manager failed to open stdout</td><td align="left">Check that the RSL <code class="literal">stdout</code> attribute refers to one or more valid destination files or URLs.</td></tr><tr><td align="left">74</td><td align="left">the job manager failed to open stderr</td><td align="left">Check that the RSL <code class="literal">stderr</code> attribute refers to one or more valid destination files or URLs.</td></tr><tr><td align="left">75</td><td align="left">the cache file could not be opened in order to relocate the user proxy</td><td align="left">Check that the user's home directory is writable and not full on the GRAM5 service node.</td></tr><tr><td align="left">76</td><td align="left">cannot access cache files in ~/.globus/.gass_cache, check permissions, quota, and disk space</td><td align="left">Check that the user's home directory is writable and not full on the GRAM5 service node.</td></tr><tr><td align="left">77</td><td align="left">the job manager failed to insert the contact in the client contact list</td><td align="left">Check job manager log</td></tr><tr><td align="left">78</td><td align="left">the contact was not found in the job manager's client contact list</td><td align="left">Don't attempt to unregister callback contacts that are not registered</td></tr><tr><td align="left">79</td><td align="left">connecting to the job manager failed.  Possible reasons: job terminated, invalid job contact, network problems, ...</td><td align="left">Check that the job manager process is running.
        Check that the job manager credential has not expired.
        Check that the job manager contact refers to the correct TCP/IP host and port.
        Check that the job manager contact is not blocked by a firewall.</td></tr><tr><td align="left">80</td><td align="left">the syntax of the job contact is invalid</td><td align="left">Check the syntax of job contact string.</td></tr><tr><td align="left">81</td><td align="left">the executable parameter in the RSL is undefined</td><td align="left">Include the RSL <code class="literal">executable</code> in all job requests.</td></tr><tr><td align="left">82</td><td align="left">the job manager service is misconfigured.  condor arch undefined</td><td align="left">Add the <code class="option">-condor-arch</code> to the command-line or configuration file for a job manager configured to use the <code class="literal">condor</code> LRM.</td></tr><tr><td align="left">83</td><td align="left">the job manager service is misconfigured.  condor os undefined</td><td align="left">Add the <code class="option">-condor-os</code> to the command-line or configuration file for a job manager configured to use the <code class="literal">condor</code> LRM.</td></tr><tr><td align="left">84</td><td align="left">the provided RSL 'min_memory' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">min_memory</code> attribute evaluates to a positive integer value.</td></tr><tr><td align="left">85</td><td align="left">the provided RSL 'max_memory' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">max_memory</code> attribute evaluates to a positive integer value.</td></tr><tr><td align="left">86</td><td align="left">the RSL 'min_memory' value is not zero or greater</td><td align="left">Check that the RSL <code class="literal">min_memory</code> attribute evaluates to a positive integer value.</td></tr><tr><td align="left">87</td><td align="left">the RSL 'max_memory' value is not zero or greater</td><td align="left">Check that the RSL <code class="literal">max_memory</code> attribute evaluates to a positive integer value.</td></tr><tr><td align="left">88</td><td align="left">the creation of a HTTP message failed</td><td align="left">Check job manager log.</td></tr><tr><td align="left">89</td><td align="left">parsing incoming HTTP message failed</td><td align="left">Check job manager log.</td></tr><tr><td align="left">90</td><td align="left">the packing of information into a HTTP message failed</td><td align="left">Check job manager log.</td></tr><tr><td align="left">91</td><td align="left">an incoming HTTP message did not contain the expected information</td><td align="left">Check job manager log.</td></tr><tr><td align="left">92</td><td align="left">the job manager does not support the service that the client requested</td><td align="left">Check that the client is talking to the correct servce</td></tr><tr><td align="left">93</td><td align="left">the gatekeeper failed to find the requested service</td><td align="left">OBSOLETE IN GRAM2</td></tr><tr><td align="left">94</td><td align="left">the jobmanager does not accept any new requests (shutting down)</td><td align="left">Execute queries before the job has been cleaned up.</td></tr><tr><td align="left">95</td><td align="left">the client failed to close the listener associated with the callback URL</td><td align="left">Call <code class="function">globus_gram_client_callback_disallow()</code> with a valid the callback contact.</td></tr><tr><td align="left">96</td><td align="left">the gatekeeper contact cannot be parsed</td><td align="left">Check the syntax of the gatekeeper contact string you are attempting to contact.</td></tr><tr><td align="left">97</td><td align="left">the job manager could not find the 'poe' command</td><td align="left">OBSOLETE IN GRAM2</td></tr><tr><td align="left">98</td><td align="left">the job manager could not find the 'mpirun' command</td><td align="left">Configure the LRM script with <code class="filename">mpirun</code> in your path.</td></tr><tr><td align="left">99</td><td align="left">the provided RSL 'start_time' parameter is invalid</td><td align="left">OBSOLETE IN GRAM2</td></tr><tr><td align="left">100</td><td align="left">the provided RSL 'reservation_handle' parameter is invalid</td><td align="left">OBSOLETE IN GRAM2</td></tr><tr><td align="left">101</td><td align="left">the provided RSL 'max_wall_time' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">max_wall_time</code> attribute evaluates to a positive integer.</td></tr><tr><td align="left">102</td><td align="left">the RSL 'max_wall_time' value is not zero or greater</td><td align="left">Check that the RSL <code class="literal">max_wall_time</code> attribute evaluates to a positive integer.</td></tr><tr><td align="left">103</td><td align="left">the provided RSL 'max_cpu_time' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">max_cpu_time</code> attribute evaluates to a positive integer.</td></tr><tr><td align="left">104</td><td align="left">the RSL 'max_cpu_time' value is not zero or greater</td><td align="left">Check that the RSL <code class="literal">max_cpu_time</code> attribute evaluates to a positive integer.</td></tr><tr><td align="left">105</td><td align="left">the job manager is misconfigured, a scheduler script is missing</td><td align="left">Check that the adminstrator has configured the LRM by running its setup script.</td></tr><tr><td align="left">106</td><td align="left">the job manager is misconfigured, a scheduler script has invalid permissions</td><td align="left">Check that the adminstrator has installed the <code class="filename"><code class="envar">GLLOBUS_LOCATION</code>/libexec/globus-job-manager-script.pl</code> script.
        Check that the file system containing that script allows file execution.</td></tr><tr><td align="left">107</td><td align="left">the job manager failed to signal the job</td><td align="left">OBSOLETE IN GRAM2</td></tr><tr><td align="left">108</td><td align="left">the job manager did not recognize/support the signal type</td><td align="left">Check that your signal operation is using the correct signal constant.</td></tr><tr><td align="left">109</td><td align="left">the job manager failed to get the job id from the local scheduler</td><td align="left">OBSOLETE IN GRAM2</td></tr><tr><td align="left">110</td><td align="left">the job manager is waiting for a commit signal</td><td align="left">Send a two-phase commit signal to the job manager to acknowledge receiving the job contact from the job manager.</td></tr><tr><td align="left">111</td><td align="left">the job manager timed out while waiting for a commit signal</td><td align="left">Send a two-phase commit signal to the job manager to acknowledge receiving the job contact from the job manager.
        Increase the two-phase commit time out for your job.
        Check that the job manager contact TCP/IP port is reachable from your client.</td></tr><tr><td align="left">112</td><td align="left">the provided RSL 'save_state' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">save_state</code> attribute is set to <code class="literal">yes</code> or <code class="literal">no</code>.</td></tr><tr><td align="left">113</td><td align="left">the provided RSL 'restart' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">restart</code> attribute evaluates to a string containing a job contact string.</td></tr><tr><td align="left">114</td><td align="left">the provided RSL 'two_phase' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">two_phase</code> attribute evaluates to a positive integer.</td></tr><tr><td align="left">115</td><td align="left">the RSL 'two_phase' value is not zero or greater</td><td align="left">Check that the RSL <code class="literal">two_phase</code> attribute evaluates to a positive integer.</td></tr><tr><td align="left">116</td><td align="left">the provided RSL 'stdout_position' parameter is invalid</td><td align="left">OBSOLETE IN GRAM5</td></tr><tr><td align="left">117</td><td align="left">the RSL 'stdout_position' value is not zero or greater</td><td align="left">OBSOLETE IN GRAM5</td></tr><tr><td align="left">118</td><td align="left">the provided RSL 'stderr_position' parameter is invalid</td><td align="left">OBSOLETE IN GRAM5</td></tr><tr><td align="left">119</td><td align="left">the RSL 'stderr_position' value is not zero or greater</td><td align="left">OBSOLETE IN GRAM5</td></tr><tr><td align="left">120</td><td align="left">the job manager restart attempt failed</td><td align="left">OBSOLETE IN GRAM2</td></tr><tr><td align="left">121</td><td align="left">the job state file doesn't exist</td><td align="left">Check that the job contact you are trying to restart matches one that the job manager returned to you.</td></tr><tr><td align="left">122</td><td align="left">could not read the job state file</td><td align="left">Check that the state file directory is not full.</td></tr><tr><td align="left">123</td><td align="left">could not write the job state file</td><td align="left">Check that the state file directory is not full.</td></tr><tr><td align="left">124</td><td align="left">old job manager is still alive</td><td align="left">Contact the returned job manager contact to manage the job you are trying to restart.</td></tr><tr><td align="left">125</td><td align="left">job manager state file TTL expired</td><td align="left">OBSOLETE in GRAM2</td></tr><tr><td align="left">126</td><td align="left">it is unknown if the job was submitted</td><td align="left">Check job manager log.</td></tr><tr><td align="left">127</td><td align="left">the provided RSL 'remote_io_url' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">remote_io_url</code> attribute evaluates to a string value.</td></tr><tr><td align="left">128</td><td align="left">could not write the remote io url file</td><td align="left">Check that the user's home file system on the job manager service node is writable and not full.</td></tr><tr><td align="left">129</td><td align="left">the standard output/error size is different</td><td align="left">Send a stdio update signal to redirect the job manager output to a new URL</td></tr><tr><td align="left">130</td><td align="left">the job manager was sent a stop signal (job is still running)</td><td align="left">Submit a restart request to monitor the job.</td></tr><tr><td align="left">131</td><td align="left">the user proxy expired (job is still running)</td><td align="left">Generate a new proxy and then submit a restart request to monitor the job.</td></tr><tr><td align="left">132</td><td align="left">the job was not submitted by original jobmanager</td><td align="left">OBSOLETE IN GRAM2</td></tr><tr><td align="left">133</td><td align="left">the job manager is not waiting for that commit signal</td><td align="left">Do not send a commit signal to a job that is not waiting for a commit signal.</td></tr><tr><td align="left">134</td><td align="left">the provided RSL scheduler specific parameter is invalid</td><td align="left">Check the LRM-specific documentation to determine what values are legal for the RSL extensions implemented by the LRM.</td></tr><tr><td align="left">135</td><td align="left">the job manager could not stage in a file</td><td align="left">Check that the file service hosting the file to stage is reachable from the GRAM5 service node.
        Check that the file to stage exists on the file service node.
        Check that there is sufficient disk space in the user's home directory on the service node to store the file to stage.</td></tr><tr><td align="left">136</td><td align="left">the scratch directory could not be created</td><td align="left">Check that the directory named by the RSL <code class="literal">scratch_dir</code> attribute exists and is writable.
        Check that the directory named by the RSL <code class="literal">scratch_dir</code> attribute is not full.</td></tr><tr><td align="left">137</td><td align="left">the provided 'gass_cache' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">gass_cache</code> attribute evaluates to a string.</td></tr><tr><td align="left">138</td><td align="left">the RSL contains attributes which are not valid for job submission</td><td align="left">Do not use restart- or signal-only RSL attributes when submitting a job.</td></tr><tr><td align="left">139</td><td align="left">the RSL contains attributes which are not valid for stdio update</td><td align="left">Do not use submit- or restart-only RSL attributes when sending a stdio update signal to a job.</td></tr><tr><td align="left">140</td><td align="left">the RSL contains attributes which are not valid for job restart</td><td align="left">Do not use submit- or signal-only RSL attributes when restarting a job.</td></tr><tr><td align="left">141</td><td align="left">the provided RSL 'file_stage_in' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">file_stage_in</code> attribute evaluates to a sequence of <em class="replaceable"><code>SOURCE</code></em> <em class="replaceable"><code>DESTINATION</code></em> pairs.</td></tr><tr><td align="left">142</td><td align="left">the provided RSL 'file_stage_in_shared' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">file_stage_in_shared</code> attribute evaluates to a sequence of <em class="replaceable"><code>SOURCE</code></em> <em class="replaceable"><code>DESTINATION</code></em> pairs.</td></tr><tr><td align="left">143</td><td align="left">the provided RSL 'file_stage_out' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">file_stage_out</code> attribute evaluates to a sequence of <em class="replaceable"><code>SOURCE</code></em> <em class="replaceable"><code>DESTINATION</code></em> pairs.</td></tr><tr><td align="left">144</td><td align="left">the provided RSL 'gass_cache' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">gass_cache</code> attribute evaluates to a string.</td></tr><tr><td align="left">145</td><td align="left">the provided RSL 'file_cleanup' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">file_clean_up</code> attribute evaluates to a sequence of strings.</td></tr><tr><td align="left">146</td><td align="left">the provided RSL 'scratch_dir' parameter is invalid</td><td align="left">Check that the RSL <code class="literal">scratch_dir</code> attribute evaluates to a string.</td></tr><tr><td align="left">147</td><td align="left">the provided scheduler-specific RSL parameter is invalid</td><td align="left">Check the LRM-specific documentation to determine what values are legal for the RSL extensions implemented by the LRM.</td></tr><tr><td align="left">148</td><td align="left">a required RSL attribute was not defined in the RSL spec</td><td align="left">Check that the RSL <code class="literal">executable</code> attribute is present in your job request RSL.
        Check that the RSL <code class="literal">restart</code> attributes is present in your restart RSL.</td></tr><tr><td align="left">149</td><td align="left">the gass_cache attribute points to an invalid cache directory</td><td align="left">Check that the RSL <code class="literal">gass_cache</code> attributes evaluates to a directory that exists or can be created.
        Check that the user's home file system is writable and not full.</td></tr><tr><td align="left">150</td><td align="left">the provided RSL 'save_state' parameter has an invalid value</td><td align="left">Check that the RSL <code class="literal">save_state</code> attribute has a value of <code class="literal">yes</code> or <code class="literal">no</code>.</td></tr><tr><td align="left">151</td><td align="left">the job manager could not open the RSL attribute validation file</td><td align="left">Check that <code class="filename"><code class="envar">$GLOBUS_LOCATION</code>/share/globus_gram_job_manager/globus-gram-job-manager.rvf</code> is present and readable on the job manager service node.
        Check that <code class="filename"><code class="envar">$GLOBUS_LOCATION</code>/share/globus_gram_job_manager/<em class="replaceable"><code>LRM</code></em>.rvf</code> is readable on the job manager service node if present.</td></tr><tr><td align="left">152</td><td align="left">the  job manager could not read the RSL attribute validation file</td><td align="left">Check that <code class="filename"><code class="envar">$GLOBUS_LOCATION</code>/share/globus_gram_job_manager/globus-gram-job-manager.rvf</code> is valid.
        Check that <code class="filename"><code class="envar">$GLOBUS_LOCATION</code>/share/globus_gram_job_manager/<em class="replaceable"><code>LRM</code></em>.rvf</code> is valid if present.</td></tr><tr><td align="left">153</td><td align="left">the provided RSL 'proxy_timeout' is invalid</td><td align="left">Check that RSL <code class="literal">proxy_timeout</code> attribute evaluates to a positive integer.</td></tr><tr><td align="left">154</td><td align="left">the RSL 'proxy_timeout' value is not greater than zero</td><td align="left">Check that RSL <code class="literal">proxy_timeout</code> attribute evaluates to a positive integer.</td></tr><tr><td align="left">155</td><td align="left">the job manager could not stage out a file</td><td align="left">Check that the source file being staged exists on the job manager service node.
        Check that the directory of the destination file being staged exists on the file service node.
        Check that the directory of the destination file being staged is writable by the user.
        Check that the destination file service is reachable by the job manager service node.</td></tr><tr><td align="left">156</td><td align="left">the job contact string does not match any which the job manager is handling</td><td align="left">Check that the job contact string matches one returned from a job request.</td></tr><tr><td align="left">157</td><td align="left">proxy delegation failed</td><td align="left">Check that the job manager service node trusts the signer of your credential.
        Check that you trust the signer of the job manager service node's credential. </td></tr><tr><td align="left">158</td><td align="left">the job manager could not lock the state lock file</td><td align="left">Check that the file system holding the job state directory supports POSIX advisory locking.
        Check that the job state directory is writable by the user on the service node.
        Check that the job state directory is not full.</td></tr><tr><td align="left">159</td><td align="left">an invalid globus_io_clientattr_t was used.</td><td align="left">Check that you have initialized the <code class="literal">globus_io_clientattr_t</code> attribute prior to using it with the GRAM client API.</td></tr><tr><td align="left">160</td><td align="left">an null parameter was passed to the gram library</td><td align="left">Check that you are passing legal values to all GRAM API calls.</td></tr><tr><td align="left">161</td><td align="left">the job manager is still streaming output</td><td align="left">OBSOLETE IN GRAM5</td></tr><tr><td align="left">162</td><td align="left">the authorization system denied the request</td><td align="left">Check with your GRAM system administrator to allow a particular certificate to be authorized.</td></tr><tr><td align="left">163</td><td align="left">the authorization system reported a failure</td><td align="left">Check with your system administrator to verify that the authorization system is configured properly.</td></tr><tr><td align="left">164</td><td align="left">the authorization system denied the request - invalid job id</td><td align="left">Check with your system administrator to verify that the authorization system is configured properly.
        Use a credential which is authorized to interact with a particular GRAM job.</td></tr><tr><td align="left">165</td><td align="left">the authorization system denied the request - not authorized to run the specified executable</td><td align="left">Check with your system administrator to verify that the authorization system is configured properly.
        Use a credential which is authorized to interact with a particular GRAM job.</td></tr><tr><td align="left">166</td><td align="left">the provided RSL 'user_name' parameter is invalid.</td><td align="left">Check that the RSL <code class="literal">user_name</code> attribute evaluates to a string.</td></tr><tr><td align="left">167</td><td align="left">the job is not running in the account named by the 'user_name' parameter.</td><td align="left">Ask with the GRAM system administrator to add an authorization entry to allow your credential to run jobs as the specified user account.</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-developer-protocols"></a>Chapter 10. Semantics and syntax of protocols</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#gram5-interface-protocol">1. GRAM5 Protocol</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136340584064">1.1. Framing</a></span></dt><dt><span class="section"><a href="#idm136336970640">1.2. Message Format</a></span></dt><dt><span class="section"><a href="#idm136318072608">1.3. Message Types</a></span></dt><dd><dl><dt><span class="section"><a href="#idm136318071968">1.3.1. Ping Request</a></span></dt><dt><span class="section"><a href="#idm136318104208">1.3.2. Job Request</a></span></dt><dt><span class="section"><a href="#idm136316035056">1.3.3. Status Request</a></span></dt><dt><span class="section"><a href="#idm136315037024">1.3.4. Callback Register Request</a></span></dt><dt><span class="section"><a href="#idm136315384016">1.3.5. Callback Unregister Request</a></span></dt><dt><span class="section"><a href="#idm136315444656">1.3.6. Job Cancel Request</a></span></dt><dt><span class="section"><a href="#idm136315874576">1.3.7. Job Signal Request</a></span></dt><dt><span class="section"><a href="#idm136315035648">1.3.8. Job State Updates</a></span></dt><dt><span class="section"><a href="#idm136315753216">1.3.9. Proxy Delegation</a></span></dt><dt><span class="section"><a href="#idm136315580816">1.3.10. Security Attributes</a></span></dt></dl></dd><dt><span class="section"><a href="#gram5-state-model">1.4. Job State Model</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="gram5-interface-protocol"></a>1. GRAM5 Protocol</h2></div></div></div><p>
The GRAM Protocol is used to handle communication between the Gatekeeper,
Job Manager, and GRAM Clients. The protocol is based on a subset of the
HTTP/1.1 protocol, with a small set of message types and responses sent
as the body of the HTTP requests and responses. This document describes
GRAM Protocol version 2 as used by GRAM5. This is compatible with with the
GRAM Protocol parsers in GRAM2 with extensions.
</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136340584064"></a>1.1. Framing</h3></div></div></div><p>
    GRAM messages are framed in HTTP/1.1 messages. However, only a small
    subset of the HTTP specification is used or understood by the GRAM system.
    All GRAM requests are HTTP POST messages. Only the following HTTP headers
    are understood:

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Host</li><li class="listitem">Content-Type (set to "application/x-globus-gram" in
        all cases)</li><li class="listitem">Content-Length</li><li class="listitem">Connection (set to "close" in all HTTP
        responses)</li></ul></div><p>

    </p><p>
    Only the following status codes are supported in response's HTTP
    Status-Line:

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">200 OK</li><li class="listitem">403 Forbidden</li><li class="listitem">404 Not Found</li><li class="listitem">500 Internal Server Error</li><li class="listitem">400 Bad Request</li></ul></div><p>
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136336970640"></a>1.2. Message Format</h3></div></div></div><p>
    All messages use the carriage return (ASCII value 13) followed by line feed
    (ASCII value 10) sequence to delimit lines. In all cases, a blank line
    separates the HTTP header from the message body. All
    <code class="literal">application/x-globus-gram</code> message bodies consist of
    attribute names followed by a colon, a space, and then the value of the
    attribute. When the value may contain a newline or double-quote character,
    a special escaping rule is used to encapsulate the complete string. This
    encapsulation consists of surrounding the string with double-quotes, and
    escaping all double-quote and backslash characters within the string with a
    backslash. All other characters are sent without modification. For example,
    the string 
    </p><pre class="programlisting">rsl: &amp;( executable = "/bin/echo" )
 ( arguments = "hello" )</pre><p>
    becomes
    </p><pre class="programlisting">rsl: "&amp;( executable = \"bin/echo\" )
  (arguments = \"hello\" )"</pre><p>
    </p><p>In GRAM5, protocol extensions are supported in the status update
    messages. These extensions are implemented as extra attribute names
    <span class="emphasis"><em>after</em></span> all of the attributes defined in the messages
    below. Older GRAM protocol parsers will ignore those extensions that occur
    after the attributes in the messages defined below. In GRAM5, the following
    extensions are used:

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">exit-code</code></span></dt><dd>Job exit code. Sent in job state callbacks and
            in job status replies when the job completes.</dd><dt><span class="term"><code class="literal">gt3-failure-type</code></span></dt><dd>Failure detail type for staging errors. Sent in
            job state callbacks and in job status replies when a job
            fails.</dd><dt><span class="term"><code class="literal">gt3-failure-message</code></span></dt><dd>Failure detail message for more context for
            errors. Sent in job state callbacks and in job status replies when
            a job fails.</dd><dt><span class="term"><code class="literal">gt3-failure-source</code></span></dt><dd>Failure detail message for the source of a
            failed file transfer.  Sent in job state callbacks and in job
            status replies when a job fails.</dd><dt><span class="term"><code class="literal">gt3-failure-destination</code></span></dt><dd>Failure detail message for the destination of a
            failed file transfer.  Sent in job state callbacks and in job
            status replies when a job fails.</dd><dt><span class="term"><code class="literal">version</code></span></dt><dd>Job manager package version.
            Sent in all messages from the job manager.</dd><dt><span class="term"><code class="literal">toolkit-version</code></span></dt><dd>Toolkit release that the job manager is running.
            Sent in all messages from the job manager.</dd></dl></div><p>
    </p><p>This is the only form of quoting which
    <code class="literal">application/x-globus-gram</code> messages support.  Use of
    <code class="literal">% HEX HEX</code> escapes (such as seen in URL encodings) is
    not meaningful for this protocol.
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm136318072608"></a>1.3. Message Types</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136318071968"></a>1.3.1. Ping Request</h4></div></div></div><p>
        A ping request is used to verify that the gatekeeper is configured
        properly to handle a named service. The ping request consists of the
        following:

</p><pre class="programlisting"><code class="literal">POST ping/</code><em class="replaceable"><code>job-manager-name</code></em><code class="literal"> HTTP/1.1</code>
<code class="literal">Host: </code><em class="replaceable"><code>host-name</code></em>
<code class="literal">Content-Type: application/x-globus-gram</code>
<code class="literal">Content-Length: </code><em class="replaceable"><code>message-size</code></em>

<code class="literal">protocol-version: </code><em class="replaceable"><code>version</code></em>
</pre><p>
        </p><p>
            The values of the message-specific strings are

            </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>job-manager-name</code></em></span></dt><dd>The name of the service to have the
                    gatekeeper check. The service name corresponds to one of
                    the gatekeeper's configured grid-services, and is usually
                    of the form
                    "jobmanager-<em class="replaceable"><code>LRM</code></em>".
                    </dd><dt><span class="term"><em class="replaceable"><code>host-name</code></em></span></dt><dd>The name of the host on which the
                    gatekeeper is running. This exists only for compatibility
                    with the HTTP/1.1 protocol.</dd><dt><span class="term"><em class="replaceable"><code>message-size</code></em></span></dt><dd>The length of the content of the
                    message, not including the HTTP/1.1
                    header.</dd><dt><span class="term"><em class="replaceable"><code>version</code></em></span></dt><dd>The version of the GRAM protocol which
                    is being used. For the protocol defined in this document,
                    the value must be the string "2".</dd></dl></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136318104208"></a>1.3.2. Job Request</h4></div></div></div><p>
        A job request is used to scheduler a job remotely using GRAM.  The ping
        request consists of the HTTP framing described above with the
        request-URI consisting of <em class="replaceable"><code>job-manager-name</code></em>,
        where <em class="replaceable"><code>job-manager name</code></em> is the name of the
        service to use to schedule the job. The format of a job request message
        consists of the following:

</p><pre class="programlisting"><code class="literal">POST </code><em class="replaceable"><code>job-manager-name</code></em>[@<em class="replaceable"><code>user-name</code></em>]<code class="literal"> HTTP/1.1</code>
<code class="literal">Host: </code><em class="replaceable"><code>host-name</code></em>
<code class="literal">Content-Type: application/x-globus-gram</code>
<code class="literal">Content-Length: </code><em class="replaceable"><code>message-size</code></em>

<code class="literal">protocol-version: </code><em class="replaceable"><code>version</code></em>
<code class="literal">job-state-mask: </code><em class="replaceable"><code>mask</code></em>
<code class="literal">callback-url: </code><em class="replaceable"><code>callback-contact</code></em>
<code class="literal">rsl: </code><em class="replaceable"><code>rsl-description</code></em></pre><p>
        </p><p>
        The values of the emphasized text items are as below:
        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>job-manager-name</code></em></span></dt><dd>The name of the service to submit the job
                request to. The service name corresponds to one of the
                gatekeeper's configured grid-services, and is usually of the
                form
                jobmanager-<em class="replaceable"><code>LRM</code></em>.</dd><dt><span class="term"><em class="replaceable"><code>user-name</code></em></span></dt><dd>Starting with GT4.0, a client may request
                that a certain account by used by the gatekeeper to start the
                job manager. This is done optionally by appending the @ symbol
                and the local user name that the job should be run as to the
                <em class="replaceable"><code>job-manager-name</code></em>. If the @ and
                username are not present, then the first grid map entry will be
                used. If the client credential is not authorized in the grid
                map to use the specified account, an authorization error will
                occur in the gatekeeper.</dd><dt><span class="term"><em class="replaceable"><code>host-name</code></em></span></dt><dd>The name of the host on which the gatekeeper
                is running. This exists only for compatibility with the
                HTTP/1.1 protocol.</dd><dt><span class="term"><em class="replaceable"><code>message-size</code></em></span></dt><dd>The length of the content of the message,
                not including the HTTP/1.1 header.</dd><dt><span class="term"><em class="replaceable"><code>version</code></em></span></dt><dd>The version of the GRAM protocol which is
                being used. For the protocol defined in this document, the
                value must be the string
                <code class="literal">2</code>.</dd><dt><span class="term"><em class="replaceable"><code>mask</code></em></span></dt><dd>An integer representation of the job state
                mask. This value is obtained from a bitwise-OR of the job state
                values which the client wishes to receive job status callbacks
                about. These meanings of the various job state values are
                defined in the GRAM Protocol API
                documentation.</dd><dt><span class="term"><em class="replaceable"><code>callback-contact</code></em></span></dt><dd>A https URL which defines a GRAM protocol
                listener which will receive job state updates. The from a
                bitwise-OR of the job state values which the client wishes to
                receive job status callbacks about. The job status update
                messages are defined below.</dd><dt><span class="term"><em class="replaceable"><code>rsl-description</code></em></span></dt><dd>A quoted string containing the RSL
                description of the job request.</dd></dl></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136316035056"></a>1.3.3. Status Request</h4></div></div></div><p>A status request is used by a GRAM client to get the current job
        state of a running job. This type of message can only be sent to a job
        manager's job-contact (as returned in the reply to a job request
        message).  The format of a job request message consists of the
        following:
</p><pre class="programlisting"><code class="literal">POST </code><em class="replaceable"><code>job-contact</code></em><code class="literal"> HTTP/1.1</code>
<code class="literal">Host: </code><em class="replaceable"><code>host-name</code></em>
<code class="literal">Content-Type: application/x-globus-gram</code>
<code class="literal">Content-Length: </code><em class="replaceable"><code>message-size</code></em>
<code class="literal">protocol-version: </code><em class="replaceable"><code>version</code></em>

<code class="literal">"status"</code>
</pre><p>
        </p><p>
        The values of the emphasized text items are as below:
        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>job-contact</code></em></span></dt><dd>The job contact string returned in a
                response to a job request message, or determined by querying
                the MDS system.</dd><dt><span class="term"><em class="replaceable"><code>host-name</code></em></span></dt><dd>The name of the host on which the job
                manager is running. This exists only for compatibility with the
                HTTP/1.1 protocol.</dd><dt><span class="term"><em class="replaceable"><code>message-size</code></em></span></dt><dd>The length of the content of the message,
                not including the HTTP/1.1 header.</dd><dt><span class="term"><em class="replaceable"><code>version</code></em></span></dt><dd>The version of the GRAM protocol which is
                being used. For the protocol defined in this document, the
                value must be the string <code class="literal">2</code>.</dd></dl></div><p>

        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136315037024"></a>1.3.4. Callback Register Request</h4></div></div></div><p>
        A callback register request is used by a GRAM client to register a new
        callback contact to receive GRAM job state updates.  This type of
        message can only be sent to a job manager's job-contact (as returned in
        the reply to a job request message). The format of a job request
        message consists of the following:
</p><pre class="programlisting"><code class="literal">POST </code><em class="replaceable"><code>job-contact</code></em><code class="literal"> HTTP/1.1</code>
<code class="literal">Host: </code><em class="replaceable"><code>host-name</code></em>
<code class="literal">Content-Type: application/x-globus-gram</code>
<code class="literal">Content-Length: </code><em class="replaceable"><code>message-size</code></em>

<code class="literal">protocol-version: </code><em class="replaceable"><code>version</code></em>
<code class="literal">"register </code><em class="replaceable"><code>mask</code></em><code class="literal"> </code><em class="replaceable"><code>callback-contact</code></em>"
</pre><p>
        </p><p>
        The values of the emphasized text items are as below:

        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>job-contact</code></em></span></dt><dd>The job contact string returned in a
                response to a job request message, or determined by querying
                the MDS system.</dd><dt><span class="term"><em class="replaceable"><code>host-name</code></em></span></dt><dd>The name of the host on which the job
                manager is running. This exists only for compatibility with the
                HTTP/1.1 protocol.</dd><dt><span class="term"><em class="replaceable"><code>message-size</code></em></span></dt><dd>The length of the content of the message,
                not including the HTTP/1.1 header.</dd><dt><span class="term"><em class="replaceable"><code>version</code></em></span></dt><dd>The version of the GRAM protocol which is
                being used. For the protocol defined in this document, the
                value must be the string
                <code class="literal">2</code>.</dd><dt><span class="term"><em class="replaceable"><code>mask</code></em></span></dt><dd>An integer representation of the job state
                mask. This value is obtained from a bitwise-OR of the job state
                values which the client wishes to receive job status callbacks
                about. These meanings of the various job state values are
                defined in the GRAM Protocol API
                documentation.</dd><dt><span class="term"><em class="replaceable"><code>callback-contact</code></em></span></dt><dd>A https URL which defines a GRAM protocol
                listener which will receive job state updates. The from a
                bitwise-OR of the job state values which the client wishes to
                receive job status callbacks about. The job status update
                messages are defined below.
                </dd></dl></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136315384016"></a>1.3.5. Callback Unregister Request</h4></div></div></div><p>A callback unregister request is used by a GRAM client to request
        that the job manager no longer send job state updates to the specified
        callback contact.  This type of message can only be sent to a job
        manager's job-contact (as returned in the reply to a job request
        message). The format of a job request message consists of the
        following:

        </p><pre class="programlisting"><code class="literal">POST </code><em class="replaceable"><code>job-contact</code></em><code class="literal"> HTTP/1.1</code>
<code class="literal">Host: </code><em class="replaceable"><code>host-name</code></em>
<code class="literal">Content-Type: application/x-globus-gram</code>
<code class="literal">Content-Length: </code><em class="replaceable"><code>message-size</code></em>

<code class="literal">protocol-version: </code><em class="replaceable"><code>version</code></em>
<code class="literal">"unregister </code><em class="replaceable"><code>callback-contact</code></em><code class="literal">"</code>
        </pre><p>
        </p><p>
        The values of the emphasized text items are as below:

        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>job-contact</code></em></span></dt><dd>The job contact string returned in a response to a job request
            message, or determined by querying the MDS system.</dd><dt><span class="term"><em class="replaceable"><code>host-name</code></em></span></dt><dd>The name of the host on which the job manager is running. This exists
                only for compatibility with the HTTP/1.1 protocol.</dd><dt><span class="term"><em class="replaceable"><code>message-size</code></em></span></dt><dd>The length of the content of the message, not including the HTTP/1.1
                header.</dd><dt><span class="term"><em class="replaceable"><code>version</code></em></span></dt><dd>The version of the GRAM protocol which is being used. For the
                protocol defined in this document, the value must be the string
                "2".</dd><dt><span class="term"><em class="replaceable"><code>callback-contact</code></em></span></dt><dd>A https URL which defines a GRAM protocol listener which should no
                longer receive job state updates. The from a bitwise-OR of the job
                state values which the client wishes to receive job status callbacks
                about. The job status update messages are defined @ref
                globus_gram_protocol_job_state_updates "below".
            </dd></dl></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136315444656"></a>1.3.6. Job Cancel Request</h4></div></div></div><p>
        A job cancel request is used by a GRAM client to request that the job
        manager terminate a job.  This type of message can only be sent to a
        job manager's job-contact (as returned in the reply to a job request
        message). The format of a job request message consists of the
        following:
        </p><pre class="programlisting"><code class="literal">POST </code><em class="replaceable"><code>job-contact</code></em><code class="literal"> HTTP/1.1</code>
<code class="literal">Host: </code><em class="replaceable"><code>host-name</code></em>
<code class="literal">Content-Type: application/x-globus-gram</code>
<code class="literal">Content-Length: </code><em class="replaceable"><code>message-size</code></em>

<code class="literal">protocol-version: </code><em class="replaceable"><code>version</code></em>
<code class="literal">"cancel"</code>
        </pre><p>
        </p><p>
        The values of the emphasized text items are as below:

        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>job-contact</code></em></span></dt><dd>The job contact string returned in a
                response to a job request message, or determined by querying
                the MDS system.</dd><dt><span class="term"><em class="replaceable"><code>host-name</code></em></span></dt><dd>The name of the host on which the job
                manager is running. This exists only for compatibility with the
                HTTP/1.1 protocol.</dd><dt><span class="term"><em class="replaceable"><code>message-size</code></em></span></dt><dd>The length of the content of the message,
                not including the HTTP/1.1 header.</dd><dt><span class="term"><em class="replaceable"><code>version</code></em></span></dt><dd>The version of the GRAM protocol which is
                being used. For the protocol defined in this document, the
                value must be the string
                <code class="literal">2</code>.</dd></dl></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136315874576"></a>1.3.7. Job Signal Request</h4></div></div></div><p>
        A job signal request is used by a GRAM client to request that the job
        manager process a signal for a job.  The arguments to the various
        signals are discussed in the protocol library documentation.
        The format of a job request message consists of the following:

        </p><pre class="programlisting"><code class="literal">POST </code><em class="replaceable"><code>job-contact</code></em><code class="literal"> HTTP/1.1</code>
<code class="literal">Host: </code><em class="replaceable"><code>host-name</code></em>
<code class="literal">Content-Type: application/x-globus-gram</code>
<code class="literal">Content-Length: </code><em class="replaceable"><code>message-size</code></em>

<code class="literal">protocol-version: </code><em class="replaceable"><code>version</code></em>
<code class="literal">"</code><em class="replaceable"><code>signal</code></em><code class="literal">"</code></pre><p>
        </p><p>
        The values of the emphasized text items are as below:

        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>job-contact</code></em></span></dt><dd>The job contact string returned in a
                response to a job request message, or determined by querying
                the MDS system.</dd><dt><span class="term"><em class="replaceable"><code>host-name</code></em></span></dt><dd>The name of the host on which the job
                manager is running. This exists only for compatibility with the
                HTTP/1.1 protocol.</dd><dt><span class="term"><em class="replaceable"><code>message-size</code></em></span></dt><dd>The length of the content of the message,
                not including the HTTP/1.1 header.</dd><dt><span class="term"><em class="replaceable"><code>version</code></em></span></dt><dd>The version of the GRAM protocol which is
                being used. For the protocol defined in this document, the
                value must be the string
                <code class="literal">2</code>.</dd><dt><span class="term"><em class="replaceable"><code>signal</code></em></span></dt><dd>A quoted string containing the signal number
                and its parameters.</dd></dl></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136315035648"></a>1.3.8. Job State Updates</h4></div></div></div><p>
    A job status update message is sent by the job manager to all registered
    callback contacts when the job's status changes. The format of the job
    status update messages is as follows:
    </p><pre class="programlisting"><code class="literal">POST </code><em class="replaceable"><code>callback-contact</code></em><code class="literal"> HTTP/1.1</code>
<code class="literal">Host: </code><em class="replaceable"><code>host-name</code></em>
<code class="literal">Content-Type: application/x-globus-gram</code>
<code class="literal">Content-Length: </code><em class="replaceable"><code>message-size</code></em>

<code class="literal">protocol-version: </code><em class="replaceable"><code>version</code></em>
<code class="literal">job-manager-url: </code><em class="replaceable"><code>job-contact</code></em>
<code class="literal">status: </code><em class="replaceable"><code>status-code</code></em>
<code class="literal">failure-code: </code><em class="replaceable"><code>failure-code</code></em>
    </pre><p>
    </p><p>
    The values of the emphasized text items are as below:
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>callback-contact</code></em></span></dt><dd>The callback contact string registered with the
            job manager either by being passed as the
            <em class="replaceable"><code>callback-contact</code></em> in a job request
            message or in a callback register message.</dd><dt><span class="term"><em class="replaceable"><code>host-name</code></em></span></dt><dd>The host part of the callback-contact URL. This
            exists only for compatibility with the HTTP/1.1
            protocol.</dd><dt><span class="term"><em class="replaceable"><code>message-size</code></em></span></dt><dd>The length of the content of the message, not
            including the HTTP/1.1 header.</dd><dt><span class="term"><em class="replaceable"><code>version</code></em></span></dt><dd>The version of the GRAM protocol which is being
            used. For the protocol defined in this document, the value must be
            the string <code class="literal">2</code>.</dd><dt><span class="term"><em class="replaceable"><code>job-contact</code></em></span></dt><dd>The job contact of the job which has changed
            states.</dd></dl></div><p>
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136315753216"></a>1.3.9. Proxy Delegation</h4></div></div></div><p>
    A proxy delegation message is sent by the client to the job manager to
    initiate a delegation handshake to generate a new proxy credential for the
    job manager. This credential is used by the job manager or the job when
    making further secured connections. The format of the delegation message is
    as follows:
    </p><pre class="programlisting"><code class="literal">POST </code><em class="replaceable"><code>callback-contact</code></em><code class="literal"> HTTP/1.1</code>
<code class="literal">Host: </code><em class="replaceable"><code>host-name</code></em>
<code class="literal">Content-Type: application/x-globus-gram</code>
<code class="literal">Content-Length: </code><em class="replaceable"><code>message-size</code></em>

<code class="literal">protocol-version: </code><em class="replaceable"><code>version</code></em>
<code class="literal">"renew"</code></pre><p>
    </p><p>
    If a successful (200) reply is sent in response to this message, then
    the client will procede with a GSI delegation handshake. The tokens in this
    handshake will be framed with a 4 byte big-endian token length header. The
    framed tokens will then be wrapped using the
    GLOBUS_IO_SECURE_CHANNEL_MODE_SSL_WRAP wrapping mode. The job manager will
    frame response tokens in the same manner. After the job manager receives
    its final delegation token, it will respond with another response message
    that indicates whether the delegation was processed or not. This response
    message is a standard GRAM response message.  
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm136315580816"></a>1.3.10. Security Attributes</h4></div></div></div><p>
        The following security attributes are needed to communicate with the
        Gatekeeper:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Authentication must be done using GSSAPI mutual
            authentication</li><li class="listitem">Messages must be wrapped with support for the
            delegation message. When using Globus I/O, this is accomplished by
            using the the GLOBUS_IO_SECURE_CHANNEL_MODE_GSI_WRAP wrapping
            mode.</li></ul></div><p>
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gram5-state-model"></a>1.4. Job State Model</h3></div></div></div><p>
       As the GRAM service processes a job, the job undergoes a series of state
       transitions. These states and their meanings follow:

        </p><div class="table"><a name="idm136315579872"></a><p class="title"><b>Table 10.1. GRAM Job States</b></p><div class="table-contents"><table summary="GRAM Job States" border="1" width="700px"><colgroup><col><col></colgroup><thead><tr><th><p>State</p></th><th><p>Meaning</p></th></tr></thead><tbody><tr><td><p><code class="constant">GLOBUS_GRAM_PROTOCOL_JOB_STATE_UNSUBMITTED</code></p></td><td><p>Initial job state</p></td></tr><tr><td><p><code class="constant">GLOBUS_GRAM_PROTOCOL_JOB_STATE_STAGE_IN</code></p></td><td><p>Job staging in
                        progress</p></td></tr><tr><td><p><code class="constant">GLOBUS_GRAM_PROTOCOL_JOB_STATE_PENDING</code></p></td><td><p>Job submitted to LRM, awaiting
                        execution</p></td></tr><tr><td><p><code class="constant">GLOBUS_GRAM_PROTOCOL_JOB_STATE_ACTIVE</code></p></td><td><p>Job executing</p></td></tr><tr><td><p><code class="constant">GLOBUS_GRAM_PROTOCOL_JOB_STATE_SUSPENDED</code></p></td><td><p>Job made progress executing but is
                        now suspended</p></td></tr><tr><td><p><code class="constant">GLOBUS_GRAM_PROTOCOL_JOB_STATE_STAGE_OUT</code></p></td><td><p>Job staging in progress after job
                        completed</p></td></tr><tr><td><p><code class="constant">GLOBUS_GRAM_PROTOCOL_JOB_STATE_DONE</code></p></td><td><p>Job completed
                        successfully</p></td></tr><tr><td><p><code class="constant">GLOBUS_GRAM_PROTOCOL_JOB_STATE_FAILED</code></p></td><td><p>Job was canceled or
                        failed</p></td></tr></tbody></table></div></div><p><br class="table-break">
    </p><div class="figure"><a name="idm136315914080"></a><p class="title"><b>Figure 10.1. GRAM State Transitions</b></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="GRAM5_states.png" align="middle" alt="GRAM State Transitions"></div></div></div><br class="figure-break"></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="gram5-developer-relateddocs"></a>Chapter 11. Related Documentation</h1></div></div></div><p>No related documentation links have been determined at this time.</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="gram5-developer-internal-components"></a>Chapter 12. Internal Components</h1></div></div></div><p><a class="ulink" href="internal-components.html" target="_top">Internal Components</a></p></div><div class="glossary"><div class="titlepage"><div><div><h1 class="title"><a name="glossary-gram5Developer"></a>Glossary</h1></div></div></div><div class="glossdiv"><h3 class="title">C</h3><dl><dt><a name="cert"></a><span class="glossterm">certificate</span></dt><dd class="glossdef"><p> A public key plus information about the certificate owner bound
                              together by the digital signature of a CA. In the case of a CA
                              certificate, the certificate is self signed, i.e. it was signed using
                              its own private key.</p></dd></dl></div><div class="glossdiv"><h3 class="title">G</h3><dl><dt><a name="gatekeeper"></a><span class="glossterm">Gatekeeper</span></dt><dd class="glossdef"><p>A part of GRAM that runs as root and
                        authenticates clients prior to starting the
                        <a href="#job-manager" class="glossterm"><em class="glossterm">Job Manager</em></a>.</p></dd><dt><a name="grid-map-file"></a><span class="glossterm">grid map file</span></dt><dd class="glossdef"><p> A file containing entries mapping certificate subjects to local user
                              names. This file can also serve as a access control list for GSI
                              enabled services and is typically found in
                                    <code class="filename">/etc/grid-security/grid-mapfile</code>. For more
                              information see the Gridmap section <a href="../../gsic/admin/#setting-up-gridmap" class="olink">here</a>.</p></dd></dl></div><div class="glossdiv"><h3 class="title">J</h3><dl><dt><a name="job-manager"></a><span class="glossterm">Job Manager</span></dt><dd class="glossdef"><p>A part of GRAM that runs as a local
                        user and interfaces with a
                        <a href="#local-resource-manager" class="glossterm"><em class="glossterm">Local Resource Manager</em></a>
                        for that user.</p></dd></dl></div><div class="glossdiv"><h3 class="title">L</h3><dl><dt><a name="local-resource-manager"></a><span class="glossterm">Local Resource Manager</span> (LRM)</dt><dd class="glossdef"><p>
                        A system which controls access to a compute resource,
                        such as a compute cluster or parallel computer.
                        Such systems provide batch execution interfaces,
                        which GRAM uses to execute jobs.
                        <a href="#condor" class="glossterm"><em class="glossterm">Condor</em></a>,
                        <a href="#pbs" class="glossterm"><em class="glossterm">Portable Batch System</em></a>,
                        <a href="#Oracle-GridEngine" class="glossterm"><em class="glossterm">GridEngine</em></a> are examples
                        of local resource managers.
                    </p><p>See Also Condor, Portable Batch System, Oracle GridEngine.</p></dd><dt><a name="local-resource-manager-adapter"></a><span class="glossterm">LRM Adapter</span></dt><dd class="glossdef"><p>
                        The interface code between 
                        a <a href="#local-resource-manager" class="glossterm"><em class="glossterm">Local Resource Manager</em></a> and
                        GRAM. In most cases, this consists of a Perl
                        module that implements the
                        <code class="classname">Globus::GRAM::JobManager</code> class
                        and a <a href="#seg" class="glossterm"><em class="glossterm">Scheduler Event Generator</em></a>
                        module.
                    </p><p>See Also Local Resource Manager.</p></dd></dl></div><div class="glossdiv"><h3 class="title">P</h3><dl><dt><a name="proxy-cert"></a><span class="glossterm">proxy certificate</span></dt><dd class="glossdef"><p> A short lived certificate issued using a EEC. A proxy certificate
                              typically has the same effective subject as the EEC that issued it and
                              can thus be used in its place. GSI uses proxy certificates for single
                              sign on and delegation of rights to other entities.</p><p>For more information about types of proxy certificates and their
                              compatibility in different versions of GT, see <a class="ulink" href="http://dev.globus.org/wiki/Security/ProxyCertTypes" target="_top">http://dev.globus.org/wiki/Security/ProxyCertTypes</a>.</p></dd></dl></div><div class="glossdiv"><h3 class="title">R</h3><dl><dt><a name="rsl"></a><span class="glossterm">Resource Specification Language</span> (RSL)</dt><dd class="glossdef"><p>Term used to describe a GRAM job for GT2 and GT3. (Note: This is not
                              the same as RLS - the Replica Location Service) </p></dd></dl></div><div class="glossdiv"><h3 class="title">S</h3><dl><dt><a name="seg"></a><span class="glossterm">Scheduler Event Generator</span> (SEG)</dt><dd class="glossdef"><p>The Scheduler Event Generator (SEG) is a program which uses
                              scheduler-specific monitoring modules to generate job state change events.
                              Depending on scheduler-specific requirements, the SEG may need to run with
                              privileges to enable it to obtain scheduler event notifications. As such, one
                              SEG runs per scheduler resource. For example, on a host which provides access
                              to both PBS and fork jobs, two SEGs, running at (potentially) different privilege
                              levels will be running.
                              One SEG instance exists for any particular scheduled resource instance (one for all
                              homogeneous PBS queues, one for all fork jobs, etc).
                              The SEG is implemented in an executable called the globus-scheduler-event-generator,
                              located in the Globus Toolkit's libexec directory.
                        </p></dd></dl></div></div><div class="index"><div class="titlepage"><div><div><h1 class="title"><a name="idm136351883808"></a>Index</h1></div></div></div><div class="index"><div class="indexdiv"><h3>A</h3><dl><dt>apis, <a class="indexterm" href="#gram5-apis">APIs</a></dt><dd><dl><dt>overview, <a class="indexterm" href="#idm136313777376">Programming Model Overview</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>C</h3><dl><dt>compatibility, <a class="indexterm" href="#gram5-compatibility">Backward compatibility summary</a></dt></dl></div><div class="indexdiv"><h3>D</h3><dl><dt>debugging, <a class="indexterm" href="#gram5-debugging">Debugging</a></dt><dt>dependencies, <a class="indexterm" href="#gram5-dependencies">Technology dependencies</a></dt></dl></div><div class="indexdiv"><h3>E</h3><dl><dt>errors, <a class="indexterm" href="#gram5-error-codes">Errors</a></dt></dl></div><div class="indexdiv"><h3>F</h3><dl><dt>features, <a class="indexterm" href="#gram5-features">Feature summary</a></dt></dl></div><div class="indexdiv"><h3>P</h3><dl><dt>platforms, tested, <a class="indexterm" href="#gram5-platforms">Tested platforms</a></dt></dl></div><div class="indexdiv"><h3>T</h3><dl><dt>troubleshooting, <a class="indexterm" href="#gram5-troubleshooting">Troubleshooting</a>, <a class="indexterm" href="#gram5-troubleshooting-client">GRAM Client Troubleshooting</a></dt><dd><dl><dt>errors, <a class="indexterm" href="#gram5-troubleshooting">Troubleshooting</a>, <a class="indexterm" href="#gram5-troubleshooting-client">GRAM Client Troubleshooting</a></dt></dl></dd></dl></div></div></div></div>
